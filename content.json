{"meta":{"title":"Ariman's Lazy Blog","subtitle":null,"description":"微服务 自动化测试 契约测试","author":"Ariman","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"从一个3000行的登录页面聊PageObject","slug":"从一个3000行的登录页面聊PageObject","date":"2023-06-01T02:47:51.000Z","updated":"2023-06-08T07:56:41.927Z","comments":true,"path":"2023/06/01/从一个3000行的登录页面聊PageObject/","link":"","permalink":"http://yoursite.com/2023/06/01/%E4%BB%8E%E4%B8%80%E4%B8%AA3000%E8%A1%8C%E7%9A%84%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E8%81%8APageObject/","excerpt":"最近帮助一个客户项目改进它们的自动化测试，SUT是一个分别基于iOS和Android进行原生开发的APP，客户团队的即有测试代码使用Cucumber、Appium、WebDriver构建，属于非常典型的UI自动化测试套装。代码的层级结构大致如下： 1234567891011121314151617181920└── Tests/ ├── features/ │ ├── login.feature │ ├── shopping.feature │ ├── register.feature │ └── ... ├── glues/ │ ├── login.glue │ ├── shopping.glue │ ├── register.glue │ └── ... ├── pageObjects/ │ ├── loginPage.java │ ├── homePage.java │ ├── paymentPage.java │ └── ... └── utils/ ├── fileHandling.java ├── environmentConfig.java └── ... 整个测试代码粗看起来有板有眼，feature文件中合理的使用了数据驱动，glue文件中对step的定义和参数化都还不错。但翻看到PageObject时就傻眼了，一个登录页面的PageObject竟然有3000行代码！是的，你没看错，足足3000行，是QA测试登录页面的PageObject代码，而不是Dev开发登录页面的代码。这个页面本身没有复杂的交互与功能设计，比如Social Login、单页注册等，就是一个非常简单、传统的登录页面，类似下面这样：","text":"最近帮助一个客户项目改进它们的自动化测试，SUT是一个分别基于iOS和Android进行原生开发的APP，客户团队的即有测试代码使用Cucumber、Appium、WebDriver构建，属于非常典型的UI自动化测试套装。代码的层级结构大致如下： 1234567891011121314151617181920└── Tests/ ├── features/ │ ├── login.feature │ ├── shopping.feature │ ├── register.feature │ └── ... ├── glues/ │ ├── login.glue │ ├── shopping.glue │ ├── register.glue │ └── ... ├── pageObjects/ │ ├── loginPage.java │ ├── homePage.java │ ├── paymentPage.java │ └── ... └── utils/ ├── fileHandling.java ├── environmentConfig.java └── ... 整个测试代码粗看起来有板有眼，feature文件中合理的使用了数据驱动，glue文件中对step的定义和参数化都还不错。但翻看到PageObject时就傻眼了，一个登录页面的PageObject竟然有3000行代码！是的，你没看错，足足3000行，是QA测试登录页面的PageObject代码，而不是Dev开发登录页面的代码。这个页面本身没有复杂的交互与功能设计，比如Social Login、单页注册等，就是一个非常简单、传统的登录页面，类似下面这样： 但就是这样一个简单得不能再简单的登录页面，却被写出了3000行代码的PageObject，着实让人惊讶不已。 3000行的登录页面PageObject基于众所周知的原因，这里无法展现该PageObject的源代码，但为了便于描述，我大概模拟了其中的两个很有个性的函数代码，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class LoginPage &#123; public String usernameFiled = &quot;#username-filed&quot;; public String passwordFiled = &quot;#password-filed&quot;; public String loginButton = &quot;#login-button&quot;; ... public boolean loginSuccessfully(String username, String password) &#123; boolean isTrue = true; try &#123; driver.get(&quot;https://www.example.com/login-page&quot;); logger.info(&quot;get login page&quot;); isTrue = true; &#125; catch (Exception e) &#123; logger.info(&quot;get login page failed&quot;); isTrue = false; &#125; try &#123; logger.info(&quot;start login&quot;); WebElement usernameInput = driver.findElement(By.id(usernameFiled)); usernameInput.sendKeys(username); WebElement passwordInput = driver.findElement(By.id(passwordFiled)); passwordInput.sendKeys(password); WebElement loginButton = driver.findElement(By.id(this.loginButton)); loginButton.click(); isTrue = true; &#125; catch (Exception e) &#123; logger.info(&quot;login failed&quot;); isTrue = false; &#125; return isTrue; &#125; public boolean loginFailed(String username, String password) &#123; boolean isTrue = false; try &#123; driver.get(&quot;https://www.example.com/login-page&quot;); logger.info(&quot;get login page&quot;); isTrue = true; &#125; catch (Exception e) &#123; logger.info(&quot;get login page failed&quot;); isTrue = false; &#125; try &#123; logger.info(&quot;start login&quot;); WebElement usernameInput = driver.findElement(By.id(usernameFiled)); usernameInput.sendKeys(username); WebElement passwordInput = driver.findElement(By.id(passwordFiled)); passwordInput.sendKeys(password); WebElement loginButton = driver.findElement(By.id(this.loginButton)); loginButton.click(); isTrue = true; &#125; catch (Exception e) &#123; logger.info(&quot;login failed&quot;); isTrue = false; &#125; return isTrue; &#125; ...&#125; 这段代码的问题，相信很多同学一眼就能发现： loginSuccessfully方法与loginFailed方法的实现代码基本就是完全重复的，非常冗余。后面我们会聊到，这种基于测试场景的方法，是不应该写到PageObject里面的。正是这种场景化的PageObject方法给这个登录页面”贡献”了大量的代码行数； 那个遍地开花的isTrue就是个”呵呵”。作者的意图大概是期望在测试执行的不同节点上收集测试步骤的执行结果（成功或者失败），然后给上层的glue文件提供这些结果数据。这些isTrue的遍地赋值在降低代码阅读流畅度的同时，还增加了代码的复杂度，从而增加了发生错误的几率，比如在一些复杂的操作中，例如在需要循环或者重复执行的操作中，就发现了多处的赋值错误。而更可悲的是，这些返回给glue层的isTrue几乎全部都没有被使用； try-catch的目的就是为了打印日志吗？ 这个pageObject里面充斥了大量这样的try-catch，除了给isTrue赋值，唯一干的活儿就是打印日志。try-catch的使用会大大的增加代码的复杂度，基本都不建议在PageObject中直接使用，即便真的需要使用try-catch来处理一些特殊的事件，也最好把它放到basePage或者utils里面去（这个后文会聊到）； 测试中的失效和异常被生吞了，这是滥用try-catch带来的最严重的后果，像上面代码那样，捕获失效异常后不做任何实质性处理，测试压根儿就不会挂，除非查看日志，不然可能都不知道测试找不到元素了； 除此之外，原始代码中的问题还有很多，这里无法一一列举。当然，写作这篇文章的初衷并不是要去怎么批判别人的代码，而是希望借此机会分享一些我个人围绕PageObject的实操心得。 下面的内容不包括对PageObject的基础介绍，相关的内容可以在网上找到很多，需要了解的同学可以自行查阅，或者直接调戏ChatGPT也是不错的选择。 PageObject文件中的命名PageObject文件中会定义大量的变量和方法，对这些属性的合理命名能让你在编写测试案例时得心应手，相反的，如果命名不当，则会让你的测试案例晦涩难懂。比如，页面上有一个按钮叫Submit，如果你这样命名： 12345678910public class OrderPage &#123; ... public String submit = &quot;#submit&quot;; ... public void submit() &#123;&#125; public void submitSucceed() &#123;&#125; ...&#125; 那你写出的测试案例就可能存在歧义，比如order.submit到底是在引用元素还是在点击按钮？又或者order.submitSucceed到底是在点击按钮还是在判断submit成功？请不要鄙视我说”.submit没带括号就是引用元素，.submit()带了括号就是点击按钮”，又或者”.submitSucceed返回void就是单纯点击按钮，.submitSucceed返回boolean就是判断成功”，要知道在阅读评审测试案例时，更加准确表意的命名能帮助我们快速理解测试案例，而基于语法的逻辑判断在这里是显然是低效且无意义的。所以，像下面这样更加表意的命名能让使用它们的测试案例阅读起来更加的顺畅。 12345678910public class OrderPage &#123; ... public String submitButton = &quot;#submit&quot;; ... public void clickSubmit() &#123;&#125; public boolean isSubmitSucceed() &#123;&#125; ...&#125; 总的来说，对于PageObject中属性的命名，我们可以参考这些原则： 对元素的命名要以组件名结尾，比如loginButton, usernameFiled, acceptOption等等； 对操作方法的命名要以动词开头，比如clickLoginButton，inputPassword，scrollUp等等； 对判断或者断言方法的命名以连系动词或者情态动词开头，比如isLoading, isNotClickable, shouldDisplayWelcomeMessageWith等等； PageObject的EAC &amp; EACP模式无论SUT是web APP或mobile APP，我们在PageObject中只会做三种事情：定位元素、定义方法，以及断言结果（对于”要不要在PageObject中进行断言”的讨论会在下面细聊）。通常情况下，我们可能会在PageObject里面直接创建这些内容，类似下面的代码： 123456789101112131415161718192021222324252627282930313233public class LoginPage &#123; public String usernameFiled = &quot;#username-filed&quot;; public String passwordFiled = &quot;#password-filed&quot;; public String loginButton = &quot;#login-button&quot;; ... public void inputUsername(String username) &#123;&#125; public void inputPassword(String password) &#123;&#125; public void clickLoginButton() &#123;&#125; ... public boolean isLogoDisplayed() &#123;&#125; public boolean isLoginButtonClickable() &#123;&#125; ...&#125;public class LoginPageTests &#123; ... @Test void testLoginPage() &#123; loginPage.isLogoBeDisplayed(); loginPage.inputUsername(&quot;username&quot;); loginPage.inputPassword(&quot;password&quot;); loginPage.isLoginButtonBeClickable(); loginPage.clickLoginButton(); &#125;&#125; 这样的写法在被测页面内容简单的情况下没有任何问题，但当页面内容复杂、交互操作多样化时，PageObject里面的元素与方法可能就会有几十甚至上百之多，这时如果又是多人协作编写这个文件，就可能出现各种元素、操作与断言的交错混杂，代码的清晰度会降低，有时甚至会出现重复定义的方法，这在真实的项目中我已经多次遇到过了。所以，出于个人习惯，我一般更喜欢这样： 12345678910111213141516171819202122232425262728293031323334353637public class LoginPage &#123; private static class Elements &#123; private static final String usernameFiled = &quot;#username-filed&quot;; private static final String passwordFiled = &quot;#password-filed&quot;; private static final String loginButton = &quot;#login-button&quot;; ... &#125; public static class Actions &#123; public static void inputUsername(String username) &#123;&#125; public static void inputPassword(String password) &#123;&#125; public static void clickLoginButton() &#123;&#125; ... &#125; public static class Checks &#123; public static void shouldLoginButtonBeClickable() &#123;&#125; public static void shouldLogoBeDisplayed() &#123;&#125; ... &#125;&#125;public class LoginPageTests &#123; ... @Test void testLoginPage() &#123; LoginPage.Checks.shouldLogoBeDisplayed(); LoginPage.Actions.inputUsername(&quot;username&quot;); LoginPage.Actions.inputPassword(&quot;password&quot;); LoginPage.Checks.shouldLoginButtonBeClickable(); LoginPage.Actions.clickLoginButton(); &#125;&#125; 也就是把元素、操作、断言这三类属性进行归类，这样的好处是无论页面元素再复杂、协同编写这个文件的人再多，只要按照上述归类添加页面属性，整个PageObject的代码都会显得相对归整，即便有人命名了一个非常不表意的方法，只要这个方法在Actions里面，使用者也不会把它当做元素或者断言来使用，这就是EAC(Elements, Actions, Checks)模式。 另外，除了PageObject里面定义的单步方法（下面会讲到定义方法的最小粒度原则），我们的测试案例中还经常会用到一些复合的方法。比如，如果我的目的是测试登录，那我的测试案例可以这么写： 123456789101112131415public class LoginPageTests &#123; ... @Test void testLoginPage() &#123; LoginPage.Checks.shouldLogoBeDisplayed(); LoginPage.Actions.inputUsername(&quot;username&quot;); LoginPage.Actions.inputPassword(&quot;password&quot;); LoginPage.Checks.shouldLoginButtonBeClickable(); LoginPage.Actions.clickLoginButton(); ... &#125;&#125; 这是没有问题的。而当我要测试HomePage时，第一步也需要登录，那么可能会这么写： 12345678910111213public class HomePageTests &#123; ... @Test void testHomePage() &#123; LoginPage.Actions.inputUsername(&quot;username&quot;); LoginPage.Actions.inputPassword(&quot;password&quot;); LoginPage.Actions.clickLoginButton(); HomePage.Checks.shouldWelcomeMessageDisplayed(); ... &#125;&#125; 但很显然，登录对HomePage的测试来说只是一个前置步骤，并不是测试目标，所以没必要调用三个方法来做登录，这里更需要的是一个能一键登录的方法，所以我们就可以这么写： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class LoginPage &#123; private static class Elements &#123; private static final String usernameFiled = &quot;#username-filed&quot;; private static final String passwordFiled = &quot;#password-filed&quot;; private static final String loginButton = &quot;#login-button&quot;; ... &#125; public static class Actions &#123; public static void inputUsername(String username) &#123;&#125; public static void inputPassword(String password) &#123;&#125; public static void clickLoginButton() &#123;&#125; ... &#125; public static class Checks &#123; public static void shouldLoginButtonBeClickable() &#123;&#125; public static void shouldLogoBeDisplayed() &#123;&#125; ... &#125; public static class Procedure &#123; public static void login(String username, String password) &#123; Actions.inputUsername(username); Actions.inputPassword(password); Actions.clickLoginButton(); &#125; ... &#125;&#125;public class HomePageTests &#123; ... @Test void testHomePage() &#123; LoginPage.Procedure.login(&quot;username&quot;, &quot;password&quot;); HomePage.Checks.shouldWelcomeMessageDisplayed(); ... &#125;&#125; 也就是在EAC的基础上添加一个Procedure的归类，构成EACP模式。Procedure中定义各种复合方法，从而使调用相应方法的测试案例更加简洁。类似的思路在有些网上资料中也被叫做Service，因为它表征的是当前页面提供的业务功能（即服务），而不再是单纯的操作步骤。 当然，除了创建复合方法之外，我们还可以创建支持链式调用的PageObject来达到”一行代码登录”的目的，比如loginPage.inputUsername(&quot;username&quot;).inputPassword(&quot;password&quot;).clickLoginButton()，但从代码的可读性与调试的便利性上来说，我个人还是更倾向于复合方法。 是否需要在PageObject内部进行断言？“是否在PageObject内部进行断言？”这是一个聊到PageObject就绕不过去的问题（面试必考题&lt;-_&lt;-)。在Selenium的官网上使用了should never来告诫众生： MartinFowler的博客中也阐述了类似的倾向。所以，通常情况下，我们可能会这么使用断言： 12345678910111213141516171819public class ShoppingPage &#123; ... public void clickSubmitButton() &#123; WebElement submitButton = driver.findElement(By.id(this.submitButton)); submitButton.click(); &#125;&#125;public class ShoppingPageTests &#123; ... @Test void testShoppingPage() &#123; ... shoppingPage.clickSubmitButton(); WebElement submitResultBanner = driver.findElement(By.id(this.submitResultBanner)); assertTrue(submitResultBanner.isDisplayed()); &#125;&#125; 这样的写法，就我个人的喜好而言，有两处槽点： 首先，我不喜欢在测试文件中暴露driver对象。在我看来，测试文件应该偏向于更加流畅的描述性写法，通过合理的函数与对象命令，让阅读测试方法达到近似阅读测试案例（文本）的效果是最好的，而靠近这个目标的重要方式之一就是把技术性的API调用封装到测试文件的下一层，所以，我更喜欢把driver封装到PageObject里面去； 其次，我们在测试中很多时候会复用断言，比如，上面的示例中，模拟了一个点击submit按钮后、检查提交结果的断言，这样的断言在当前页面的测试中很可能被多次用到，比如测试不同的参数组合与提交操作，这时在每个测试案例中都去写这么两行断言显然有些冗余，所以我们可能会想到创建一个单独的方法来做这个断言： 1234567891011121314public class ShoppingPageTests &#123; ... @Test void testShoppingPage() &#123; ... shoppingPage.clickSubmitButton(); assertSubmitResultBanner(); &#125; private void assertSubmitResultBanner() &#123; WebElement submitResultBanner = driver.findElement(By.id(this.submitResultBanner)); assertTrue(submitResultBanner.isDisplayed()); &#125;&#125; 那么既然我们为了复用已经把断言进行了封装，那为什么不封装到PageObject里面去呢？基于测试文件专注呈现测试案例的原则，这种为了优化编码的写法就最好放到测试文件的下一层去； 所以，我会在PageObject里面去对断言的代码进行封装，例如这样： 123456789101112131415161718192021222324252627282930313233public class ShoppingPage &#123; ... public static class Actions &#123; ... public static void clickSubmitButton() &#123; WebElement submitButton = driver.findElement(By.id(Elements.submitButton)); submitButton.click(); &#125; &#125; public static class Checks &#123; ... public static void shouldDisplaySubmitSucceedBanner() &#123; WebElement submitResultBanner = driver.findElement(By.id(Elements.submitResultBanner)); assertTrue(submitResultBanner.isDisplayed()); &#125; &#125;&#125;public class ShoppingPageTests &#123; ... @Test void testShoppingPage() &#123; ... ShoppingPage.Actions.clickSubmitButton(); ShoppingPage.Checks.shouldDisplaySubmitSucceedBanner(); &#125;&#125; 至于为什么各路大佬都不提倡在PageObject里面写断言，而要在测试文件里面去写，原因其实很简单：“断言”是测试的行为，不是页面的行为，PageObject只应该是对页面的抽象，不对测试负责，所以提倡仅在测试里面才进行断言。而我之所以仍然乐于在PageObject里面写Checks，还在于我对断言进行了进一步的区分，即我仅仅在PageObject里面定义断言，但不会在PageObject里面执行断言，断言只应该在上层的测试文件中才被执行。比如，像下面这样的代码在我看来就是不适宜的，它既破坏了操作方法的单一性原则，又对上一层的测试文件隐藏了断言检查，是我们应该尽量避免的。 12345678910111213141516171819202122public class ShoppingPage &#123; ... public static class Actions &#123; ... public static void clickSubmitButton() &#123; WebElement submitButton = driver.findElement(By.id(Elements.submitButton)); submitButton.click(); Checks.shouldDisplaySubmitSucceedBanner(); &#125; &#125; public static class Checks &#123; ... public static void shouldDisplaySubmitSucceedBanner() &#123; WebElement submitResultBanner = driver.findElement(By.id(Elements.submitResultBanner)); assertTrue(submitResultBanner.isDisplayed()); &#125; &#125;&#125; 最后想提一下，其实MartinFowler的那篇博客也承认”是否在PageObject中包含断言”是一个开放的问题，没有标准答案，它还描述了一些在PageObject中包含断言的优势。所以，对于这个问题，YES也好NO也罢，大家可根据自己的理解来选择，只要在一套测试中按照相同的原则、做到代码的整洁划一就能写出很好的测试。 适当定义PageComponentObject有时我们会遇到一些内容比较复杂的页面包含很多相同类型的UI组件，又或者一些相同的UI组件经常出现在不同的页面当中，比如list、card、table、popup等等。这些组件通常都由固定的内容和布局组成，比如card一般都会包含title、image、description、button。对于这些UI组件，如果我们要在一个PageObject里面平铺的创建他们的全部测试对象，那代码可能非常冗余，类似这样： 123456789101112131415161718public class AdminPage &#123; ... public String adminUserCardTitle = &quot;#userCard-title-0&quot;; public String adminUserCardImage = &quot;#userCard-image-0&quot;; public String adminUserCardDescription = &quot;#userCard-desc-0&quot;; public String adminUserCardButton = &quot;#userCard-button-0&quot;; public String leaderUserCardTitle = &quot;#userCard-title-1&quot;; public String leaderUserCardImage = &quot;#userCard-image-1&quot;; public String leaderUserCardDescription = &quot;#userCard-desc-1&quot;; public String leaderUserCardButton = &quot;#userCard-button-1&quot;; public String operatorUserCardTitle = &quot;#userCard-title-2&quot;; public String operatorUserCardImage = &quot;#userCard-image-2&quot;; public String operatorUserCardDescription = &quot;#userCard-desc-2&quot;; public String operatorUserCardButton = &quot;#userCard-button-2&quot;; ...&#125; 这时，我们可以定义一些组件对象来简化代码，比如： 12345678910111213141516public class AdminPage &#123; ... public UserCard adminUserCard = new UserCard(&quot;title-0&quot;, &quot;image-0&quot;, &quot;description-0&quot;, &quot;button-0&quot;); public UserCard leaderUserCard = new UserCard(&quot;title-1&quot;, &quot;image-1&quot;, &quot;description-1&quot;, &quot;button-1&quot;); public UserCard operatorUserCard = new UserCard(&quot;title-2&quot;, &quot;image-2&quot;, &quot;description-2&quot;, &quot;button-2&quot;); @AllArgsConstructor public class UserCard &#123; public String title; public String image; public String description; public String button; ... &#125; ...&#125; 如果需要复用的UI组件仅仅出现在当前页面，那么可以把这些组件对象定义为当前PageObject的innerClass，如果这些UI组件是跨页面出现的，那么可以单独创建ComponentsPage来收集各种可以复用的组件。 不要在PageObject里面包含测试场景还记得我们开篇说的那个3000行代码的登录页面PageObject吗，它里面一个非常不适宜的写法就是创建了很多包含测试场景的方法，比如loginSuccessFully和loginFailed就是很明显的包含了测试场景。那什么样的方法是包含测试场景的方法呢，一般来说主要有以下两类： 包含对执行结果期望的方法，这种很好辨识，像刚刚说的xxxxSuceed、xxxxFailed什么的，都是包含期望的方法。注意，这里说的是”期望”，不是”断言”，即便在方法中没有使用断言，只要方法有非常明确的执行期望就都算数； 包含了&#39;明确以测试为目的&#39;的执行步骤的方法，这类方法一般会在方法内部按照设测试案例计好的场景、完整地或者部分地执行步骤，比如：1234567public class SamplePage &#123; public void loginAsAdminUser(); public void loginWithIncorrectPasswordFirstAndCorrectPasswordNextTime(); public void clickSubmitButton3Times(); public void refreshPageThenClickSubmitButton(); ...&#125; 之所以不要在PageObject里面包含测试场景，原因和”不在PageObject里面包含断言”是相同的，即PageObject是对页面的抽象，不应该包含测试的类容。测试场景应该仅仅出现在测试文件的测试案例当中，这样才能保证我们在评审测试案例时不会遗漏测试场景中的缺陷，毕竟绝大多数时候我们评审测试案例（特别是考量覆盖率的时候）都是只看测试文件，很少去细看下层的PageObject。一旦开始创建包含测试场景的方法，就会让PageObject产生非常多旁枝末节的方法，极大的扩充PageObject的体量，而那些包含测试场景的方法往往只会在特定的测试案例中被调用一次，复用率很低。所以，尽量避免在PageObject中创建包含测试场景的方法。 喜欢挑刺儿的同学可能会问：我在Procedure里面定义的方法难道不是包含测试场景的吗？的确，我在Procedure中定义的复合方法都有明确的步骤，甚至可以说是符合某些场景的，但这些方法只会包含基本的Happy Path步骤，所以我把它们定义为”流程”，这些流程都应该是没有明确的测试目的的。比如，login就是一个基本的流程，既没有结果期望，也没有特定的测试场景，可以放在Procedure里面，但loginSucceed就包含了期望，而类似loginAsAdmin、loginWithExpiredPassword则是包含了明确的测试场景，就都不应该放在PageObject里面。 所以，对于Selenium官网给出的下面这个例子，我个人还是不予推荐的。 123456789public class LoginPage &#123; public HomePage loginAs(String username, String password) &#123; // ... clever magic happens here &#125; public LoginPage loginAsExpectingError(String username, String password) &#123; // ... failed login here, maybe because one or both of the username and password are wrong &#125;&#125; 执行方法的最小粒度原则PageObject里的页面执行方法尽量按照最小粒度原则来定义。比如，对于登录页面，不要只定义login方法，而要把login拆开，分别定义inputUsername, inputPassword,clickLoginButton三个方法，其目的是可以让测试文件灵活的去根据测试场景来组装测试案例，比如： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class LoginPage &#123; ... public void inputUsername(String username) &#123;&#125; public void inputPassword(String password) &#123;&#125; public void clickLoginButton() &#123;&#125;&#125;public class LoginPageTest &#123; @Test void testLoginSucceed() &#123; loginPage.inputUsername(&quot;username&quot;); loginPage.inputPassword(&quot;correct-password&quot;); loginPage.clickLoginButton(); ... &#125; @Test void testLoginFailed() &#123; loginPage.inputUsername(&quot;username&quot;); loginPage.inputPassword(&quot;incorrect-password&quot;); loginPage.clickLoginButton(); ... &#125; @Test void testIncorrectLoginMultipleTimes() &#123; loginPage.inputUsername(&quot;username&quot;); loginPage.inputPassword(&quot;incorrect-password-1&quot;); loginPage.clickLoginButton(); loginPage.inputPassword(&quot;incorrect-password-2&quot;); loginPage.clickLoginButton(); loginPage.inputPassword(&quot;incorrect-password-3&quot;); loginPage.clickLoginButton(); ... &#125; @Test void testClickLoginButtonRepeatedly() &#123; loginPage.inputUsername(&quot;username&quot;); loginPage.inputPassword(&quot;correct-password&quot;); loginPage.clickLoginButton(); loginPage.clickLoginButton(); loginPage.clickLoginButton(); ... &#125;&#125; 页面继承与页面交叉在BasePage里面封装所有页面可以共用的方法，比如refresh，takeScreenshot，scroll等，然后使用XxxPage继承BasePage来得到某个具体的页面，相信已经是大家的基操了。那么关于BasePage，有以下几点想分享一下： BasePage里面只封装操作方法，不要封装页面元素及其操作方法，比如封装上面说的refresh、takeScreenshot、scroll等操作，但不要封装页面的header、footer等跨页面存在的对象及其方法。这类跨页面的对象及其方法可以封装在AnyPage或者CrossPage中； BasePage里面可以封装一些增强版的操作方法，比如在期望一些不稳定的元素，或者执行一些不稳定的操作时，可能会使用到retry、sleep、甚至异常捕获等操作，如果把这些”骚操作”放到PageObject里面会让原本简洁的代码瞬间变得臃肿起来，所以我们可以在BasePage里面创建这些增强版的方法来实现这些骚操作，比如:1234567891011121314public class BasePage &#123; ... public void doClick(WebElement element) &#123;&#125; public void refreshPageIfElementNotFound(WebElement element) &#123;&#125; &#125; public class SamplePage extends BasePage &#123; ... public void doSomething() &#123; ... this.doClick(this.submitButton); this.refreshPageIfElementNotFound(this.submitResultText); &#125;;&#125; 当然，有时如果根据具体情况觉得这些增强版操作放在BasePage不合适，也可以创建utils类来定义这些增强版方法； 方法内部尽量避免复杂的逻辑在PageObject里面定义方法时，尽量避免写复杂的if-else、switch等逻辑控制，特别是嵌套的逻辑。基于最小粒度原则定义的方法一般来说都不会包含复杂的内部逻辑，但有时候可能会有一些特例，比如，有些页面功能在不同平台上操作步骤可能有区别，又或者在不同环境中执行起来有差异，而我们又期望使用同一个PageObject的方法来表征这个功能从而达到复用的目的，那么可能会这么写： 12345678910111213141516171819public class SamplePage &#123; ... public void doSomething() &#123; if (config.PLATFORM.equals(&quot;iOS&quot;)) &#123; if (config.ENV.equals(&quot;simulator&quot;)) &#123; // do some steps &#125; else if (config.ENV.equals(&quot;device&quot;)) &#123; // do some steps &#125; &#125; else if (config.PLATFORM.equals(&quot;Android&quot;)) &#123; if (config.ENV.equals(&quot;emulator&quot;)) &#123; // do some steps &#125; else if (config.ENV.equals(&quot;device&quot;)) &#123; // do some steps &#125; &#125; &#125;&#125; 如此定义的方法是非常臃肿的，这类方法如果多了，整个PageObject就会惨不忍睹。遇到这种情况时，可以尝试对测试案例进行归类，通过tag的方式，将特定环境下执行的测试案例放在一起执行，这时PageObject就可以做如下的相应修改： 123456789101112131415161718public class SamplePage &#123; ... public void doSomethingOnIOSWithSimulator() &#123;&#125; public void doSomethingOnIOSWithDevice() &#123;&#125; public void doSomethingOnAndroidWithEmulator() &#123;&#125; public void doSomethingOnAndroidWithDevice() &#123;&#125;&#125;public class SamplePageTest &#123; @Test @Tag(&quot;iOS&quot;) @Tag(&quot;Simulator&quot;) void testSample() &#123; ... samplePage.doSomethingOnIOSWithSimulator(); &#125;&#125; 然后通过执行测试的命令来控制不同的测试案例在不同的环境下执行，这样可以让测试案例和PageObject都保持简洁的代码结构。也许有人会质疑”那如果这样的差异化操作多了，岂不是要定义非常多的操作方法？”，是的，的确如此。但即便我们定义了更多的操作方法也是可以接受的，因为我们只是把原本揉捏在一个方法中的不同代码块分布到了各自的方法中去，在不增加代码总量的情况下获得了更好的可读性，便于后期的维护与扩展。而如果你觉得这样的操作真的多到大大增加工作量的程度，那么就应该回过头来审视一下是否还有必要为了”复用”而使用同一套测试案例去测试不同平台环境上的SUT了。自动化测试有一条有益的原则：复用测试实现但不要复用测试案例。 方法是否需要返回otherPages？在很多网上资料中，包括Selenium的官网都有介绍说”methods on the PageObject should return other PageObjects”，比如，正确执行了某个登录方法后，这个方法就应该返回登录后进入的页面，例如下面这样： 12345public class LoginPage &#123; public HomePage loginAs(String username, String password) &#123; // ... clever magic happens here &#125;&#125; 对于这样的考量，我个人是不推荐的。因为当LoginPage的login方法固定返回HomePage其实就是给这个login方法预置了期望，而且这个期望还是只在登录成功的情况下才能达成，这就进一步的限定了场景是”测试成功”，这种包含期望和场景的方法是我们在写PageObject时应该尽量避免的，这一点上面已经提过了。 日志与异常处理日志与异常处理属于执行代码的技术事件，在测试案例与PageObject里面都不应该出现。除了调试，PageObject里面一般都不需要使用打印日志的代码，像下面这样的日志打印就纯属画蛇添足： 123456789101112131415public class LoginPage() &#123; ... public void login(String username, String password) &#123; inputUsername(username); logger.info(&quot;input username: &quot; + username); inputPassword(password); logger.info(&quot;input password: &quot; + password); WebElement loginButton = driver.findElement(By.id(loginButton)); loginButton.click(); logger.info(&quot;logged in&quot;); &#125;&#125; 如果需要收集日志，应该交给执行测试的runner或者运行测试的命令行工具去控制。对于日志，值得多提几句的是，同样是写代码，开发代码与测试代码对日志的需求是完全不同的。以后端服务为例，Service的运行代码中包含大量的日志打印是为了在出现异常情况时留下线索帮助事后分析问题。服务处理的事件很多情况都是无序、无状态、甚至有些是异步或难以复现的，特别是微服务系统，为了还原一个异常事件的前因后果，往往可能需要在多个系统的日志信息中去寻找蛛丝马迹，所以服务往往需要大量精准的日志打印工作。相对的，测试案例的场景和参数往往都是固定的（当然也有少数的动态参数），所有的操作步骤也都是有序执行的（这里仅考虑同一个测试案例的执行，不考虑并行执行、甚至竞争执行的情况），出现问题时可以通过异常发生的代码行数快速摸清整个场景的前后流程，所以日志打印对测试代码来说绝大多数情况下都是不必要的。 至于异常处理，对自动化测试来说，除了一些需要特别关照的”骚操作”外，尽量不要去主动捕获异常，测试执行遇到异常该挂就挂，该中断就中断。开发代码使用try-catch是为了让应用在遇到异常时仍然可以继续工作，而测试代码的目的则是发现错误。错误是SUT的就让开发去修，错误是测试的就让QA去修，修不好就让它挂着，挂到修好为止。千万不要为了让测试能跑起来就去盲目的添加各种try-catch，否则一旦处理不当就能坑死人。开篇说的那个3000行PageObject的自动化测试项目，就在处理配置文件时错误的使用了try-catch，致使测试在缺少一些关键配置项的情况下任然启动执行，最终导致部分测试案例出现了匪夷所思的行为，给调试工作带来了巨大的麻烦。 最后作为免责声明，最后还是高亮一下：以上内容既不是什么金科玉律，也谈不上什么最佳实践，只是基于我个人的实操、观察与思考得来的心得体会，纯属一家之言，还望观者自己思辨。","categories":[],"tags":[]},{"title":"QA视角下的API安全测试-下篇","slug":"QA视角下的API安全测试-下篇","date":"2022-11-23T04:02:51.000Z","updated":"2022-11-26T08:17:07.911Z","comments":true,"path":"2022/11/23/QA视角下的API安全测试-下篇/","link":"","permalink":"http://yoursite.com/2022/11/23/QA%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84API%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95-%E4%B8%8B%E7%AF%87/","excerpt":"上篇中的OWASP API Security Top 10已经帮我们梳理了最常见的API安全问题，QA针对自己API服务的具体情况，开展有的放矢的测试和安全保障工作，能够在很大程度上扫除一大批基本的安全漏洞和隐患。这其中，作为API安全最关键的层面，API的认证与授权是整个测试工作中的重中之重。如果我们自己的团队负责构建了后端的认证授权服务，那么QA对认证授权的安全测试则需要更详细、更深入的关注。 值得一提的是，我们经常将”认证授权”放在一起描述，但认证、授权其实是两个不同的事件，我们接下来会对它们的常见方式和QA可以涉及的关注点进行介绍。 服务认证的相关基础认证，Authentication，更准确一点的称谓应该是身份认证，主要功能是对服务的使用者进行身份的合法性校验，常见的身份认证方式主要有静态码、动态口令、短信码、数字证书、以及生物特征等。说到身份认证，我们经常将它解决的问题描述成”确定’你是谁’”，然而，更确切地来说，’你是谁’仅仅是确认身份的一个要素，除此之外，还有’你知道什么’、’你拥有什么’：","text":"上篇中的OWASP API Security Top 10已经帮我们梳理了最常见的API安全问题，QA针对自己API服务的具体情况，开展有的放矢的测试和安全保障工作，能够在很大程度上扫除一大批基本的安全漏洞和隐患。这其中，作为API安全最关键的层面，API的认证与授权是整个测试工作中的重中之重。如果我们自己的团队负责构建了后端的认证授权服务，那么QA对认证授权的安全测试则需要更详细、更深入的关注。 值得一提的是，我们经常将”认证授权”放在一起描述，但认证、授权其实是两个不同的事件，我们接下来会对它们的常见方式和QA可以涉及的关注点进行介绍。 服务认证的相关基础认证，Authentication，更准确一点的称谓应该是身份认证，主要功能是对服务的使用者进行身份的合法性校验，常见的身份认证方式主要有静态码、动态口令、短信码、数字证书、以及生物特征等。说到身份认证，我们经常将它解决的问题描述成”确定’你是谁’”，然而，更确切地来说，’你是谁’仅仅是确认身份的一个要素，除此之外，还有’你知道什么’、’你拥有什么’： 你知道什么，通过验证’你知道什么’来确认身份是最古老的身份认证方式，我们常用的密码、暗号、生日、初恋对象等等就属于这一类； 你拥有什么，不管你是谁，只要你拥有相应的物件，就能通过认证，常用的短信码、U盾（其实质是里面的数字证书）、ID卡、甚至是婚宴的请帖都属于这一类； 你是谁，这里的’你是谁’聚焦的就是生物特征，比如指纹、声纹、虹膜等可以作为个体唯一认证的特征事务； 在身份认证的时候，如果只对上述三种要素中的一种进行校验，那么认证失效的可能性是比较高的。比如，仅仅要求验证密码，而密码又被他人获取，那就可能发生身份盗用。所以，当代的认证服务经常会在一些关键节点对两种或者三种要素进行同时校验，这就是我们说的多要素认证（Multiple Factor Authentication）。比如，银行APP在登录时只需要登录密码或指纹进行单要素认证，而在转账时就需要交易密码+短信验证码或U盾密码的双要素认证（即2FA认证）。 常用的身份认证技术目前，在API服务的使用场景下，身份认证也有多种不同的技术，主要包括： 基于HTTP Basic的基本认证 基于API KEY签名的认证 基于SOAP Header的认证 基于Token系列的认证 基于数字证书的认证 SAML认证 其中，基于Token系列的认证是我们平常接触最多的认证方式，所以我们在这里着重讨论。 对于其他认证方式的测试保障，特别是基于API KEY签名和数字证书的认证，感兴趣的同学可以再进一步研究哈。 之所以叫”基于Token系列的认证”，是因为该认证体系是多项与Token相关的技术、协议的综合使用，包括OAuth、OpenID Connect、JWT等，其中最常见的就是OpenID Connect（简称为OIDC）协议中的身份认证技术。 需要说明的是，OIDC的认证技术解决的是第三方认证的问题，比如用户使用Google或者Apple的账号登录Bitbucket网站，而单方认证并不需要使用到OIDC，比如用户直接使用自己的Bitbucket账号登录Bitbucket网站。我们这里之所以关注OIDC，主要还是由于OIDC作为第三方认证的解决方案，在API的交互上比单方认真的流程要复杂许多，从而出现安全隐患的几率更高。但就业务场景来说，现实中单方认证的使用频率肯定是高于第三方认证的，QA需要对它们的区别建立正确的理解（说人话就是：如果你的系统只需要单方认证服务，就不要去纠结为啥没用OIDC了）。 OIDC是在OAuth2.0协议的基础上加构认证层（主要是添加了ID Token和UserInfo Endpoint组件）而制定的协议，大家可以参见OIDC的官网来获取协议的全部细节内容。 下图是OIDC抽象流程图，其中，第(2)步既需要终端用户完成其在服务端的登录认证，又需要终端用户授权服务端向客户端提供其的个人信息，所以，这其实是认证+授权相结合的流程。而技术上也确实如此，OIDC是基于OAuth2扩展的，而OAuth2本身最早就是授权协议，而图中的服务端，更准确的说就是授权服务，所以OIDC其实质就是基于授权服务来完成的认证流程。 上图第(2)~(3)步的认证过程，在OIDC的协议里面根据OAuth2的授权许可方式的不同，又被分为三种认证模式： 授权码模式，使用OAuth2的授权码流程来获取ID Token和Access Token； 简化授权码模式，使用OAuth2的简化授权码流程来获取ID Token和Access Token； 混合模式，前两种方式的混合使用； 这三种认证模式通过第(1)步中请求参数response_type的取值来确定，所以又有以下具体划分： response_type 取值 认证模式 原生定义 code 授权码模式 OIDC定义 id_token 简化授权码模式 OIDC定义 id_token token 简化授权码模式 OIDC定义 code id_token 混合模式 OIDC定义 code token 混合模式 OIDC定义 code id_token token 混合模式 OIDC定义 token N/A OAuth2定义 nonce N/A OAuth2定义 上述表格中的各认证流程如下图所示（图中为简化起见，未标注获得Access Token后请求个人信息的步骤）： 其中，认证码模式是进行用户身份认证最常用的模式，其第一步的认证请会用到的参数如下表所示： 参数名 使用方式 scope 必选参数 response_type 必选参数 client_id 必选参数 redirect_uri 必选参数 state 建议参数 response_mode 可选参数 nonce 可选参数 display 可选参数 prompt 可选参数 max_age 可选参数 ui_locales 可选参数 id_token_hin 可选参数 acr_values 可选参数 每项参数的具体含义，感兴趣的同学可以自行查阅官方文档。对于QA来说，这里需要着重关注的是redirect_uri和nonce: redirect_uri定义了授权服务端在完成终端用户的登录认证后需要将用户引导去的地址，比如，当我们需要使用Github的账号登录StackOverflow的时候，我们在StackOverflow的登录页面向Github的授权服务端发送登录认证请求，其携带的redirect_uri地址就是StackOverflow地址。服务端在接收到redirect_uri参数后，会和自己保存的redirect_uri参数进行对比，结果匹配才会进行后续跳转。由于服务端接收到的redirect_uri参数来自客户端，所以就存在被篡改的风险。如果服务端在进行参数对比和之后的跳转实现时存在缺陷，一旦遭遇被篡改的redirect_uri参数，就可能造成安全漏洞。比如，当两端的redirect_uri参数不匹配时，直接跳转到客户端发送的地址，就可能遭受钓鱼攻击； nonce是一个随机数，设计的主要目的是进行会话保持，减缓重放攻击，所以尽管nonce在规范中是可选参数，但在实现时也尽量使用； QA可以采取的安全保障工作 QA一定要对MFA建立正确的理解和业务敏感度，如果发现产品或系统在关键认证节点（比如转账、修改密码登操作）仅仅使用了简单的单要素认证，一定要督促团队或者建议客户改用多要素认证； 对基于OAuth2或者OIDC的认证服务，一定要对redirect_uri参数的使用进行相关测试和验证，确保该地址在服务端配置正确，且在进行匹配校验时使用的是严格的一致对比，禁用部分匹配或正则表达式，禁止使用白名单； 建议团队使用state和nonce参数； 测试验证过期的验证码和Access Token； 对于OIDC更多的安全保障切点可以参见官方文档的Security Consideration; 基于我个人的知识范畴、体力、以及通常情况下QA所能触及的能力边界，我们对认证方面的安全保障就粗略介绍到这里，但请相信，我们上面聊到的部分仅仅是与认证相关的安全细节中的冰山一角，更多复杂和高难度的、针对认证系统的攻击方式都不是短期内能够了解和掌握的，术业有专攻，更深层次的防御和保障工作还是需要安全专家的协助。 服务授权的相关基础说完认证，就该说说授权了。授权，Authorization，是指为了满足用户实现某种功能而授予其相应的权利，也就是常说的解决用户”能干什么”的问题。在软件领域，授权管理主要分为两个大类： 功能级权限管理，即管理不同的用户能够进行哪些不同的操作。比如在各种后台系统的页面上，普通用户只能使用浏览和查询功能，管理员才能使用编辑功能，而只有超级管理员才能使用用户管理功能等。而对应到API服务里，普通用户只能使用GET请求获取数据，管理员用户才能使用POST请求创建数据； 数据级权限管理，即管理不同的用户在进行相同的操作时能获取哪些不同的数据。比如一家跨国电商贸易公司的业务查询接口，中国区管理员访问时获取的数据量，通常都应该小于等于亚太区管理员访问时获取的数据量； 访问控制授权仅仅是对权限进行了划分，而真正要落实权限划分，就还牵涉到一个概念叫做访问控制。我们可以把授权管理理解为制定规则，而访问控制则是实现规则。比如常用的门禁系统，我们可以设置各种需要的开关、警报、以及远程通知规则，而要落实这些规则就需要使用到传感器、电磁阀、警报器等物理执行机构。软件，特别是API服务也是如此，即使规则设计得再好，如果功能实现或服务部署层面出现缺失或不完善的话，授权管理也是不工作的，我们在前面提到的OWASP API Security Top 10中的API1-失效的对象级授权和API5-失效的功能级授权中的很多漏洞都是由此产生的。 再次强调，访问控制是API安全中非常重要的环节。我们平常在述及API安全时经常听到”认证授权”，却很少提及”访问控制”，为了加深对访问控制的映像，我们可以再举一个身边的例子：购票乘坐高铁。旅客购买高铁车票时，首先需要提供身份证，这个环节就是认证，有时我们可能没有身份证，那么也可以提供户口本、护照、港澳通行证等，这就是第三方认证，无论是使用身份证进行单方认证还是使用其他证件进行第三方认证，认证的目的都是获取旅客真实的个人身份信息。而后铁路公司在收取车票钱后就会出票，出票的过程就是授权，旅客拿到的车票就是授权凭证，也就是下面我们会提到的OAuth协议中的Access Token，车票中会写明我们乘坐的座位信息，包括乘车日期、几车几号、始发与终点站等等，这些信息就是Access Token中的Claims，其中肯定会有一个非常重要的信息：一等座还是二等座，这就对应了Claims中的Scope。旅客在获取车票后，就完成了认证授权的全过程，剩下的就是拿着车票去乘高铁了。在乘车的过程中，如果拿二等座的票去做一等座的座位，又或者拿3车的车票去坐5车的座位，肯定会被乘务人员阻止的，乘务人员的这一系列验票验座、甚至驱赶旅客下车的操作就是访问控制。所以，无论认证授权做得再好，访问控制实施不当，API安全就是竹篮打水一场空。 常见的API授权与访问控制技术在API服务领域，授权与访问控制相关的技术比较分散，常见的成熟方案主要包括： 基于用户身份或被访问资源的OAuth授权协议，毫无疑问是目前API领域使用最广泛的技术； 基于角色的访问控制（Role-Based Access Control）模型，RBAC得益于它通过用户角色来实现权限控制的理念，使其在产品级应用中大量使用，从传统的操作系统、数据库，到现代的K8s、OpenStack都能看到它的身影； 基于属性的访问控制（Attribute-Based Access Control）模型，ABAC则基于对象的各种属性来进行控制判断，比如K8s中使用它来进行亲合度与污点的判断从而控制资源的调配，ABAC的使用规模没有RBAC大，通常单点使用较多； 基于上下文的访问控制（Context-Based Access Control）模型，CBAC是基于通信上下文的控制模型，需要结合数据流来进行分析判断，在防火墙产品中使用较多； 基于访问控制列表（Access Control List）的控制，ACL则是相对更常见和简单粗暴的控制方式了，普遍应用于路由器的访问规则、IP控制表、黑白名单等； 由于体力和技术应用对象的关系，我们下面只重点关注OAuth的相关技术与安全测试。 OAuth的授权技术OAuth协议的产生主要是为了解决在不共享密码的情况下、从第三方服务获取受保护的个人数据的问题。OAuth有1.0和2.0两个版本，1.0版本因为存在一些安全隐患，已经基本弃用，所以目前所说OAuth主要都是指的OAuth2.0。下图是OAuth的抽象流程图，细心的同学也许可以发现，虽然OAuth的抽象流程图与OIDC相比有一些细节的结构区别，但两者的访问流程几乎是完全相同的。事实也确实如此，因为OIDC协议就是基于OAuth扩展而来的。 在上图中的第(2)步，根据授权凭证（Authorization Grant）类型的不同，OAuth的授权又分为不同的模式： 授权码模式，客户端从授权服务端获得授权码，以授权码作为客户端与用户（即资源所有者）之间的中介，向授权服务端换取Access Token，再使用Access Token来访问用户的资源； 简化授权码模式，即对授权码模式进行简化后的流程模式，又称隐式流模式，该模式最大的特点就是省去了授权码，直接获取Access Token，这种方式主要用于没有单独的客户端后端的授权情况，比如Web SPA应用、手机APP应用获取授权； 密码模式，客户端直接使用用户的密码来获取Access Token； 客户端凭证模式，客户端使用已经获取的授权凭证来换取Access Token，比如使用secretKey来换取Access Token； 设备码模式，主要用于对没有浏览器等缺乏用户输入手段的设备进行授权，比如打印机、多媒体控制器等； 各种认证模式的协议流程图如下图所示： 需要指出的是，简化授权码模式和密码模式由于其安全性较差，已经基本弃用，且被最新的OAuth2.1版本（草案）移除了。即便是相对安全的授权码模式，也存在授权码遭受劫持的可能，所以2015年OAth对授权码模式提出了PKCE（Proof Key for Code Exchange）扩展。OAuth使用授权码+PKCE的协议流程如下图所示： PKCE与普通授权码模式的区别就在于发送授权请求时要额外携带code_challenge和code_challenge_method参数，而在使用授权码换取Access Token时的请求要额外携带code_verifier参数，其中，code_verifier为一串随机数，每次请求都不相同，code_challenge_method指定计算code_challenge的方法，只能选plain或者S265，且 12345# 当code_challenge_method为plain时code_challenge = code_verifier# 当code_challenge_method为S265时code_challenge = BASE64URL-ENCODE(SHA256(ASCII(code_verifier))) PKCE的方案最初是为了解决公共应用（Mobile、Desktop、Web SPA等）授权码被劫持的问题，因为这些公共应用都是在用户手中直接跟授权服务通讯，在客户端保存着获取Access Token的另外一个重要参数client_secret，如果应用被反编译或者以其它的方式泄露了client_secret，再遭遇授权码劫持的话，攻击者就能获取用户的Access Token。而加上PKCE的协议，即便攻击者劫持了授权码，只要没有正确的code_verifier也就无法获取其它用户的Access Token。 通过劫持授权码来获取Access Token理论上只能对公共应用发起攻击，因为机密应用的client_secret都保存在后端，由后端使用授权码+client_secret向授权服务请求Access Token。比如我们常见的前后端分离的Web应用就由BFF保存client_secret来向授权服务请求Access Token，所以对机密应用来说，攻击者通常无法获取client_secret，那么劫持授权码也就没有作用。然而，基于PKCE更好的安全性，OAuth2.1建议在所有应用中使用PKCE模式。 QA可以采取的安全保障工作OAuth作为目前使用最广的API授权协议，尽管其协议流程本身已经在行业中经历了实战的考验，但围绕OAuth周遭的安全问题也是常有发生的，QA应该对其抱有足够的重视。同样，基于QA的能力范畴，我们通常可以从以下方面予以关注： QA要对授权管理的分类有正确的理解和业务敏感度功能授权容易实现，但数据授权却往往容易被忽略，需要额外关注。比如，在业务分析时如果遇到与授权相关的场景，既要考虑功能的授权校验，也要考虑数据的授权校验。 督促团队及时评估和更新OAuth客户端SDKOAuth是开放协议，不同平台、不同开发语言一般都有各自的OAuth实现，团队在使用的时候也几乎不会自己独立实现一套OAuth，而是根据项目的技术栈选择合适的OAuth SDK来使用。而这些SDK自身也是可能存在漏洞的，比如，HelloJS就是标准的OAuth客户端SDK，就曾经出现过CVE-2020-7741这个安全漏洞： 1234else if (&#x27;oauth_redirect&#x27; in p) &#123; location.assign(decodeURIComponent(p.oauth_redirect)); return;&#125; 在以上早期代码中，SDK直接使用了参数中的.oauth_redirect进行页面跳转而没有做相应的URL校验，这就可能允许XSS攻击的发生。HelloJS在其后的版本中修复的这个漏洞，其代码如下： 123456789else if (&#x27;oauth_redirect&#x27; in p) &#123; var url = decodeURIComponent(p.oauth_redirect); if (isValidUrl(url)) &#123; location.assign(url); &#125; return;&#125; 所以团队需要及时评估自己使用的OAuth客户端SDK的版本，根据情况适时更新； 对redirect_uri的测试检查OAuth协议中使用的redirect_uri参数是另一个被高频攻击的对象，因为围绕URI实施的攻击难度相对较低，所以QA需要： 检查授权服务的配置中正确地绑定了客户端的client_id与redirect_uri； 测试验证授权服务对接收到的redirect_uri参数做了严格的一致性校验，禁止使用通配、包含、正则表达式等匹配规则； 关注对授权码的测试检查授权码是OAuth协议中非常重要的中间信物，很多会话劫持都是围绕授权码展开的，所以需要重点关注： 测试验证授权码的实现是无规律、且是一次性的； 测试验证、或向开发同学确认不同客户端之间不会共用相同的授权码； 按照OAuth的协议，state参数在发送授权码时是可选参数，但从安全的角度来说最好要使用，所以QA可以建议团队将state参数纳入设计与实现，并予以测试验证； 在条件允许的情况下，建议团队使用PKCE扩展； 对Access Token的测试验证客户端拿到Access Token后，授权的过程实质上就已经完成了。这时需要关注的就是访问控制了，只有正确的实现了访问控制，颁发的Access Token才有实际的意义，对此，QA可以关注： 测试验证设计要求的所有API接口都必须使用Access Token才能访问，特别是对多版本并存的API，一定要校验老版本接口的访问控制； 测试使用过期的Access Token； 测试使用已经失效的Access Token，比如已经使用Refresh Token换取了新的Access Token，老的Access Token应该失效，又比如logout后原有的Access Token应该失效； 测试使用用户A的Access Token访问用户B的资源； 对有功能权限管理的业务，测试使用Access Token去进行不被授权的操作，比如，普通用户登录后获取的Access Token，不能访问创建用户的POST接口； 对有数据权限管理的业务，测试使用Access Token去访问不被授权的数据，比如，普通用户登录后获取的Access Token，在访问查询数据的GET接口时，只能获取其被授权的数据； JWT的相关测试验证在API的认证授权以及其他一些数据传输的过程中，JWT是十分常用的组件，也是可能造成信息泄露的安全隐患之一，QA需要对JWT的基本知识有所了解。 JWT来自于JOSE（Javascript Object Signing and Encryption）协议栈，JOSE包括以下主要内容： JWT（JSON Web Token），由RFC7519规范定义的使用JSON对象在通信中进行交互的标准数据格式，就是我们常说的JWT； JWS（JSON Web Signature），针对JWT进行数字签名的操作规范； JWE（JSON Web Encryption），针对JWT进行加密的操作规范； JWK（JSON Web Key），描述JWE加密时使用的密钥数据结构的规范； JWA（JSON Web Algorithm），定义JWS或JWE中使用的算法列表； 事实上，JWT只是抽象层的数据格式定义，真正有实际操作指导作用的是JWS和JWT，换句话说，JWT是抽象，JWS和JWE是JWT的具体实现方式，而JWK和JWA则是实现过程中会使用到的数据和算法规范。我们平常在网上看到的关于JWT的介绍，绝大多数讲的都是header.payload.signature的三段式编码字符串，其实质就是JWS，也是使用最广泛的JWT。使用RS265签名算法创建JWS的过程如下图所示： JWS实现的是标准的JWT数据结构，包含： Header（JOSE标头），用来声明签名算法、令牌类型等信息，比如上图中就声明了使用RS256签名算法； Payload （有效载荷），用来装配需要传输的数据信息，payload可以是任意类容，并且从技术上来说，可以不是标准的JSON数据结构； Signature（签名），根据header和payload、再加上所选择的签名算法计算得到的签名字符串； 需要强调的是，JWT/JWS中的payload看起来是一串随机的字符串，但它仅仅是经过base64url编码得到的，并没有经过加密，是可以解码还原的，所以payload的内容在JWT/JWS中和明文没有区别。另外，JWT数据结构是允许不携带签名的，也就是说base64url(header).base64url(payload).这样的数据结构也是合法的JWT，但很显然，JWS是必须使用签名的，否则就没有意义了，因为签名的目的，就是为了解决JWT的payload在传输过程中被篡改的问题，从而保障数据的完整性和一致性。 再次强调：JWT/JWS传输的数据是没加密的明文！明文！明文！所以千万不要使用JWT传输敏感信息。如果真的需要使用JWT来传输敏感信息，就需要使用JWE。JWE是专门针对传输数据进行加密的JWT操作规范，具体的协议细节大家可以查阅官网，这里就不在赘述了（实在没体力了OTL）。如何区别JWT是JWS还是JWE呢？很简单，JWS是三段字符串，而JWE是五段字符串： QA可以采取的安全保障工作JWT属于数据传输过程中的技术，一般来说需要QA介入进行安全测试的切点并不多，更多的是需要开发同学在使用JWT时遵循各种安全实践，QA可以对此做一些审查、提醒的帮助： 验证使用的JWT/JWS中没有传输铭感、机密数据； 如果业务上需要使用JWT传输敏感、机密数据，提醒开发同学不能使用JWS，而要使用JWE，或者使用其它的加解密方案（比如将数据加密后再放到JWS的payload中），并做相应的代码审查（不用害怕看不懂代码，让Dev把关键步骤show出来讲清楚就行）； 提醒开发同学不能在代码中硬编码密钥，密钥如果以文件方式存在，密钥文件要被命名为复杂且不易被猜测的文件名，且必须放在有权限访问控制的目录中，不能放在Web服务器的应用目录； JWT允许定义签名算法集、然后在传输过程中选择使用某种签名算法，但从安全的角度来说，不要这样做。应该由服务端指定唯一的签名算法，不接受客户端选择的签名算法，QA需要对此有所警醒； 提醒开发同学，一定使用携带签名的JWS，在使用JWS时，一定要验签，对此QA可以让开发同学协助审查代码（不要觉得这些显而易见的事情没必要，有的项目就曾遇到过在协议设计中要求的加解密操作，在具体的代码实现中被遗漏了，而缺少加解密对业务功能又没有直接影响，除非进行有针对性的渗透测试，否则很难被发现）； 总结API安全是一个十分重要敏感、同时又非常宽泛的话题，绝不是一两篇文章就能叙之以全的。我们这里介绍的类容：OWASP API Security Top 10、认证、授权、访问控制、JWT等等，都只是API安全领域非常基础的部分，对它们的安全保障实践也是针对QA力所能及的、最基本的方式。在实际的项目开发中，真正会面对的问题往往会更加复杂，对安全方面的测试挑战也会更高。特别是对于认证、授权的流程测试，我们文中谈到的OIDC、OAuth仅仅是基础中的基础，现实项目中都会在这些标准规范的基础上叠加支撑各自业务需求的特征功能，比如在认证过程中引入OTP验证、生物识别等多要素认证，又或者在授权过程中叠加SSO等，所以不同项目中的实际情况通常会复杂很多。但无论具体项目中的实现多么复杂，我们这里总结分享的安全保障措施都是可以适用的，它们是基础，离开它们就谈不上安全测试，但仅仅依靠它们，也做不好安全测试。所以，立足基础、快速学习、应用变通永远都是QA的生存之道。","categories":[],"tags":[]},{"title":"QA视角下的API安全测试-上篇","slug":"QA视角下的API安全测试-上篇","date":"2022-11-23T04:02:43.000Z","updated":"2022-11-26T08:17:07.915Z","comments":true,"path":"2022/11/23/QA视角下的API安全测试-上篇/","link":"","permalink":"http://yoursite.com/2022/11/23/QA%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84API%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95-%E4%B8%8A%E7%AF%87/","excerpt":"最近工作在一个跨国银行的项目上，整个项目是为客户构建一个面向终端用户的银行应用程序，包括Android、iOS、Web三前端及其配套的后端系统。我所在的团队负责其中的注册登录、会话管理、以及用户数据等和安全息息相关的部分。项目中，我们遇到了很多认证授权的具体实现及其测试需求，基于这样的背景，我觉得有必要对”以QA的视角、以API为对象、以安全为重点”的API安全测试进行一些整理总结，遂赘此文于斯。 安全测试向来都是质量工程师和安全工程师所共同关注的交叉地带，有时候甚至非常不幸的是混沌地带。对应用程序或系统而言，质量工程师关注的重点通常都是功能实现，安全作为非功能需求中的一环，虽然所有人都不会质疑其重要性，但落实到具体的保障手段上来说，对一般的质量工程师而言，还是缺乏相应的金刚钻。当然，和质量类似，安全也不是测试出来的，它需要全局性的、流程性的保障手段，所以，相较于单纯的测试，我们现在更注重SDL、BSI、NIST、CLASP这些基于流程、过程、以及全生命周期的综合性安全保障方案。即便如此，对QA而言，掌握基本的安全测试理念和技能，在日常测试工作中更有目的性和针对性的实施和安全相关的测试活动，还是非常有必要的。毕竟，对团队来说，大家还是期望在提交渗透测试之前能够有一些基本的安全信心。 在软件开发的过程中，和安全相关的实体是很多的，从传统的前端应用、后端服务，到基础设施、乃至业务逻辑本身都可能存在安全风险，我们这里将以QA的视角，单独聚焦后端API的安全测试问题。","text":"最近工作在一个跨国银行的项目上，整个项目是为客户构建一个面向终端用户的银行应用程序，包括Android、iOS、Web三前端及其配套的后端系统。我所在的团队负责其中的注册登录、会话管理、以及用户数据等和安全息息相关的部分。项目中，我们遇到了很多认证授权的具体实现及其测试需求，基于这样的背景，我觉得有必要对”以QA的视角、以API为对象、以安全为重点”的API安全测试进行一些整理总结，遂赘此文于斯。 安全测试向来都是质量工程师和安全工程师所共同关注的交叉地带，有时候甚至非常不幸的是混沌地带。对应用程序或系统而言，质量工程师关注的重点通常都是功能实现，安全作为非功能需求中的一环，虽然所有人都不会质疑其重要性，但落实到具体的保障手段上来说，对一般的质量工程师而言，还是缺乏相应的金刚钻。当然，和质量类似，安全也不是测试出来的，它需要全局性的、流程性的保障手段，所以，相较于单纯的测试，我们现在更注重SDL、BSI、NIST、CLASP这些基于流程、过程、以及全生命周期的综合性安全保障方案。即便如此，对QA而言，掌握基本的安全测试理念和技能，在日常测试工作中更有目的性和针对性的实施和安全相关的测试活动，还是非常有必要的。毕竟，对团队来说，大家还是期望在提交渗透测试之前能够有一些基本的安全信心。 在软件开发的过程中，和安全相关的实体是很多的，从传统的前端应用、后端服务，到基础设施、乃至业务逻辑本身都可能存在安全风险，我们这里将以QA的视角，单独聚焦后端API的安全测试问题。 API的类型与技术对于QA来说，要想做好某项测试（无论是功能需求还是非功能需求），了解被测对象一定是第一步，对于API来说亦是如此。那么，什么是API呢？Application Programming Interface，即应用程序编程接口，其具体的描述，我就不去抄维基百科了，感兴趣的同学可以自行查阅。这里值得强调的是，有些同学可能会直接把API等价为API服务，即我们通常所说的”后端API服务”或者”后端API接口”，这是不确切的，API的范畴是远大于API服务的。 API的类型软件技术发展至今，API可以被大致分为四种类型：类库型API、操作系统型API、远程应用型API、以及Web应用型API： 类库型API，最为常见的一种API，我们平常广泛使用的各种编程语言中的预定义接口函数都是类库型API，比如NodeJS的内建模块提供的path.dirname、Python的图像处理库Pillow提供的ImageFile.Parser等等； 操作系统型API，这类API通常都是和操作系统进行直接交互的接口，比如传统的Windows API和Linux标准库函数，以及Mobile开发中的Android和iOS库函数等； 远程应用型API，这类API是为了使用相似的应用程序来完成类似的操作而创建的，它首先需要定义一套相同的规范，各个应用程序厂商再按照统一的规范完成自己的实现，从而达到一套API调用不同应用程序的目的。Java的JDBC就是远程应用程序型API的代表，它是一种规范，并由Sum公司提供了完整的接口，然后各个数据库厂商，比如Oracle、SQL Server、MySql等，再按照这一接口完成自己的实现，其中，MySql的JDBC实现就是MySQL Connector。当然，对广大QA同学来说，还有一个更加亲切的例子，那就是Selenium WebDriver。WebDriver也是一套规范，各家浏览器厂商基于这套规范完成了自己的WebDriver实现，比如Google提供的ChromeDriver，Mozilla提供的FirefoxDriver； Web应用型API，好了，这才是大家最喜闻乐见的”后端API”或者”后端接口”。其特点也是显而易见的，即以Web服务的方式对外提供接口，其使用不局限于操作系统、平台、以及编程语言，广泛的应用于各种B/S、C/S系统中； 当然，我们今天讨论的话题是API的安全测试，关注的重点是Web应用型的API（后文中简称Web API或API），但这并不表示其它类型的API就不存在安全问题。事实上，在服务端的安全事件中，Web API有时仅仅是安全测试或者攻防的前线，真正的致命漏洞也可能隐秘在其它类型的API当中。比如，我们在使用npm audit进行安全检查时，经常会发现一些有安全问题的包，这些包绝大多数都是类库型API，它们不被用来直接构建Web API，却着实可能对文件IO、数据库读写等敏感信息操作造成隐患。作为QA，通常情况下我们很少有契机、也缺乏足够的能力对特定类库型API进行安全方面的审查，其相关问题往往需要安全和领域专家去进行深入剖析。所以，关注和增强对Web API的安全测试，在入口处降低暴露安全问题的几率，才是我们QA力所能及且行之有效的安全保障之道。 Web API的技术特点2000年以来，Web API得到了快速的发展，其技术形式和应用场景都非常的丰富，因此也被称为”现代API”。如果要对现代API进行归类划分，我们甚至可以从不同的维度来定义API。 基于技术实现的划分多样的技术实现，是当代API最大的特点，当然，这里的技术指代的是技术规范，而非特定的编程语言。具体来说，如今的API可以按照技术实现进行以下划分： SOAP API，以XML为数据载体、通过HTTP协议进行传输的服务接口，SOAP API在当代API中已经是很陈旧的技术了，但由于早期的使用量较大，如今在很多大型企业中还仍在沿用； REST API，广泛使用HTTP协议加JSON的数据格式，是当下最主要的API技术形式； GraphQL API, 使用Facebook提出的GraphQL查询语言构建服务接口，需要预定义Scheme且在服务端和客户端之间共享，尤其适用于树状结构的数据获取； gRPC API，基于Google提出的gRPC框架构建服务接口，使用Protocol Buffers对传输数据进行序列化后进行远端方法调用，其特点是传输相同数据量时的速度快于其它类型的Web API； 其它类型的API，除了SOAP、REST、GraphQL、gRPC这四种技术，当代API还有一些小众的技术在特定场景下持续使用，比如XML-RPC、JMS、WebSocket以及IoT设备单独使用的接口技术等等，其中，大家对使用JMS技术实现的产品可能更加耳熟能详一些，比如常见的Kafka、Rabbit MQ； 基于终端消费者身份的划分构建API的目的一定是用于消费的（Consume），那么根据消费者的身份，又可以将Web API进行如下划分： 公共API，API服务对企业外部开放，目前大多数的头部互联网企业都开放了自己的公共API，比如Google API、百度和腾讯的开放API等等。这些API的接口开放给公众使用，但数据本身毫无疑问属于企业，且都需要专属凭证才能进行访问； 私有API，API服务仅对企业自身内部开放，通常被各种企业防火墙或者安全网关裹得严严实实，外部无法触及，我们常见的企业内部的微服务系统就都是由私有API构成的； 混合API，顾名思义，兼顾外部公众访问和内部私有访问的API服务，比如，某企业的API服务本来都是私有API，为了给它的战略合作伙伴企业共享部分数据而开通的、可以被外部有限访问的API服务，就可能是混合API； 值得一提的是，还有一种与公共API、私有API、混合API非常类似的划分，即：外部API、内部API、共享API。 基于功能设计的划分当把类似MVC这样的代码设计风格应用到复杂系统的设计中时，组成整个系统的API服务也就进行了相应的层级划分： 系统层API，负责实际管控具体的系统内部资源，从传统的数据库、文件资源到传感器、执行机等物理器件都由系统层API操控； 过程层API，根据预定义的逻辑进行真实场景下的业务处理，相当于系统的大脑核心； 表现层API，主要负责给前端应用程序提供数据和操作接口，我们常说的BFF就属于表现层API； 好了，对API的基础内容我们就先聊到这里。也许有同学会好奇为什么要在讲安全测试之前”废话”这么多API基础，那是因为在对API进行有目的的安全测试之前，我们首先要做的一定是对目标API进行尽可能完备的拿捏，这就包括识别被测API的实现技术、了解API在整个系统当中的功能、位置、及其消费对象。这些信息往往可以通过查阅系统架构图、业务时序图、网络拓扑图、或者直接向TL、架构师询问来获取。唯有准确和清晰地掌握了这些信息，才能在测试开始前帮我们明确安全测试的方式方向，以及制定相应的测试计划。要知道，QA毕竟不是安全专家，绝大多数都不具备横向多领域、纵向深层次的安全缺陷定位能力，在面对项目的安全测试需求时，往往需要现学现卖、边了解边测试，那么这个时候，正确的学习和了解方向就是非常重要的。举个例子，REST API和SOAP API的安全规范是完全不同的，前者可能主要使用OAuth、OpenID Connect，而后者主要使用WS-*协议栈，如果在准备工作中混淆了，就会浪费大把的时间。再比如，同样技术栈的两个API，一个是外部API、一个是内部API，它们面对的安全风险是完全不同的，有些外部API可能需要多重认证，而有些内部API甚至可以裸奔，那么对它们的安全测试需求也就完全不同，这就需要更加针对性的去计划开展测试。 常见的API安全测试切点我们前面说过，安全问题是一个系统性的、工程性的问题，对整个被测系统的安全保障需要贯穿整个软件开发周期，不是一两次测试活动就能一蹴而就的。而当真正落实到具体执行的安全测试活动上来时，大家最快联想到的应该都是渗透测试。的确，作为安全保障工作中非常重要的一环，渗透测试的地位举足轻重。但遗憾的是，对于大众QA来说，基本都不具备开展渗透测试的知识储备和技术能力，所以渗透测试一般都由专门的安全专家来操刀。而且在很多项目上，客户基于对客观性的考量，可能会更加倾向于引入第三方的专业安全团队来开展渗透测试。所以，对大多数的QA同学来说，渗透测试一般不作为我们开展安全测试的方向。 当然，这并不表示QA不需要去学习渗透测试，相反的，我个人非常鼓励对渗透测试感兴趣的QA同学去深入学习和实践渗透测试。 那撇开渗透测试，QA还能如何开展有目的的安全测试呢？在QA的测试工具箱中，有一种可谓万金油的测试技术叫做”基于经验的测试”，其常用的技术手段包括：错误推测、探索性测试、基于检查表的测试。只要对这些测试技术和思路方法加以活用，我们就能规划出一些QA力所能及的安全测试套装： 风险推测，功能性的错误推荐技术提示我们可以通过对比被测应用的既往行为，或者其它类似应用的失效表现来预估被测应用可能出现的错误，类似的，我们同样可以参考其他API在类似接口上出现过的安全问题来预估当前被测API可能存在的安全缺陷，这其实和威胁建模有许多相似之处。错误推测技术的一个系统化方法是创建一个可能的缺陷列表，我们也可以类似的给被测API创建一个可能的安全问题列表，从而进行逐项校验； 探索性测试，将探索性测试的思路应用到安全测试中，对QA来说是非常有益的。我们说过，QA通常缺乏开展渗透测试的能力，具体的表现就是QA开展的安全测试活动会显得随意而缺乏目的性。比如，QA可能会对SQL注入”情有独钟”，对所有API输入见一个查一个，但却并不清楚自己到底想通过注入来达到什么目的。而使用探索性测试中的漫游测试思路，比如卖点测试法、破坏测试法等，就能帮助QA更好的组织安全测试的方向； 基于检查表的测试，检查表是QA开展安全测试最有利的武器。在缺乏独立开展全面、深度的安全测试能力的情况下，通过检查表来规划和罗列尽量多的测试点，既能降低对QA个体知识储备的依赖，又能确保对必要检查项目的覆盖。安全测试的检查表既包括常见安全问题的测试点，比如对不受认证保护的API接口的排查，也包括对被测API安全配置的检查点，比如在生产环境不允许开启Swagger UI功能； 常见的API安全漏洞要将基于经验的测试应用到安全测试中去，一个必须面对的问题就是哪里去找这些”经验”。QA毕竟不是安全专员，在安全问题方面获取的信息和积累的经验通常是非常有限的。但幸运的是，相较于质量问题的千繁万种，安全问题的类型与实例都有较清晰的归纳与分类，最重要的是有CWE、NVD这样统一的安全漏洞数据库，帮我们收录了每年发生的重要安全漏洞，也有OWASP这样的全球性的安全组织，帮我们归类和梳理众多的安全问题。所以，从OWASP学习安全知识，从CWE、NVD查询真实的安全漏洞，是QA快速刷经验的重要途径。 说到OWASP，就不得不提OWASP Top 10，作为众多Web安全问题的”风向标杆”，Top 10向来是安全专员最关注的指导信息之一。OWASP Top 10面向整个Web领域，将Web前端应用、后端服务、以及服务器的安全问题都囊括其中。而对于我们今天讨论的API安全测试，OWASP在2019年底正式发布了OWASP API Security Top 10，顾名思义，就是聚焦API安全问题的Top 10。QA可以对这些常见的安全问题进行快速理解，然后在自己的项目中因地制宜的实施有针对性的测试活动。这篇文章后面的类容，就以OWASP API Security Top 10中的问题为对象，介绍我们QA力所能及的安全保障手段。 API1-失效的对象级授权正常情况下，调用者通过登录认证后仅能访问自己被授权访问的资源，而授权验证失效的API允许调用者在通过登录认证后访问不属于它自己的资源。比如，调用者在登录后，可以访问/client/ID001/profile的资源，其中ID001是调用者自己的用户ID，而通过更换用户ID，调用者能够访问其他用户的资源/client/ID003/profile； QA可以采取的安全保障工作 对于所有的资源访问接口，通过更换查询参数，特别是用于身份识别的参数，来测试授权实现的正确性和完整性； 可自动化测试案例； API2-失效的用户认证API在身份认证的实现上存在缺陷或干脆就没有身份认证，将导致攻击者可以随意获取数据。比如API的身份认证允许使用弱密码，或者无锁定机制而被暴力破解，又或者没有设置或验证AccessToken的过期时间等等； QA可以采取的安全保障工作 如果我们自己的团队负责实施了API的认证实现，那么QA一定要对认证流程了然于心，清楚认证流程时序图上的每一个步骤； 向开发人员询问API采用的是哪种认证方式，确保团队使用的是业界标准的认证方式，而不是自己造轮子。尽可能的学习了解对应的认证方式，以确保团队正确地使用了该认证方式，比如对基于AccessToken的认证方式要正确设置和校验过期时间等； 测试验证API的登录接口、忘记密码接口、以及重置密码接口都实施了访问控制策略，以防御暴力破解、撞库、密码喷洒等攻击； 结合业务需求禁止弱密码的使用； 确保API Keys不被单独用于用户认证； API3-过度的数据暴露API在响应客户端请求时，返回了超出请求需要的数据，特别是敏感数据。比如查询用户基本信息时返回了用户身份证号、密码，又或者查询用户订单信息时返回了用户账号信息等； QA可以采取的安全保障工作 测试验证所有的API都仅仅返回业务需要的数据，无用的数据绝不返回，特别是敏感数据； API4-缺乏资源和速率控制API在设计时没有对资源与速率做访问限制，比如允许客户端超高频的访问资源，或者对文件上传的接口不设大小限制，最终导致DoS和暴力攻击； QA可以采取的安全保障工作 和团队一起确认API在功能层面或者网络层面有相应的访问速率控制策略且实施到位； 使用大文件测试文件上传接口，验证其对API功能和性能的影响； 对API请求中涉及资源获取的参数进行破坏测试，比如使用很大的值测试分页查询中的size/api/users?page=1&amp;size=999999999； API5-失效的功能级授权API在设计实现时，对管理类接口妄想通过隐藏来规避风险而未做认证管理。比如，客户端可以使用GET请求访问/API/shop/customer/ID001来获取用户ID001的数据，攻击者可以通过猜测，使用POST请求访问/API/shop/customer来尝试创建非法数据（这些都是标准的REST接口定义风格，非常容易猜测），如果/API/shop/customer正好是一个只有管理员才知道的方法且没做认证管理，就可能允许攻击的成功。再比如，看到/api/users/xxx这样的接口，很容易就能联想到/api/admins/xxx这样的接口，后者如果不做认证管理，就可能出现风险； QA可以采取的安全保障工作 测试验证所有的管理控制接口都实施了相应的认证控制策略，且认证策略都基于特定的角色权限控制； 如果团队是基于既有的认证授权服务进行的定制开发，比如基于Keycloak、Forgerock进行开发，那么一定要校验原始服务的各种默认管理接口，确保没有在高环境上开启不必要的接口； API6-批量分配通过API接口创建或修改数据时，很多时候会使用对象及其属性，如果对这些接口的对象属性缺少过滤，就会导致数据被篡改。比如，我们经常会使用POST或者PUT请求来创建或者修改数据，当修改的数据以对象属性的方式存在时，比如user.name、user.age等，我们正常请求的payload应该是{“user”: { “name”: “customer”, “age”: 18 }}，而攻击者可能添加额外的属性来发起请求，比如{“user”: { “name”: “customer”, “age”: 18, “is_admin”: 1 }}，如果API没有对这些属性进行过滤就有可能造成数据篡改； QA可以采取的安全保障工作 测试验证所有使用对象数据作为payload的接口，比如，先使用GET请求获取较完整的有效对象属性，再对POST或PUT等请求的payload赋值额外的有效属性来进行测试； 可以自动化测试案例 API7-安全性配置错误API本身也是应用程序，部署在特定的服务器或者云端，期间就会有一些与安全相关的应用级或系统级配置项，这些配置项如果配置不当就可能造成安全事故。比如禁用或者错误的配置了TLS，或者在生产环境开启了Swagger UI、辅助测试接口等本来只应该在开发测试环境开启的功能，又或者配置不当将服务内部在遇到异常情况时的错误堆栈信息在接口处进行了返回； QA可以采取的安全保障工作 和团队一起校验API的相关安全配置有被正确设置； 如果在低环境应用了辅助开发测试的接口或功能，一定要在高环境（预生产环境、生产环境）测试验证这些接口或功能是关闭或移除的； 测试验证API在遇到内部异常时不会返回错误堆栈信息等多余信息，包括来自依赖服务的错误信息； 测试验证没有开启多余的HTTP方法，比如对一个有效的GET请求，在相同接口上使用HEAD、POST、PUT、DELETE等不应该响应的HTTP方法进行测试； 对于响应来自浏览器端请求的API，测试验证正确配置了CORS规则； API8-注入老少咸宜、人见人爱的注入，但凡API在实现上对接受到的数据缺乏相应的校验和过滤，就能被攻击者炸出翔来。常见的注入对象包括SQL/NoSQL/LDAP的查询语句、系统命令行参数、XML解析、以及ORM/ODM。API6-批量分配中的漏洞就常常是和注入相结合来进行攻击的，比如一个接受上传视频的服务，它在创建视频时的API可能是/api/videos/new，接受的payload中包含{ …, “mp4_conversion_params”: “-v codec h264”, … }，如果API对参数缺乏校验，攻击者可能以{ …, “mp4_conversion_params”: “-v codec h264 &amp;&amp; rm -rf /“, … } 的方式发起攻击； QA可以采取的安全保障工作 测试验证所有可能用于数据存储、数据查询、命令执行的输入内容，包括URL的pathParameter、query、以及payload中的数据； 对于注入的防御，一定不能依赖于前端应用，API侧必须完整实施所有的防注入策略。这一点QA必须要和团队达成一致且确保实施落实； API9-资产管理不当资产管理不当不属于可被直接利用的漏洞，但它却是其他漏洞或风险发生的温床。最常见的问题是在生产环境上运行多个版本的API，新版本的API虽然有较完整的安全保障措施，但对老版本的API却缺乏保护。比如，对API的访问速率通常都是在网关处控制的，当更新API版本时，在网关处更新了控制规则地址为/api/v2/booking，但却遗漏了老版本/api/v1/booking，而老版本的API又没有被关闭访问，就可能造成服务遭受DoS攻击。除此之外，API版本自身管理混乱、缺少必要的文档或文档长期不更新造成API维护困难、以及更新依赖服务版本不及时等等，都可能为其它安全隐患埋下伏笔； QA可以采取的安全保障工作 关注老版本API的生命周期，当最新版本API有安全相关的变动时，和团队一起评估对老版本API的影响； 鼓励团队完成必要的API文档规建与更新； API10-日志记录和监控不足对API缺乏监控和日志管理，或者日志等级设计不合理、日志信息收集不全等，都可能导致在系统遭受攻击时，无法在第一时间掌握状况，从而错失采取防御措施的最佳时机，又或者在遭受攻击过后，无法统计和整理遭受破坏或损失的具体数据； QA可以采取的安全保障工作 提醒且确保团队对生产环境的日志和监控系统进行在线功能验证； 测试验证日志系统收集的数据包含足够的信息，比如接口的调用者、请求发生的时间戳、日志的操作者、操作详情、操作对象、操作结果等； 检查日志系统收集的数据不包括一些特殊信息，比如API的源代码片段、各种Token、用户的个人敏感信息、认证密码、加解密的密钥、以及数据库的链接字符串等； QA或者开发团队有时并没有权限直接访问生产环境的日志与监控系统，这时可以请求客户的相关人员代为做相应的测试与检查； 小结作为上篇的小结，我想再提一下，QA在API安全方面，虽然不具备安全专家那样的精湛技能和丰富经验，但也有一些QA独有的优势： 可以更早的触及和发现隐患，安全专家或安全团队介入项目交付的时期通常都比较滞后，如果把期望都压在最后的渗透测试上，对交付的风险是比较大的。相对的，QA全程参与项目交付，能够更早的触及和发现隐患，降低风险发生的几率与修复隐患的成本，这和我们平常讲的测试左移是同样的道理； 发现复杂场景下的安全隐患，第三方安全团队对API服务的安全测试或者审计通常都是基于模式或者经验来进行的，比如我们说的OWASP Top 10就是最典型的”经验之谈”，而有些具体项目下的安全隐患可能隐蔽在复杂的业务交互场景下，安全专员由于缺少相关的详细上下文，可能根本触及不到这样的隐患，又或者一些短期、临时上线的功能场景，可能压根儿就不会经过安全团队的把关，那么针对这样的场景，QA毫无疑问是最有机会发现问题的角色； 安全测试的自动化，功能测试中，”发现缺陷 -&gt; 修复缺陷 -&gt; 添加相应的自动化回归测试”是非常常见的做法，这个套路在安全测试、特别是API的安全测试中也同样适用。安全专家是不会帮咋们写自动化测试的，但QA通常会非常乐于； 所以，发挥QA的角色优势，频繁的、碎片化的、有目的的开展安全保障工作，能够最大限度的提升API的安全性。 最后，附上一些常用的安全方面的查询和学习网站：CVE：https://cve.mitre.orgNVD：https://nvd.nist.govCNNVD：https://www.cnnvd.org.cn/home/childHomeOWASP：https://owasp.orgOWASP Cheat Sheet: https://cheatsheetseries.owasp.org/","categories":[],"tags":[]},{"title":"契约测试二三事","slug":"契约测试二三事","date":"2022-10-26T08:41:44.000Z","updated":"2022-11-26T09:11:48.126Z","comments":true,"path":"2022/10/26/契约测试二三事/","link":"","permalink":"http://yoursite.com/2022/10/26/%E5%A5%91%E7%BA%A6%E6%B5%8B%E8%AF%95%E4%BA%8C%E4%B8%89%E4%BA%8B/","excerpt":"距离我上一次写契约测试的文章已经过去了三年，在这期间，契约测试在测试策略层面已经确确实实地被很多团队落地实践，无论是对工具的熟练层度、还是对引入契约测试的主观意愿，越来越多的团队在契约测试上都展现出了更高的使用水准，甚喜。 最近，我接触到了两个不同项目的一些事情，它们都对契约测试有所涉及，但又都包含了一些很容易让人迷失的细节，所以想和大家一起分享。 生产者端的契约测试不是“写”出来的","text":"距离我上一次写契约测试的文章已经过去了三年，在这期间，契约测试在测试策略层面已经确确实实地被很多团队落地实践，无论是对工具的熟练层度、还是对引入契约测试的主观意愿，越来越多的团队在契约测试上都展现出了更高的使用水准，甚喜。 最近，我接触到了两个不同项目的一些事情，它们都对契约测试有所涉及，但又都包含了一些很容易让人迷失的细节，所以想和大家一起分享。 生产者端的契约测试不是“写”出来的在一次帮助项目上的开发同学评审契约测试代码的时候，我留意到开发同学多次描述“……在生产者端的实现是这么写的……” ，我顿时感到有些“好奇”，因为正常情况下，Pact在生产者端的契约测试不是写出来的，而是执行出来的（否则“消费者驱动的契约测试”的最终结果就只能是累死生产者团队）。于是我们进一步地对生产者端的契约测试代码进行了走读。 结果发现，开发同学通过注解的方式、使用Pact的state功能对契约文件中定义的每一个交互分别进行了对应响应的实现。这样就会出现“契约文件定义多少交互，生产者端就要写多少测试”的情况，显然，这不是一种最佳的契约测试实践方式。 我们先来回顾一下契约测试在生产者端的一般实践方式，如下图所示，Pact从Pact Broker拉取契约文件（或者直接读取本地的契约文件），然后从契约文件中提取交互中的请求发送给生产者服务，生产者服务根据请求返回对应的响应，Pact再将生产者返回的真实响应与契约文件中定义的期望响应进行对比，得出测试结果。在这一过程中，生产者端的契约测试有两个重要特征：生产者端只需要执行测试，而不需要写测试，测试案例都由Pact通过契约文件来触发执行；测试执行过程中，要求生产者服务一定要是尽量真实的服务；这里的“真实”又体现在两个点上，其一，服务一定要是真正部署且运行的服务；其二，服务的代码一定（或尽量）要贴近真实产品的源码，避免包含或使用支持测试的辅助代码，即测试尽量保证非侵入性。 而Pact提供的state方式，恰恰是一种侵入式的测试方式。通常来讲，当消费者端期望测试一些异常情况下的交互时，可以和生产者端协商使用state来支持测试，比如测试生产者服务出现Internal Server Error的情况，这些情况在正常的测试环境中很难稳定触发，不能支持测试的持续执行，所以才会使用state的方式来“模拟”。所以，作为一种侵入式的模拟测试手段，state方式在契约测试中一定要慎用。 那么，回过头来想一下，为什么开发同学会在生产者端的契约测试中地毯式地使用state呢？我想可能还是对契约测试的理解有些流于表面造成的。通常情况下，当我们说到“写测试”的时候，头脑中的步骤大概是这样的： 分析和思考测试点； 把测试案例写下来； 执行测试； 而在使用Pact进行消费者驱动的契约测试时，特别是在生产者端，“分析和思考测试点”的工作显然是不需要的，因为已经有契约文件这个现成的测试集合了，那么要做的就是“写测试案例”和“执行测试”。怎么写？对于生产者端的契约测试，Pact官网并没有给出多少写的步骤（因为确实在生产者端，通常情况下就不需要写测试），唯独要写的就是state的方式。由此，可能会误导一些开发同学以为生产者端的契约测试就是根据契约文件的定义使用state来遍地开花，实则不然。 生产者端的契约测试要使用Mock吗？还是在上述对生产者端的契约测试进行评审的过程中，我们发现生产者端的state之所以“很香”，一个非常重要的原因就是方便构造数据。我们上面提到，state的主要使用场景是模拟生产者服务出现异常情况的响应，异常情况都可以模拟，那正常情况的响应岂不更是顺手拈来。以SpringBoot的Controller、Service、Repository三层划分来说，既然能在Service层（甚至Controller层）使用Mock返回任意数据的响应，那何必还去调用依赖服务或者查询数据库然后组装真实数据返回呢？毕竟对测试来说，测试数据的准备和保障永远都是令人头痛的事情，这对契约测试来说也不例外。所以，在“真香定律”面前，state + Mock就成了生产者端执行契约测试的最佳组合……貌似。 这样的认知有一个看似无懈可击的“理论支撑”，那就是：“契约测试验证的只是生产者服务返回的数据结构（少量情况下可能也会校验数值），通俗来讲就是schema，既然只验证schema，那生产者服务内部的数据是Mock的还是E2E的，其实并不重要”。如此考量，可能也是对契约测试的认知流于片面所致。作为契约测试众多价值中的一种：验证生产者服务的履约能力，期望的一定是最真实的生产者服务，能够E2E就尽量E2E，能不使用Mock就尽量不使用Mock，只有这样，我们验证的履约能力才是最接近真实的履约能力。实施自动化测试的目的，不是让测试能永远顺利通过，而是让测试能永远体现出其应有的价值。 当然，理想很丰满，但现实却很骨感。在实践过程中，我们确实难免会遇到依赖服务不稳定、测试数据难以构造等问题。这种时候，我们首先应该考虑的是使用虚拟服务（比如wiremock）和测试数据库（比如testcontainers），而不是通过state在生产者服务内部添加Mock代码，因为前者在解决数据依赖的同时保证了生产者服务自身的完整性和真实性，而后者则是外科手术式的侵入式实现。而当虚拟服务和测试数据库都无法满足我们的需求时，比如就是需要构造Internal Server Error的情况，那么就大可使用state + Mock的组合了。 换个角度看契约测试通常情况下： 我们都是在服务之间讨论契约测试，典型的场景就是在微服务之间构建契约测试； 契约测试要想发挥最大的价值，一定是在多（消费者）对一（生产者）的架构中； 然而，这两点也有例外。前段时间帮助另一个项目解析测试痛点时，就遇到了一个非常鲜明的案例。如下图所示，一个APP前端消费后端的API服务，甚至可以把后端的API服务理解为APP专属的BFF。对于这样的架构（其实这里都谈不上“架构”，仅仅算个调用关系罢了），通常我们是完全不用考虑做契约测试的，因为如此架构下的契约测试并不能带来多余UI E2E测试与API功能测试的任何价值。 然而，这个项目的痛点在于，在生产环境上要求可以同时共存不同版本的APP，BFF需要对历史版本的APP进行前向兼容。不同版本的APP在消费BFF时使用的接口定义可能不同，这就要求团队在每次更新BFF版本时，都要对所有历史版本的APP做回归测试，以避免出现接口不兼容的情况。显而易见，这个测试工作量是很大的，即使通过UI的E2E自动化测试来全回归，测试执行和维护的工作量也是远远超出了我们通常基于测试金字塔所期望的可控范畴。可如果我们换个视角来看待这个问题，如下图所示，将APP的不同版本视为各自不同的消费者服务，BFF还是那个唯一的生产者服务，那整个架构不就是我们前面提到的最经典的契约测试场景了吗？ 所以，只要我们能够建立既往各版本APP与其当时版本BFF之间的完整契约测试，我们就能为BFF的后续迭代变更提供强有力的质量保障，从而避免了每次更新BFF都要回归测试各个历史版本APP的艰难挑战。 说到这里，细心的同学可能会想，“UI的E2E自动化测试解决不了这个问题的根本原因是工作量太大，契约测试能够解决这个问题无非是因为测试维护和执行的工作量小而已，那么类似的，不用契约测试，而用API功能测试的方法，为各个版本的APP所消费的后端BFF版本建立各自的自动化API功能测试，是不是也能解决这个问题呢？” 答案是肯定的，建立多套自动化API功能测试确实可以解决相同的问题。那它和契约测试的区别又在哪里呢？答案就是没有区别。在这个场景下，当我们使用Pact进行契约测试时，其实质也是使用不同的契约文件触发了不同的版本的API测试。而当我们抛开Pact这个工具，使用类似RestAssured这样的工具来实现类似的“多套”API自动化测试时，我们达到的效果和使用Pact是几乎完全相同的。其实，当我们真的构建这种多套API功能测试时，我们所做的工作就是使用RestAssured对契约测试进行了实现。所以说，契约测试更重要的是一种思想，当我们剖析完问题的实质、确定可以使用契约测试来解决问题后，选择怎样的工具是可以非常灵活的。","categories":[],"tags":[]},{"title":"图像对比在UI测试中的实践-技术篇","slug":"图像对比在UI测试中的实践-技术篇","date":"2021-05-16T01:05:51.000Z","updated":"2021-05-16T06:36:36.923Z","comments":true,"path":"2021/05/16/图像对比在UI测试中的实践-技术篇/","link":"","permalink":"http://yoursite.com/2021/05/16/%E5%9B%BE%E5%83%8F%E5%AF%B9%E6%AF%94%E5%9C%A8UI%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5-%E6%8A%80%E6%9C%AF%E7%AF%87/","excerpt":"什么是UI测试中的图像对比首先唠叨一下什么是UI测试，顾名思义，UI测试就是泛指对UI的测试工作。UI又分图形化UI和非图形化UI，即Graphic User Interface和Non-Graphic User Interface，常见的GUI主要有Web页面、移动应用界面、桌面应用界面、以及嵌入式设备的图形界面等。而非图形化用户界面则主要是各种命令行终端程序，比如docker，xcrun，kubectl等。我们这里讨论的UI，限定在GUI的范畴内，严谨的同学就别挑刺儿了哟。 对UI的测试，又可以分为功能性的测试和非功能性的测试。功能测试主要关注应用的业务实现，非功能测试则关注业务实现之外的其它方面，比如安全性、性能、易用性、兼容性等。那图像对比在UI测试中扮演怎样的角色呢？","text":"什么是UI测试中的图像对比首先唠叨一下什么是UI测试，顾名思义，UI测试就是泛指对UI的测试工作。UI又分图形化UI和非图形化UI，即Graphic User Interface和Non-Graphic User Interface，常见的GUI主要有Web页面、移动应用界面、桌面应用界面、以及嵌入式设备的图形界面等。而非图形化用户界面则主要是各种命令行终端程序，比如docker，xcrun，kubectl等。我们这里讨论的UI，限定在GUI的范畴内，严谨的同学就别挑刺儿了哟。 对UI的测试，又可以分为功能性的测试和非功能性的测试。功能测试主要关注应用的业务实现，非功能测试则关注业务实现之外的其它方面，比如安全性、性能、易用性、兼容性等。那图像对比在UI测试中扮演怎样的角色呢？ 我们先来看看下面这个，白宫官网的页脚: 然后，同样是白宫官网的页脚： 你能一眼看出它们的区别吗？比较困难是吧，那如果再给你提供下面这个呢： 是不是瞬间就能发现它们之间的差异了。然后我们来仔细品味一下它俩的差异，最上面白宫图标的粗细变化，我们可以认为是截图噪音而忽略不计，那么左下角的单词错误，应该是文本的错别字，不涉及功能，属于用户体验的问题。而右下角缺失YouTube图标，则是实打实的功能缺陷。所以，图像对比在UI测试中并不是某种具体的专项测试，而是一种辅助手段，帮助我们方便快捷地定位各种可以被其捕获的、泛化的UI异常。 当然，称呼“UI测试中的图像对比”实在太拗口，所以平常交流中，更多的是使用它的英文及其译名，即Visual Testing和”视觉测试”。 图像对比在UI测试中的价值在UI测试、特别是UI自动化测试中应用图像对比能够带来非常直观的价值，它们包括： 替代自动化测试中的断言语句，提高自动化测试的维护效率和测试执行的稳定性； 实现对图表等绘图元素的回归测试； 能够捕获意料之外的UI异常； 更加适应敏捷项目中UI的频繁变更； 更好的描述UI的变化； 替代自动化测试中的断言语句，提高自动化测试的维护效率和测试执行的稳定性长久以来，UI自动化测试中的测试期望都是通过断言语句来实现的，比如 1cy.get(&#x27;div.main-content-article-wrapper &gt; article &gt; div &gt; div:nth-child(34)&#x27;).should(&#x27;contain&#x27;, &#x27;Price&#x27;) 期望一个特定位置的元素内容应该包含’Price’，但如果页面重构，变成了 1cy.get(&#x27;div.main-content-article-wrapper &gt; article &gt; div:nth-child(34)&#x27;).should(&#x27;contain&#x27;, &#x27;Price&#x27;) 那我们的自动化测试就会失败。相信凡是写过UI自动化测试的同学，都遇到过类似的问题，即我们对特定元素的断言，都依赖其相应的元素定位器，如果UI界面发生了结构性的调整（这些调整有时对用户还是无感的），已有的元素定位器很容易受影响。特别是当需要断言的页面元素很多时，这样的重构往往是UI自动化测试的噩梦。 而图像对比完全不需要使用断言语句来校验页面元素的特征，从而可以大幅简化使用断言语句的工作量，并且极大的提高执行自动化测试的稳定性，特别是对于那些内容丰富的页面，无论是校验的工作量、还是校验的稳定性，都远远优于传统的断言语句。 实现对图表等绘图元素的回归测试另一个“长久以来”，对绘图元素的回归校验始终是UI自动化测试中的痛点。前端获取后端提供的数据，使用Javascript和CSS动态地将其绘制在UI界面上，面对这些圈圈点点、条条框框，传统的UI自动化测试，无论是爷爷辈儿的Selenium、还是高富帅的Cypress，都只能望图心叹，而唯独图像对比可以“以图攻图”。这对于那些需要展示图形报表的应用，比如大数据前端，是非常有益的。 能够捕获意料之外的UI异常这是我对图像对比在UI自动化测试中最赞赏的价值！传统的、基于断言的UI自动化测试，只能做到“期望A在B有C的表现”，即只能期望某事按照希望的方式发生，可捕获的异常仅仅是“期望的事件没有发生”。而在此基础上，使用图像对比的UI自动化测试还能期望“不希望的事情不要发生”，即对于那些无中生有、完全意料之外的UI异常也能进行捕获。 曾经的一个客户项目，项目的产品是一个微前端，上线后会被嵌入到上一层的页面当中。某次，我们的图像对比测试在UAT测试环境中意外的发现，自己页面的某个widget居然被替换成了广告，整个团队大吃一惊，因为我们根本就没干过“这活儿”。经过几番技术调研和需求确认，最终才知道这是我们被要求引入的某个上层页面的Javascript“偷偷修改”的，而且是正确的业务需求。当时的那个广告很显眼，容易被人肉捕捉到，但如果是某个不起眼的小改动呢，常规的自动化测试方式都束手无策，即便是单元级别的snapshot测试也做不到，因为它是在部署后才会出现的”问题”。 更加适应敏捷项目中UI的频繁变更对于UI自动化测试，有一条金句：“只在UI稳定后再进行自动化回归测试”。而对于敏捷项目来说，不好意思，UI稳定的那一天多半就是上线的那一天。UI的频繁变更，对于自动化测试来说，主要考验的是咋们的体力和（忍）耐力，看你有没有足够的体力、三天两头的跟着UI变更来修改你的测试案例，以及面对一言不合就红红火火的pipeline、你能憋着多久不拍桌骂娘。而使用图像对比的UI自动化测试，虽然不能完全解除你发飙的风险，但得益于对断言需求的大量降低、以及图像对比服务的一键rebase，至少能让你每天少灭亡5000单位的脑细胞（大误），阿弥陀佛，善哉善哉！ 更好的描述UI的变化这一点，我坦白，很主观。当UI出现变化、需要跟Dev或BA去确认时，相较于查看日志或报告中的描述语言，我更喜欢眼见为实和看图说话。当然，随着自动失败截图和视频录制功能的丰富，像Cypress、Detox这样的测试工具，在这方面也做得很不错。 值得强调的是，尽管再高效和准确，图像对比也只是UI测试中的一种辅助手段，单独依靠图像对比是无法独立完成整个UI自动化测试的，我们仍然需要Selenium、Cypress那样的测试工具和框架来对浏览器和页面进行基本的操作，比如打开一个网站、填写某个表单、点击一些按钮等等。所以，图像对比是高效UI自动化测试的助推器，但并不是全部。 图像对比在UI测试中的自动化实施模式图像对比是一种高效的测试手段，理念非常清晰、简单。在具体的UI自动化测试中，图像对比的实施基本都遵循相同的模式，如下图： 其中： 初始化baseline的步骤一定是手动的，而且也是必须的； 图像对比和差异报告是自动完成的； 差异判定目前基本都是手动完成的，自动化能做的仅仅是发现差异，但差异并不等于缺陷，对于设计变更、新的需求、以及既有缺陷修复带来的UI差异，都是业务的正确表现； 显而易见，更新baseline的步骤也一定是手动的，当报告的差异属于正确的业务表现时，就应该将当前版本的UI截图设置为最新的baseline，否则后续测试会继续沿用之前的baseline； 当前的自动化图像对比方案如今的视觉测试工具已经非常多了，这里罗列了目前市面上绝大多数的相关工具。他们的主要区别在于： 获取途径，开源 vs 商业； 实现方案，工具&amp;框架型 vs 服务型； 测试流程，交互式 vs 批处理式； 商业和开源的区别不必多说。开源软件绝大多数都是本地工具或框架型的实现方案，服务型的实现方案主要集中在各种商业服务中，比如领头羊的Applitools就是远程服务型解决方案，非常类似于BroswerStack。 无论是工具型的实现方案（以下简称视觉测试工具）、还是服务型的实现方案（以下简称视觉测试服务），它们都遵循上面提到的自动化实施模式，UI操作和截图都发生在执行功能测试的本地环境。两者的关键区别在于图片的对比和Baseline的管理，一个是发生在本地环境，一个是发生在远端服务内。具体来讲，当测试获取到UI的截图后，视觉测试工具会将截图与本地的Baseline进行比较，得出差异报告，需要更新的Baseline也保存在本地环境。而使用视觉测试服务时，截图会被上传到远端的视觉测试服务，在服务端完成图片对比，当需要更新Baseline时，也是在服务端保存新的Baseline。 本地视觉测试工具 vs 远端视觉测试服务大量的实践告诉我们，UI测试中使用远端视觉测试服务要远远优于使用本地视觉测试工具，主要体现在： Baseline的管理和共享视觉测试工具将Baseline保存在本地环境，如果是一直个人使用，并没有多大问题，但如果要多人共享，麻烦就来了。以网页应用为例，图像都是来自于浏览器对应用界面渲染的结果，如果两个人的操作系统、浏览器版本、显示器分辨率等不同，即便面对相同UI，也可能得出不一致的图像。A、B分别在各自的电脑上、使用各自的Baseline通过了视觉测试，但最终发现两人的Baseline其实并不相同。当然，这里的差异更多属于噪音，但对于像素级别的图像对比来说，这样的噪音是难以忽略的。 所以，对于本地视觉测试工具来说，一种变通的使用方式就是将Baseline保存在代码的版本管理系统内，然后让组员共享相同的Baseline。该方式可行，但使用代码管理系统来存储二进制的图片文件、而且还是经常变动的图片文件，其本身并不是一种好的工程实践。 而视觉测试服务则完全不存在这样的问题，因为Baseline都是保存在服务端的，共享使用完全没有任何问题。 更新Baseline的难易程度图像对比替代语句断言的优势之一就是能更好的适应被测UI的频繁变更，这就要求图像对比能够更好的频繁更新Baseline。视觉测试工具一般使用单独的命令来更新Baseline，集成到持续集成环境后，则通常需要设定一个单独的Job来执行该命令。如果使用了版本管理系统来存储Baseline，那还得将本地的Baseline上传回版本管理系统才能完成整个操作。 而视觉测试服务则相对要简单得多，往往只需要点击服务页面上的一个按钮就全搞定了。 历史版本的可追溯性本地视觉测试工具通常都有一个硬伤，它们只会保存当前的Baseline，当需要更新Baseline时，会用新的Baseline覆盖掉之前的Baseline，整个环境中永远只会有最新的Baseline。然而对于Baseline来说，除了使用当前的Baseline来对比最新截图之外，有时候我们还希望能够浏览历史的Baseline，因为Baseline的历史版本，其本身就是对被测应用的迭代描述，甚至是各个里程碑的图像记录，是有其工程意义的。 显然，本地视觉测试工具无法提供这样的可追溯性，而视觉测试服务通常都会保留全部的图片历史，所以能够更好的满足这一特性。 基准版本的回滚举个例子，Dev提交部署了版本v005，告诉QA这是新的实现，QA在测试“确认”后，将图像对比的Baseline更新为v005版本，稍后，BA提出v005版本的“需求”是错误的，此时，Dev需要把代码回滚到v004版本，那问题来了，如果是本地的视觉测试工具，v004版本的Baseline已经被v005版本给替换了，缺少v004版本的Baseline，QA只能人肉确保版本回滚的正确性了。 所以，具备基准版本的回滚功能，可以在必要的时候，更好的实现视觉测试，而只有视觉测试服务才具备回滚基准版本的能力。 当然，视觉测试服务也不是无懈可击的。相较于本地的视觉测试工具，使用视觉测试服务的高成本是显而易见的，第三方商业服务的费用是实实在在的Money，即便使用开源的视觉测试服务，在服务部署上，对团队也多多少少有一些DevOps的技能要求。如果为了更好的使用效果，将开源视觉测试服务部署到云端，也会产生相应的计算资源费用。 交互式的图像对比 vs 批处理式的图像对比无论是本地的视觉测试工具，还是远端的视觉测试服务，在测试流程上，一般都可以分为交互式和批处理式两种。 交互式的测试流程一般如下图所示。在该流程中，图像对比的工作的全部嵌入到功能测试的步骤当中，每一步视觉测试都会将被测图像传递给图像对比的工具或服务，然后等待工具或服务返回图像对比的结果，就类似平常使用的断言语句。 批处理式的测试流程一般如下图所示。该流程的特点是视觉测试的步骤和功能测试的步骤完全分离，功能测试仅仅需要将图像保存到指定的路径下，待整个功能测试都结束后，再将所有的图像、一次性全部传递给视觉测试工具或服务进行对比。 交互式视觉测试和批处理式视觉测试在流程上的不同，造成了两者在呈现测试结果上的差异。对于交互式视觉测试，每一步测试都会即时获取到对比结果，从而使视觉测试的结果直接体现在功能测试的结得当中。而批处理式视觉测试，其步骤和功能测试完全隔离，测试结果由视觉测试工具或服务单独呈现。 至于视觉测试结果要不要和功能测试结果绑定在一起，并没有什么公理可依，大家尽可按照自己的实际需求进行取舍。只不过就个人而言，我更倾向于将二者分离，因为严格来讲，视觉测试给出的自动化结果，其本身仅仅是图像对比的结果，而图像对比结果并不等于测试结果。我们说过，图像对比只是UI测试的一种辅助手段，帮助我们从UI差异中去快速发现问题，图像对比仅仅揭示差异，而差异并不等于缺陷。所以，自动化视觉测试给出的结果不应该被直接用来表征UI测试的结果，否则它会大大的降低功能测试结果的可信度，失去可信度的测试是没有有价值的。 关于Micoo的一点啰嗦基于以上的考虑，Micoo选择了服务型的实现方式和批处理式的测试流程。Micoo的理念是聚焦最核心的图像对比工作，仅此。所以从功能上来说，Micoo仅仅是一个图像对比服务，它将操作UI应用和截取图片的工作，全权留给了功能测试去完成。这样貌似偷了个大懒，但实则拓宽了实施视觉测试的对象。理论上，任何UI应用，无论是Web应用、移动应用、桌面应用，只要它能被自动化测试并且截图，就能借由Micoo完成视觉测试。而将来，无论这些被测应用如何更新演进，只要其相应的自动化功能测试手段能同步跟进，Micoo就永远能为它们提供视觉测试的解决方案，这样就从根本上避开了当年BackstopJS在PhantomJS身上踩下的天坑（如果对这段内容感到很突兀，可以参阅之前的故事篇获取一些上下文）。 视觉测试在CI中的实施方式目前，基于视觉测试与功能测试的相互关系，它们在CI中的构建方式主要有四种，分别为：独立型、混合型、同步型、以及异步型的构建方式。 独立型的CI构建方式下图是独立型的自动化测试在CI中的构建方式，其特征是功能测试和视觉测试完全独立，互不依赖也互不影响。BackstopJS这类的工具就通常使用独立型的方式构建到CI当中。 混合型的CI构建方式然后是混合型的构建方式，其特点是视觉测试的步骤完全跟功能测试绑定在一起，即使用一套自动化测试实现功能和视觉的双重校验。不用多想，这就是标准的交互式视觉测试方案在CI中的构建方式，比如Applitools。 同步型的CI构建方式同步型的构建方式中，视觉测试依赖前置功能测试的产出，即先由功能测试获取到UI截图，再将截图交给视觉测试进行图像对比。其后续步骤，比如部署UAT环境，需要视觉测试通过才能进行。 异步型的CI构建方式异步型的构建方式与同步型的构建方式有相似之处，其视觉测试都要依赖功能测试的截图，不同的是，其后续步骤，比如部署UAT环境，可以不依赖视觉测试的结果，只要功能测试通过就可以自动部署。 实践中，不同CI构建方式的选择没有太明显的倾向性，主要还是根据所使用的视觉测试方案来制定，比如，独立的视觉测试工具多选择独立型的构建方式，交互式的视觉测试方案肯定是混合型的构建方式，而批处理式的视觉测试方案则可以在同步型和异步型构建方式中灵活选择。 视觉测试的有益实践最后，作为对大家耐心阅读至此的感谢，特此奉上一些实施视觉测试时的有益实践，纯干货： 什么样的项目适合引入视觉测试？视觉测试的实质是UI的一种自动化回归测试。在考虑是否引入视觉测试之前，先要确定是否需要建立UI的自动化回归测试。视觉测试对UI回归测试的帮助，概括起来就四个字：减负增效。通过大大降低测试断言的使用来减小自动化测试的编写和维护负担，同时提高测试的效能和稳定性。由此可见，真正适合引入视觉测试的项目，一般来说都是那些UI内容复杂、同时迭代变更又比较频繁的项目。此外，那些对UI呈现效果要求较高的项目，比如客户全是像素眼的PO，那么视觉测试也是不错的辅助手段。 什么样的项目不适合使用视觉测试？要明确的是，只要能被自动化测试的UI，技术上都能进行视觉测试，但视觉测试是否对任何UI项目都适用，却是不一定的： 如果项目连UI自动化测试都不需要，那自然就更谈不上视觉测试了； 过于简单的UI，有基本的自动化功能测试就足够了，没必要再加上视觉测试，毕竟视觉测试也是有”成本”的； 过于复杂的UI，注意，这里的复杂不是指UI内容的复杂，而是指UI操作的复杂。比如，一个需要进行满篇填写内容来提交表单的UI，在其功能测试的步骤中，就几乎已经遍历完了所有的界面元素，再对它进行视觉测试，并不能降低多少元素定位的成本。那么对这样的UI引入视觉测试，收益是不大的； 可以使用图像对比测试视频播放器，但视觉测试一个主要内嵌视频播放器的网页或移动端UI，一般来说不是一个好想法； 想玩儿服务型的视觉测试，但没有资源怎么办？“没有就要呗，不然还能咋地？” 当然，这是半句玩笑话。这里真正想说的是，长久以来，在项目的计算资源分配上，测试一直是二等公民。当我们计算启动项目需要使用的资源费用时，比如购买哪些云服务、需要多少计算实例、需要怎样的数据库或缓存等，通常只会考虑开发的需求，而不会也不需要顾及测试的需求。历史上，这是正确的，随便找一个CI的Agent，就能把我们常用的测试框架给打发了。然而，伴随着容器技术助推传统测试工具、框架向测试服务的转型，计算资源也开始成为自动化测试策略中需要规划的要素。这一点，对早就完成测试平台化、测试服务化的大厂来说，不是问题，但对玩儿敏捷的TW团队来说，却还是一个新的思考。所以，言归正传，想在项目中使用视觉测试服务，那么就尽量在项目早期阶段，将此需求体现到测试策略当中，呈现给团队和客户，从而提前准备和规划。 视觉测试中如何解决UI对象动态变化的问题？来了来了，这个凡是做视觉测试就一定绕不过去的问题： 页面中有视频，怎么办？ 图片slideshow会自动滚动，怎么办？ 显示的时间每秒钟都不一样，怎么办？ 那个ID每次请求都不一样，怎么办？ 这些UI中动态变化的元素，对实施图像对比是非常大的阻碍。当然，解决办法也是有的，比如： 掉包，UI显示的数据大多来自后端（或远端），有些数据是不恒定的，比如一些每次请求后端都会变化的信息，如动态ID、数字签名、特征码等等，又或者一些自己团队不可控的信息，比如一个显示价格的UI，自己团队只负责在UI中将价格显示出来，具体的数字则受后端或后台的控制而可变。对于这样的场景，我们可以使用服务虚拟化的技术来替换掉相应的后端，从而使用恒定不变的数据来保障视觉测试的可行。 作弊，使用虚拟服务来掉包测试数据的成本是很高的，另外，有些前端显示的内容并不是从后端获取的，而是前端自己生成的随机数据，那么对于这些无论是来自后端还是前端的动态数据，另一种”廉价”的处理方式，就是在功能测试中将它们直接修改成固定的假数据。比如，在Web的测试中，如果需要进行视觉测试的当前页面包含有动态数据，我们可以使用Javascript直接修改DOM的内容，将某个本应该是动态计算或获取的值替换成固定的内容，然后再对当前页面截图对比。 抹黑，至于那些频繁变化的视频或者图片，我们甚至可以来得更狠，直接修改DOM将其修改成相同大小的色块，从而保障视觉测试的可行。除了抹黑，还有抠图的操作，即直接删除视频或者图片的DOM节点，但一般不建议，因为大多数情况下，删除DOM节点可能会影响到页面的布局展示。 后门，有时为了实现视觉测试，但又不想修改DOM结构，就可以让Dev在测试环境中设置一些功能或者特效开关，比如，当开关关闭时，图片slideshow只显示第一张图片而不自动切换其它图片，从而使视觉测试成为可能。一旦使用的功能开关，就增加了UI的实现复杂度，测试也需要相应的关注这些功能开关不会影响到产品环境的表现。 罢工，如果上面这些都解决不了动态数据的问题，又或者能解决但成本太高，那么就应该考虑放弃进行视觉测试。合理适当的手动测试有时才是性价比最高的解决方案。 尽管我们有这些解决动态元素问题的方法，但显而易见的是，它们要么成本高昂，要么对被测DOM修修改改，带来收益的同时也引入了风险。所以对页面动态元素的评估，也是在策略上是否引入视觉测试的重要参考。 如何解决视觉测试中截图环境不一致的问题？初次接触视觉测试的同学，通常关注的是截谁的图、怎么截图，而只有在视觉测试中栽过跟头的人，才会更关注在哪儿去截图。比如，对Web应用来说，哪怕使用相同版本的Chrome和Puppeteer，在MacOS和Windows上截的图，可能是有差异的。更别说，在你的MacBook上截取的图像，和CI的Agent机器上截取的图像，差异可能更大。那么该如何避免这种差异呢？目前来说，最合适的方法，是在容器中进行截图。比如，将你需要的Chrome或者Chromium版本，打到特定的容器里，而后无论在本地环境还是CI环境，都将自动化测试运行在这个相同的容器内部，那么你得到的截图就一定是相同的。 当然，如果你使用Applitools服务，那么也不会存在截图环境不一致的问题，因为Applitools是将DOM片段上传到服务器上，在服务端使用指定的浏览器进行渲染和截图。 如何设定差异阈值最合适？不使用差异阈值最合适！使用差异阈值的目的，通常都是在一定程度内容忍对比差异，比如设置3%的差异阈值，就可以使视觉测试在自动报告对比结果时，对于图片差异区域低于整张图像的3%的测试，视为对比结果一致而通过测试。差异阈值主要用在一些容易产生截图噪音、或者对比经常出现一些小范围且无意义的差异的测试中，用来提高测试的鲁棒性。从测试方案设计的角度来说，差异阈值是很不错的想法，但真正的项目实践中，却并不是那么回事。原因很简单，差异阈值提高测试鲁棒性的代价是牺牲图像对比的敏感性。基于像素对比的视觉测试，高敏感性是其最大的优势，同时也是建立其测试结果可信度的根基。使用了差异阈值的视觉测试，其对比结果就从完全可信变成了部分可信，哪怕其可信阈达到99.99%，只要不是100%的完全可信，其测试结果就会受到质疑，任何存在可质疑结果的自动化测试都是无益的。具体来说，设置1%的差异阈值，测试就会自动容忍1%的图像差异，然而，没人能确保这1%的差异永远都发生在那些期望的、无关紧要的边角料区域，如果下一次这1%的差异正好就发生在一些关键的地方，比如价格的单位符号，那么测试遗漏的结果就可能很严重。另外，差异阈值是绝对的，但差异区域却是相对的。请问，3%的差异和1%的差异谁大？答案是不确定，比如，200x400图像的3%的差异，和1920x1080图像的1%的差异，后者的差异明显比前者要大得多。所以，请一定慎用差异阈值。 视觉测试挂得太频繁，怎么办？恭喜你，咋要的就是这效果！图像对比作为UI回归测试的一种辅助手段，当它频繁”挂掉”的时候，说明UI正在经历快速的变更，这其实并不是什么坏事。传统的功能性自动化测试，面对UI的快速变更，测试断言会频繁失效，给自动化测试的维护工作带来极大的工作量，搞得我们心烦意乱，这时往往需要评估继续进行自动化测试的ROI。而图像对比测试在更新baseline上的优势，极大的减少甚至部分消除了这些维护工作，让我们可以泰然面对频繁的测试失败。所以，不同的测试方式带来不同的测试体验，同时也改变着我们面对测试失败的心态。 最后最后想说的是，UI测试中的图像对比并不是什么技术含量很高的工作，但它却一定是效能很高的手段，把简单的事情做到精致、做到极致，也能得到非同寻常的收获。","categories":[],"tags":[]},{"title":"图像对比在UI测试中的实践-故事篇","slug":"图像对比在UI测试中的实践-故事篇","date":"2021-05-16T00:14:30.000Z","updated":"2021-05-16T12:50:36.855Z","comments":true,"path":"2021/05/16/图像对比在UI测试中的实践-故事篇/","link":"","permalink":"http://yoursite.com/2021/05/16/%E5%9B%BE%E5%83%8F%E5%AF%B9%E6%AF%94%E5%9C%A8UI%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5-%E6%95%85%E4%BA%8B%E7%AF%87/","excerpt":"这是一份在UI自动化测试中使用图像对比的实践分享，分为故事篇和技术篇两部分，故事篇会首先回顾这几年在视觉测试上的历程，技术篇则会介绍一些视觉测试上的技术总结。 六年前刚入职到ThoughtWorks成都办公室后，第一次参加QA社区的Catch Up，那时的我在新环境中还分不清谁是张三谁是李四。 会上，依稀记得有两位貌似道行深厚的人物，就某个工具的使用反馈，询问在座的众生，现场一片寂静。会后，回到组上，我好奇的 问了一下我们的TL（请允许这里隐去TA的名字，不然我多半会被怼的）那是什么东西、我们有没有使用，面对TL一番风卷残云的 介绍，作为刚刚从通讯行业跨入互联网行业才三天的菜鸟，小的我真的是屁都没听懂，唯一听明白并且记下来的就是“它还需要部署服务器，很难用”。 那个工具的名字叫做Viff，在后来很长的一段时间内，我仍然不知道它是干嘛的，而这，就是我第一次和UI测试中的图像对比的擦肩而过。","text":"这是一份在UI自动化测试中使用图像对比的实践分享，分为故事篇和技术篇两部分，故事篇会首先回顾这几年在视觉测试上的历程，技术篇则会介绍一些视觉测试上的技术总结。 六年前刚入职到ThoughtWorks成都办公室后，第一次参加QA社区的Catch Up，那时的我在新环境中还分不清谁是张三谁是李四。 会上，依稀记得有两位貌似道行深厚的人物，就某个工具的使用反馈，询问在座的众生，现场一片寂静。会后，回到组上，我好奇的 问了一下我们的TL（请允许这里隐去TA的名字，不然我多半会被怼的）那是什么东西、我们有没有使用，面对TL一番风卷残云的 介绍，作为刚刚从通讯行业跨入互联网行业才三天的菜鸟，小的我真的是屁都没听懂，唯一听明白并且记下来的就是“它还需要部署服务器，很难用”。 那个工具的名字叫做Viff，在后来很长的一段时间内，我仍然不知道它是干嘛的，而这，就是我第一次和UI测试中的图像对比的擦肩而过。 一不小心，摸到了图像对比的大门有时候，接触某种技术、思考某种解决方案，靠的真不是大咖的演讲，而就是那么点儿缘分和灵光一现。 时间来到2016年10月，某澳洲项目S。有一次，从王小礼的桌旁溜过，看她一副愁眉苦脸、生无可恋的样子，就猜到多半有”戏”。本着有“戏”大家乐的心态，随便打听了一下。 原来，她们组最近在给客户做产品换肤。了解S项目的同学应该都知道，客户是一个集团企业，旗下有八九个品牌，所以通常一个产品就会有八九套UI。 而她们组在做的，就是给其中的多个品牌同时换肤。面对每天都在变化的UI，有时甚至是往复修改的CSS，别说写自动化测试了，每张卡的人肉检查早都已经应接不暇了。 当时的闲聊中，我提到的建议是，不知道有没有什么工具能帮着检查这类UI快速变更的页面。下来再琢磨这个问题，经过一番折腾，最终发现原来有种手段叫做“Visual Regression Testing”。 至于后来王小礼是怎么熬出她们的品牌换肤的，我就不知道咯，阿弥陀佛~ 出师未捷身先死既然摸到了图像对比的大门，不进去捣腾捣腾，就说不过去了是吧！当时，开源社区中的当家花旦是BackstopJS，使用配置文件的方式来编写和管理测试案例，完全没有多大的上手难度，输出的报告对于从来没接触过视觉测试的人来说，还是让人眼前一亮。 当时，我们组的工作也是维护一个S项目下的某个前端应用，所以在项目上通过BackstopJS来实践视觉测试，便成了非常正儿八经的选项。然而、可是、没想到，仅仅用BackstopJS遍历了两三个页面，测试就…崩了!是的，你没看错，崩了！经过几番调查，问题很快确定了：BackstopJS基于配置文件来组织测试案例，执行测试时为了能够做到Headless，使用的驱动是PhantomJS（是的，就是那个作者半途跑路的PhantomJS），而PhantomJS原生不支持ES6。所以，解决办法就是……没有办法！什么，你说BackstopJS支持Puppeteer？Puppeteer发布v1版本是在2018年的一月，至于BackstopJS完成使用Puppeteer替换PhantomJS，那更是猴年马月的事情咯~ 找准目标，二次开发刚刚开门就撞上了叹息之墙，有够背的，可即便没能取得开门红，图像对比在UI测试中的巨大潜力，仍旧让我深信这是一滩值得去趟的“浑水”。 换个工具继续尝试，接下来盯上的就是Dpxdt（我用办公室阿姨擦桌子的抹布打赌，你第一次绝对不知道这玩意儿怎么念）。选择Dpxdt是有一番考量的，包括： 作者是Google的工程师，貌似很靠谱； 源码是Python，逼不得已了还能自己抢救抢救； 支持以服务化的方式来进行测试； 其中，服务化的测试方式是选择Dpxdt的重中之重！之前虽然在BackstopJS身上出师不利，但却发现了对视觉测试来说非常重要的关键点：视觉测试的最大价值在于图像对比，其它诸如浏览器驱动、页面操作、截图等工作，都不是也不应该是视觉测试的核心内容，它们应该由其它更擅长、更专注于此类活动的技术组件来负责，即术业有专攻，从自动化实施的层面考虑，尽量做到技术组件的功能内聚，这样，无论将来前端技术如何演进，也只需要更新相应的驱动组件即可，而图像对比作为视觉测试的核心，则不会受到影响。 想法很丰满，现实却很骨感。原生的Dpxdt，在实现上与BackstopJS有相似之处，比如，同样使用配置文件来管理测试案例，同样使用PhantomJS来驱动浏览器，但在架构上，Dpxdt实现了测试端和服务端的分离。在测试端，使用PhantomJS驱动浏览器进行页面操作和截图，然后将截取的图片上传到服务端，服务端使用ImageMagic进行图像对比，最后以一个Web应用的方式来管理和展示图像对比的结果。 很明显，直接使用Dpxdt是不可行的，因为绕不过PhantomJS的死结，但Dpxdt两端分离的架构设计，给移花接木带来了可能。为了在项目上进行视觉测试，只能对Dpxdt进行二次开发，包括： 封装Dpxdt暴露的API接口，重新构建可独立使用的客户端库； 解决一些Dpxdt在Windows环境下的兼容性问题，因为UI测试运行在Windows的EC2上； 加入了Ghost功能； 重建了部分服务的UI界面，原版的实在有些丑； Dpxdt在使用ImageMagic对比不同尺寸的图片时容易出错，使用compose进行了相应的预处理操作； 经过以上的修改，2017年5月，定制版的Dpxdt基本具备了相对稳定的图像对比功能。其带来的收益也是杠杠的，像素对比带来极高的测试敏感度，不会漏掉UI的任何异常，同时，去掉了UI测试中的几乎所有断言语句，大大的提高了测试的稳定性，这在那个Selenium的年代，是非常有价值的。 费劲心思修改出来的Dpxdt，肯定不会仅仅服务于一个项目。通过将Dpxdt部署到独立的EC2上（不得不说当年的客户真的是金主爸爸，EC2基本就是随意开)，这个视觉测试服务在TW和该客户合作的最后两年里，先后服务过6个项目产品，完成了超过5000次的图像对比，给合作的客户团队也留下了非常深的印象。 自力更生“如果让我再选择一次，我绝不会再用Dpxdt”，这是后来TW结束S项目后，正荷在一次QA社区的Catch Up上分享我们的视觉测试实践时，留下的让我记忆最深的话。原因很简单，除了我们当时整套自动化测试架构过于复杂之外，最让人难以忍受的就是Dpxdt的慢！贼慢！比贼还慢！其主要原因有二，一是Dpxdt将图片保存进了sqlite数据库文件，使得历史数据多了之后，数据库读写会非常慢。二是ImageMagic进行图片对比的速度实在是太慢了。久而久之，使用Dpxdt服务浏览图片和进行差异判定，就成了一件非常痛苦的事情。 在Dpxdt服务上近两年的视觉测试实践，让我更加确幸了一件事情：服务型的视觉测试方案，才是UI测试中图像对比的王道，原因我会在之后的技术篇中细聊。 时间来到2020年初，得知春节后将会入场的一个新加坡项目对Web UI有很高的要求（高到啥程度？后来的一次Sign Off，PO说：“你把F12打开，让我看看”，然后，“看吧，这个margin和设计差了2个px吧” ……想知道当时QA和BA的心情吗？），视觉测试自然就被我提上了日程。然而，Dpxdt毕竟已经是六七年前的作品，方案实现落后太多，继续改造已无益处。放眼此时的开源市场，提供图像对比的UI测试工具已经比比皆是了，光Cypress的插件就有一大堆。可是，服务型的解决方案却只有商业软件，比如大名鼎鼎的Applitools，可开源解决方案，一个都没有，这，就有些玩儿不动了。 人不折腾，天诛地灭，没有现成的，就自己撸一个呗！天意弄人，赶上新冠疫情，10天的闭门春节假期，还真就让我码了一个出来，取了个很俗气的名字叫Team Visual Test，简称TVT（是不是很囧）。TVT在考虑之初，就奔着跨团队和开源共享去做的，所以使用的都是非工作时间进行的开发和维护。 为了最大程度的提高视觉测试的速度，TVT在具体的图像对比技术上，选择了native-image-diff，虽然这是一个名不见经传的NodeJS图像对比工具，但它的实测速度是非常理想的，通过比较，native-image-diff的图像对比速度要比ImageMagick和OpenCV快得多。比如，下图是之前做的native-image-diff和ImageMagick在对比不通尺寸图片时的速度表现，native-image-diff的对比速度几乎是ImageMagick的三倍。 除了对图像对比技术的甄选，TVT还在项目上因地制宜的实现了一个图片文件共享的方案。我们使用容器化的方式来执行功能测试，然后将功能测试的容器和TVT服务的容器运行在相同的ECS Fargate实例的Task上，这样功能测试和TVT服务就能通过Bing Mounts的方式共享文件存储，从而实现了功能测试获取的截图，可以被TVT服务直接使用，从而避免了文件上传带来的耗时，使得整个视觉测试方案的速度可以更快。这样的实施方案，既有它的特性，比如项目上本来就使用Fargate实例，也有它的共性，比如即便不使用Fargate，随便一个Docker Swarm的环境，都能使用共享存储的方式实现类似的效果。 另外，不同于Dpxdt的单体服务，TVT在架构上是一个简单的微服务系统，将负责图片对比的图像对比服务和负责测试结果呈现的主服务分离开来。这样，如果将来有更强大的图片对比技术，只需要单独更新图像对比服务，就可以对TVT进行升级。 后来，在那个新加坡项目上，配上与Telegram的消息集成，TVT取得了非常好的效果。 然而，TVT毕竟只是一个春节假期赶工出来的成果，在服务部署、易用性、安全性、以及多客户端支持上都有不少欠缺。下项目后，又陆陆续续的花了一些时间来对TVT进行修修补补，于是打磨出了如今的开源视觉测试服务Micoo。关于Micoo，这里就不多言了，在稍后的技术篇中也许会提到部分内容，更多的细节，感兴趣的同学可以查看: Github主页 文档 写在最后目前，在SEA，在没有任何推广的情况下，已经和正在使用Micoo（包括其前身TVT）的客户项目已有4个。所以，故事讲到这里，故事也还在发生。","categories":[],"tags":[]},{"title":"微服务环境下的测试策略与落地实践","slug":"微服务环境下的测试策略与落地实践","date":"2019-07-02T09:04:27.000Z","updated":"2021-05-16T06:36:37.033Z","comments":true,"path":"2019/07/02/微服务环境下的测试策略与落地实践/","link":"","permalink":"http://yoursite.com/2019/07/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5%E4%B8%8E%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/","excerpt":"这篇文章原本是当年（具体当的哪一年，忘了…T_T)抱着学习的心态，翻译的Toby Clemson的文章《Testing Strategies in a Microservice Architecture》，后来又加入了一些自己在项目上的实践总结。最近在清理磁盘文件的时候，偶然又给刨了出来，索性就搬到博客里来吧~ 如果你在Google上面搜索”microservice test strategy”，你一定会找到下面这个结果：伴随着Martin Flower的大名赫然在目，但是，这篇文章的作者，不是老马，而是Toby Clemson。之所以提这个，是因为已经多次听到有小伙伴在述及这篇文章时，张口就是”Martin Fowler的那篇微服务测试策略的文章……”，所以，尊重作者，还是从记住他们的名字开始吧~","text":"这篇文章原本是当年（具体当的哪一年，忘了…T_T)抱着学习的心态，翻译的Toby Clemson的文章《Testing Strategies in a Microservice Architecture》，后来又加入了一些自己在项目上的实践总结。最近在清理磁盘文件的时候，偶然又给刨了出来，索性就搬到博客里来吧~ 如果你在Google上面搜索”microservice test strategy”，你一定会找到下面这个结果：伴随着Martin Flower的大名赫然在目，但是，这篇文章的作者，不是老马，而是Toby Clemson。之所以提这个，是因为已经多次听到有小伙伴在述及这篇文章时，张口就是”Martin Fowler的那篇微服务测试策略的文章……”，所以，尊重作者，还是从记住他们的名字开始吧~ 微服务作为一种新的系统架构设计风格，开始被越来越多的团队接受和应用，它在给团队带来新的开发体验的同时，也给产品的质量保证提出了新的议题，如何测试我们使用微服务构建的应用？有哪些问题是在我们测试微服务的过程中需要考虑的？等等这样的问题也开始随着微服务的普及，而成为越来越多质量保证工程师需要面临的问题。于是，我们总结并提出了一些在实际的微服务项目中有益的实践方式，它们中有的是在任何产品质量保证过程中都会涉及的内容，比如单元测试和集成测试，而有的则在微服务架构中才会突显作用的内容，比如契约测试。但无论是哪种类型的测试，我们都希望通过对微服务针对性的应用，来为我们的微服务系统应用提供最可靠的质量保证体系。 单元测试单元测试是对一个可测试应用的最小单元进行测试的活动。那么多小的可测单元才是最小的可测单元呢？这个问题没有统一的答案，一个函数、一个类、一个库等等都可能被选择作为一个最小的可测单元来进行单元测试。从软件开发的角度来看，这取决于软件的架构设计，如果我们在软件设计的时候就赋予了一个类甚至是一个函数高价值的功能，那么这个类或者函数就有成为单元测试被测对象的意义。而从软件测试的角度来看，在选择单元测试的被测对象时，策略上还需要考虑被测对象的可测性，看它是否可以进行单独的测试，或者存在复杂的对外依赖关系，进行单元测试的代价太高，比如需要准备过多的测试桩数据或测试桩服务等。 当一个单元具备了合理的被测价值和可接受的可测性时，我们就可以对其进行测试设计了。单就单元测试的设计而言，我们期望被测单元在大小上越小越好、在功能上越简单越好，以及在对外部依赖上越少越好，这样能更加方便我们设计可读性好、维护性强的单元测试案例。 在设计和进行单元测试的时候，根据对被测单元外部依赖的处理方式的不同，单元测试常被分成关联型的单元测试和独立型的单元测试。其中，关联型的单元测试就是将被测单元和它相关的外部依赖（其它的单元）作为一个整体，进行黑盒测试。它的优点是你不需要对复杂的依赖关系进行任何处理，通过测试可以得到关联单元之间真实的状态转换带来的被测单元的行为表现，而缺点就是当发现失效时，难于定位缺陷是来自被测单元还是外部依赖。 相对的，独立型的单元测试则是将被测单元之外的全部外部依赖使用测试替身替换，保证发现的任何失效都是来自被测单元的缺陷。独立型的单元测试因为使用了测试替身，所以它既可以测试被测单元作为服务或数据生产者的行为正确性，也可以检查被测单元作为服务或数据使用者时是否正确调用和解析了来自外部依赖的数据源。当然，在提供这些优势的同时，独立型的单元测试的缺点就是需要创建和维护测试替身，有时甚至是很复杂的测试替身。 值得一提的是，关联型的单元测试和独立型的单元测试并不是相互冲突的，实践当中，有时还会对同样的被测对象同时设计这两种测试类型。 那么对于一个如上图的微服务架构，我们进行单元测试的一般策略可以是： Domain，使用关联型的单元测试；因为领域层部分的代码通常都是进行各种状态转换和数据计算的复杂功能区，它和外部依赖的部分，比如Service Layer和Gateways都是数据强相关，对于这样的功能代码，使用测试替身的代价太高。 Gateways 和 Repositories，使用独立型的单元测试；这个部分的代码主要的功能是数据的传输和预处理，与之交互的数据主要都是来自外部依赖的单元，比如数据库和外部服务，对这部分单元测试的目的是验证获取的数据可以被正确的传输和解析，而不是测试和外部的交互过程，于是我们使用测试替身来模拟外部依赖的数据源可以得到更高的测试效率，另外，使用测试替身还可以帮助我们触发各种异常处理的测试场景，比如数据库返回异常的数值，这在使用外部依赖的时候是很难真实的重复测试的。 Service Layer，使用独立型的单元测试；这部分代码和上面的Gateways类似，它主要的功能是传输和预处理这个微服务与其调用者之间的数据，对其单元测试的目的同样是关注数据传输和处理的正确性，无论这个数据是微服务调用者发起的请求数据，还是Domain计算完成后返回的响应数据，都可以通过使用测试替身来获取很好的测试效果。 有时，一些微服务会在体量上设计得很小，只包含领域层与最简单的对外数据交互部分，比如一些功能单一却逻辑复杂的数据适配微服务，对于这样的微服务，较之单元测试，组件测试往往能得到更好的性价比。 单元测试是一项技术性比较强的测试活动，理论上，通过使用测试替身我们可以对每一个测试单元进行非常完备的测试，但那样做的代价也是很高的，无论是创建测试替身还是维护测试替身，所以在设计和进行单元测试时，应该时常审视我们的测试目的，避免进行过度的测试，使我们的单元测试套件有一个合适的体量，这既便于我们对单元测试本身进行维护，同样也保证我们的单元测试在持续集成的过程中能在较短的时间里完成执行。 最后，就像我们在任何敏捷实践中强调的一样，我们希望由开发人员来主导单元测试的编写，测试人员适度的参与评审，这样既可以较好的保证单元测试在案例场景上的质量。至于要不要做到TDD，团队应该根据自身的情况来决定。 集成测试集成测试是测试被测对象与其他外部组件进行交互的测试活动。集成测试的时候，被测对象都是和与之相关的外部组件共同协作的，他们共同组成了一个子系统。需要注意的是，虽然集成测试会贯穿整个子系统，但我们的测试对象始终只是其中的一个组件或模块，而不是整改子系统。这其实有点类似于单元测试中的关联型测试。 集成测试是所有测试类型中的万金油，我们既能在单元测试中看到集成测试的形式，也能在系统测试或端到端测试中讨论集成测试，这都取决于我们的测试策略如何来界定和执行集成测试。在微服务的集成测试当中，对测试的粒度没有固定的要求，我们通常强调的集成测试是指在微服务与外部系统交互的层面上的测试活动，比如微服务与数据库的交互，或者是一个微服务与另一个微服务的交互等等。 在一个类似上图的微服务当中，我们的集成测试关注的是当前这个微服务与数据库及外部服务的数据交互，我们的测试对象是Data Mapper和Gateways。这个我们在前面的单元测试部分也有提到，当时我们是选择将外部服务和数据库用测试替身进行模拟来提高测试效率，因为我们只关注外部的数据是否可以被内部的单元正确处理和传输。而对于集成测试，我们关注则应该是全部的交互场景，比如正向交互有多少场景、负向交互有多少场景，这些场景都应该体现在集成测试的测试案例当中。 Gateway 集成测试，我们应该测试各种协议错误，比如丢失报文头或无效的报文头，错误的SSL处理，以及各种收发消息的格式匹配问题。另外，外部服务超时无响应等异常案例也应该纳入集成测试当中。 当然，在使用真实的外部服务的时候，往往比较难实现各种负向或异常的交互场景，这时可以选择使用桩服务来进行测试，但其带来的效能开销需要被很好的权衡。 这部分测试还有一个难点是对特定数据的状态要求。比如你需要通过外部服务来获取某个数据的状态，而该状态又和时间相关，导致你在两次获取数据之间其状态就已经发生了改变，这种情况会给自动化的集成测试带来不小的麻烦。所以在策略上我们应该尽量选择或构造固定的数据来进行集成测试。 原文发表于2014年，其述及的”桩服务”、”数据状态改变”等内容，在当时，确实是集成测试中的一些难点。但随着技术的革新，目前这类问题已经有了更好解决方案，那就是服务虚拟化。至于服务虚拟化的内容，以后有时间，我再另文介绍吧，这里就不细讲了。我在今年成都的BQConf上面，正好有介绍这方面的话题，感兴趣的同学可以参考一下这里。另外，这本书《Testing Microservices with Mountebank》则更加详尽的介绍了虚拟化服务在微服务场景下的使用，值得推荐。 Data Mappers/ORM 集成测试，对于数据持久层的集成测试，关注的重点是获取的数据源能够被正确的映射和转换。特别是那些成熟的ORM组件，他们往往有非常复杂的数据处理逻辑，我们的集成测试应该尽量的覆盖所有可能涉及的数据操作，比如各种增删查改和断言处理等等。另外，越来越多的外部数据存储使用了网络分隔或分布式存储，那么就有可能会面临响应超时等网络异常问题，这些场景也应该在数据持久层的集成测试中予以考虑。 通过这样的集成测试，特别是持续的自动化集成测试，在对微服务的集成模块进行修改或重构时，我们就可以得到快速有效的反馈。有时，内部集成模块的功能回滚，或者外部模块的修改，都可能造成我们的集成测试的失效，而光靠集成测试是无法快速的发现造成失效的问题，这时如果需要通过测试来快速定位缺陷，就要依赖于足够的单元测试、集成测试以及必要的契约测试。 组件测试组件测试是指在系统内部，对一部分整合在一起的具备独立功能的模块进行的测试。组件内部的模块应该是强耦合的，其本身也应该具备良好的封装性，而且可以被独立的替换。组件是模块的组合，不同的组件又共同组成了整个应用系统，组件测试的目的是测试单个特定组件的正确性，而不同组件之间往往都是协同工作才能完成各自的功能的，所以在组件测试中，常常用到测试替身模拟被测组件的外部依赖，这样既可以避免去和复杂的外部组件交互（特别是当失效发生时，难于定位缺陷的位置），又可以确保测试环境是固定和可控的，而且还便于触发各种异常的测试场景。 在微服务中，从组件的定义就可以知道每个微服务本身就是最完整的组件。但测试某一个微服务时，其它与之相关联的微服务就使用测试替身来替换，从而限定我们的测试范围和缺陷可能发生的范围都在被测的微服务当中。 对微服务的组件测试是一种动态的测试，需要在微服务的运行时进行测试。在策略上我们有许多地方需要考虑，比如测试应该和微服务运行在同一个进程当中，还是单独运行再通过网络来访问被测微服务？我们的测试替身应该建立在微服务内部，还是单独搭建再和被测微服务交互？外部数据库应该连接真实的数据库，还是只是和加载在内存中的数据库镜像进行交互？一般说来，与内存中通过测试替身实例化的外部微服务或数据存储进行交互，都能够得到较快的测试运行速度，并且减少测试系统的复杂度。但这也要求我们的被测组件有比较灵活的配置管理方式，能够通过配置来很好的在测试模式和生产模式之间切换。比如我需要被测组件根据配置文件来自动的识别应该访问测试用的内存镜像数据，还是直接访问真实的外部依赖服务。为此，我们既可以使用配置文件来手动配置，也可以使用依赖注入框架。 同进程组件测试，使用同进程组件测试，就是在微服务本身的内部模块之外，构建用于测试的子模块，运行测试就会将测试数据和被测的微服务加载和运行在同一个进程当中。 同进程组件测试通常会自定义shim这样的套件，来给被测微服务发送请求消息和检索返回消息，当然，也有现成的工具可供使用，比如JVM的inproctester和.NET的plasma。不管是使用自定义套件还是使用现成工具，我们的目的都是替代真实的服务调用者，来和被测微服务进行尽量最多的消息交互。由于这样的交互过程完全是在内存中进行的，所以速度是远远高于真实的网络访问的。 前面我们提到，组件功能的完成往往都还需要依赖与其它组件或微服务的交互，所以我们还需要将这部分和其它组件交互的过程在同进程中实现，一般的做法就是使用内部数据源和测试桩客户端，由此，通过使用我们预定义的测试数据，不仅可以加快获取“外部”数据的速度，还可以重复、稳定的模拟外部依赖出现异常的情况，比如通讯超时、返回脏数据等等。 对于有挂载外部数据库的微服务来说，我们还可以使用内存数据存储来断开真正的数据库访问，它在提高测试性能方面的优势是不言而喻的。内存数据存储的实现，根据情况，我们既可以简单的自定义实现，也可以选择使用专门的数据存储工具，比如H2数据库引擎。需要提到的是，在使用内存数据存储的时候，我们需要足够的集成测试来确保数据持久层和真正的外部数据库交互的正确性。 最后，由于同进程组件测试隔绝了所有的外部依赖，这就保证了当需要依赖的外部组件，比如其他的微服务甚至是数据库，在进行他们自己的修改更新时，不会对我们被测微服务的组件测试造成影响，从而保证了测试的稳定性。 异进程组件测试，相较于同进程的组件测试，异进程的组件测试将被测的组件单独的运行起来，外部依赖使用桩服务或真实的数据源来进行测试。异进程的组件测试在测试组件的基本功能的同时，还能验证和部署相关的事物，比如对配置外部依赖的配置文件的读取是否正确等。而由于把外部依赖都纳入了组件测试的边界，所以我们在执行测试的时候，就必须还要兼顾外部依赖的启动关闭、端口配置等等额外的问题。当然，在异进程的组件测试中，因为使用了通过网络访问的桩服务和真实的数据库，测试运行的速度势必会低于同进程的测试，可是，如果被测的微服务存在非常复杂的外部依赖，或者持久层和数据库的集成很繁琐，那么异进程的组件测试方式还是比较推荐的。 异进程的组件测试中，微服务本身是监听真实的服务端口，所以我们在测试其基本的消息处理功能之外，还可以验证其网络配置的正确性，这是同进程组件测试做不到的。同样的，对外部桩服务的访问，以及持久层和数据库的交互，都可以验证微服务对依赖的配置是否正确，比如是否可以正确的访问配置的URL和端口。 当然，搭建外部依赖的桩服务是不可缺少的，我们可以选择使用动态的API访问，也可以使用固定的死数据，或者使用通过记录回放机制进行的交互。比如moco，stubby4j和mountebank既可以提供动态的API访问，又可以读取固定数据，而vcr则可以提供记录回放的功能。 在有了足够的单元测试、集成测试和组件测试的基础上，我们的微服务就已经有了一定的质量保证了。但这样的质量保证只对于单个的微服务。使用微服务构建的应用不可能只是单个微服务，都是多个微服务协同工作的来实现业务价值的，所以为了保证整个应用系统的质量，我们还需要使用契约测试来时刻保证微服务之间相互契约的完备，以及使用端到端测试来保证所有微服务作为一个整体能够满足真实的业务需求。 契约测试契约测试是用来验证服务生产者和服务消费者彼此之间契约完备正确的测试活动（这里的服务不仅限于微服务，也可以是传统的单体服务）。 什么事契约呢？当一个微服务被另一个微服务访问的时候，被访问的微服务称之为服务的“生产者”，发起访问的微服务称之为服务的“消费者”，生产者与消费者之间进行的交互就是他们两者之间的契约。比如消费者发起的请求消息，以及生产者返回的应答消息都是契约的组成部分。契约是存在于一对消费者与生产者之间的，如果有多对消费者和生产者，那么就会有多种契约的存在。比如，同一个生产者被三个不同的消费者访问，就存在三个不同的契约，类似的，同一个消费者访问三个不同的生产者，也存在三个不同的契约。 契约测试在形式上比较类似组件测试，因为它们都是通过收发消息来模拟服务的调用，但组件测试需要关注全部的调用场景，比如各种正向和负向的消息交互，而契约测试则不会深入的检测消息交互的场景，它一般只关注正向的消息结构是否完备正确，比如对于一个返回消息，契约测试关注它有多少个属性、每个属性的值是什么类型，而不会像组件测试那样去验证在什么情况下每个属性的值具体是多少。所以契约测试并不是组件测试。 一般而言，每个具体的契约测试都是由各个消费者来编写，它们只关注自己与生产者之间的契约关系，而执行这个契约测试则往往是在生产者的持续集成环境中进行的。也就是说，对于某一个服务生产者，在它的持续集成环境中可能同时运行多份和不同服务消费者之间的契约测试，其目的就是去发现每一次生产者的自身更新是否会对任何它的服务消费者造成影响。这一点对于内部由微服务构成的管道型结构的应用来说，是非常有意义的，因为其内部时常存在着复杂的相互调用关系，在这种关系下，对每个微服务的变更（无论是正确还是错误的）都有可能导致其它微服务的局部失效，致使整个系统可能会出现错综复杂的异常，而契约测试通过预警每个服务生产者的变更是否会造成已有契约的失效，来最大程度的避免了这种乱象的产生。 我们来看一个例子，如图的一个调用关系，四个微服务，其中，一个生产者，它提供的服务消息里面包含id、name和age三条数据。三个消费者A、B、C，它们都与生产者有着各自的契约，消费者A只需要生产者提供的id和name，即为契约A；消费者B只需要生产者提供的id和age，即为契约B；消费者C则需要生产者提供的全部id，name和age，即为契约C。此时，如果生产者需要对name进行修改，将字符串改成一个包含firstname和surname的对象，那么消费者A和消费者C就很可能因为这样的修改而在解析消息的时候出现错误，但消费者B则不会受到影响。所有，通过在生产者的开发环境中进行契约测试，我们便可以在部署之前预警这样的风险。那么对于生产者来说，如果这样的修改是必须的，那么就应该告知消费者A和C在适当的时候进行相应的修改，然后更新契约测试。 在上面的列子中，如果对name的修改不是生产者计划的，而是某个消费者期望生产者改变的，那对生产者而言，这就形成了一种“消费者驱动”的设计开发模式，这种消费者驱动的模式可以更好的确保生产者的开发工作从设计上都是满足其消费者需求的，避免了不必要的开发。 目前主流的契约测试工具，主要是Pact和Spring Cloud Contract。 E2E测试端到端的测试活动是为了验证整个系统能够满足预定的设计需求，它完全抛开系统内部任何的微服务架构，只从整体全局上去检验系统的业务价值是否得以实现。所以，在端到端的测试当中，我们进行的是对整个系统的黑盒测试，测试的方法也是遍历真实的GUI界面或者调用真实的API接口。而为了体现真正的业务价值，在端到端测试中设计测试案例往往也使用面向业务的DSL。 端到端测试除了展现整个系统的业务功能，还能确保与整个系统相关的外围环境可以正常的协作，比如防火墙、代理以及负载均衡等等问题。另外，当整个系统架构需要进行较大规模的修改，甚至重构的时候，端到端测试还能始终保证系统业务功能的正确性。 对于端到端的测试是所有测试类型中粒度最大的，我们需要模拟真实的用户场景来进行测试。对于GUI的应用，我们可以使用Selenium来进行Web的自动化测试，而对于没有GUI的单纯的API服务，我们可以使用Postman进行手动测试，或者REST Assured进行自动化测试。 测试边界对于端到端测试来说是一个需要权衡的问题，特别是在我们的应用系统存在外部依赖，而被依赖的对象又不在我们团队的控制范围之内时，是否要将外部依赖纳入我们的测试边界就值得去思考了。如果将依赖至于测试边界之外，每次测试的时候都去访问正在的依赖对象，我们就可以得到最真实的系统行为结果，但问题是这样的结果有可能不是稳定和可复现的，比如当依赖对象发生异常时，就会给端到端测试带来不小的麻烦，特别是对于运行在持续集成系统中的自动化端到端测试而言，更是如此；如果将依赖至于测试边界之内，就意味着我们需要自己搭建被依赖的桩服务，这样虽然可以保证测试的稳定性，但却给测试的真实性打上了折扣。所以如何选择针对外部依赖的端到端测试边界，是需要团队根据项目的整体开发策略，特别是风险策略来判断的。 除了测试的边界问题，端到端测试还面临一些普遍的难点，比如由系统的消息异步问题，所以我们总结了一些小的策略来帮助更好的进行端到端测试: 编写尽量少的端到端测试，因为通过其它低层级的测试，我们已经对微服务有了不错的质量保证，而端到端测试只是确保系统业务功能达到设计要求，所以不需要在过多的场景上消耗时间，比如一些很少遇到的场景或者是负向的场景。一个不错的实践方式是使用“时间预算”，团队成员共同决定一个可接受的以分钟为单位的端到端测试时间长度，之后所有的端到端测试都只运行这么长的时间，如果有新的测试案例需要添加进来，那就移除一些老旧的案例，始终保证测试的总时长不变。（不要告诉我你不知道我们这里说的是’自动化的端到端测试’） 测试的设计关注用户角色和场景，设计案例的时候，保证系统中每一种用户角色和他会进行的使用场景都被纳入测试范围就可以了，而其他的一些极端的场景就可以交由另外的测试去检验。 合理的选择你的测试端点，就像我们在前面讨论测试边界时一样，如果你的端到端测试严重受限于GUI或外部依赖，那么就应该考虑将依赖和GUI的部分放到测试边界之外，以确保测试的稳定性。 使用代码来描述和管理基础设施，雪花状的系统环境在给系统部署带来一定麻烦的同时，也给端到端测试带来一些额外的配置管理工作，特别是需要搭建一个新的测试环境时，需要顾及不少的环境部署问题，所以一个比较好的实践就是通过代码化的方式来实现全部基础环境的可重复式的构建，比如使用Ansible工具。（嗯，2014年，DevOps肯定不像现在这么深入人心~） 使用独立的测试数据； 测试数据是端到端测试的一个重点问题，特别是当测试数据不稳定，或是跟随时间基进行状态变化的时候，同样的测试往往可能失效，而这种“假失效”无法反应系统的问题，却会给测试带来困惑。所以保证测试数据的独立和可重复是非常重要的，比较好的方法就是在每次测试运行时，往数据库中单独加载固定的测试数据集合。 以上的这些策略在技术实现上有一定的难度，所以有的团队会选择绕过测试环境，而直接在生产环境上进行端到端测试。这样的做法也是无可厚非的，虽然它的测试效率会受到限制，但它能够反映最真实的系统行为，甚至发现一些只有在生产环境上才可能发现的问题。 总结 总的来说，微服务的环境下，以上的这些策略能够给测试哪些和怎么测试带来一些方向，虽然它们中的一些观点同样适用于传统的单体应用，但我们更希望它能给微服务的测试带来更多的针对性。当然，在实际的项目运行中，基于成本的考虑（包括人员、技术、时间等），很少有团队会实践所有上面述及的策略和方法，所以如何去制定一个最适合自己项目的微服务测试策略，永远都是留给团队自己需要回答的问题。","categories":[],"tags":[]},{"title":"契约测试之核心解惑","slug":"契约测试之核心解惑","date":"2019-05-19T11:36:10.000Z","updated":"2021-05-16T06:36:37.020Z","comments":true,"path":"2019/05/19/契约测试之核心解惑/","link":"","permalink":"http://yoursite.com/2019/05/19/%E5%A5%91%E7%BA%A6%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%A0%B8%E5%BF%83%E8%A7%A3%E6%83%91/","excerpt":"在之前写的《契约测试之Pact By Example》中，我曾提到会再写一篇文章，来聊聊如何正确地认识和理解契约测试（好吧，至少是我认为的”正确地”）。但在随后的一年多时间里，对契约测试的讨论渐渐淡出了我的视野。我的理解是，随着微服务的大行其道，契约测试作为带刀护卫，已经深入人心了，所以没必要再去炒这碗冷饭，就像现在已经没有谁会再来码字吹Selenium一样（…请相信，我一定不是因为懒才这么说的o(*￣3￣)o）。 然而，在最近参加的一次面向Dev的后端分享的讨论中，我意外的发现，契约测试作为构建微服务重要的一环工程实践，虽然确实已经被团队原生接受，但对于契约测试的理解，还存在一些认识上的盲点，特别是当契约测试与集成测试、接口测试一起讨论的时候，理解的偏差往往会被放大不少。所以，我想必要的码点字，分享一下我对契约测试的理解，还是有益的。","text":"在之前写的《契约测试之Pact By Example》中，我曾提到会再写一篇文章，来聊聊如何正确地认识和理解契约测试（好吧，至少是我认为的”正确地”）。但在随后的一年多时间里，对契约测试的讨论渐渐淡出了我的视野。我的理解是，随着微服务的大行其道，契约测试作为带刀护卫，已经深入人心了，所以没必要再去炒这碗冷饭，就像现在已经没有谁会再来码字吹Selenium一样（…请相信，我一定不是因为懒才这么说的o(*￣3￣)o）。 然而，在最近参加的一次面向Dev的后端分享的讨论中，我意外的发现，契约测试作为构建微服务重要的一环工程实践，虽然确实已经被团队原生接受，但对于契约测试的理解，还存在一些认识上的盲点，特别是当契约测试与集成测试、接口测试一起讨论的时候，理解的偏差往往会被放大不少。所以，我想必要的码点字，分享一下我对契约测试的理解，还是有益的。 “契约测试，是建立在服务的消费者和生产者之间的……”(此处省略废话N多字)，如果您要继续看下去，请注意： 以下的内容不会涉及基本的契约测试概念，比如消费者、生产者、契约、消费者驱动等等，如果您对这些基本概念还不是很清楚，建议您可以花点儿时间先google一下，当然，Pact的官方文档可以是一个很好的开始； 以下的内容不会涉及具体的契约测试编写和执行步骤，相关的内容，您可以参看我之前的文章《契约测试之Pact By Example》； 如果您之前在任何地方、通过任何方式，看到过一些我对契约测试的观点的分享，并且觉得我就是在胡说八道，那您也不用看下去了，因为后面都是胡说十六道，而已； 关于测试的表述在聊契约测试之前，让我们先来说一些平时看似毫不起眼的小话题—“测试的表述”。 “我们可以在E2E测试中覆盖这个场景，而不是单元测试…” 或者 “你们的E2E测试是怎么做的？…” 这里的E2E测试可能经常出现在我们的日常交流中，那你知道它的准确含义吗？答案是没有含义！它基本等价于你们一伙人去食堂吃饭（…笑啥，俺就是食堂党，咋的！），A：”今天吃啥？”，B：”新鲜的”。新鲜的啥？炒饭？面条？饺子？套餐？…… E2E，End To End，端到端，字面意思简单明了，但它只是一个副词（组），而不是一种测试类型。所以，我们真正想表述的，可能是E2E API Test。那么”E2E API Test”就完整的表述了一项测试活动了吗？不是的！E2E表示的是测试方式，API表示的是被测对象，但这里，我们还缺少被测对象的被测属性，比如，Function、Performance, Security等等，所以，一个比较完整的表述，往往可以是这样的： 当然，平常的交流中，一般不会这么文绉绉地去抠字眼，因为我们彼此都清楚讨论问题的上下文，这点很重要。特别是针对E2E测试这样的表述。比如，我们有一个前后端分离、后端是微服务集群的系统应用，同样的E2E测试可能就代表着完全不同的测试活动： 如果从更多的维度来思考，比如套上测试四象限的模式，那么对于测试活动的表述，还会有更多考量。但今天的主题是关于契约测试的，所以就不过多的展开了。为什么要在讨论契约测试之前来废话”测试表述”呢？因为契约测试其实是多种测试方式的和思维的复合产物，比如，契约测试是E2E的测试吗？还是说是基于Mock的？契约测试是服务的接口测试还是集成测试？等等。所以，如果对这些基本的测试概念不是很清楚的，很容易迷失在契约测试的理念中。 为什么要做契约测试？为什么要做契约测试？”因为我们是微服务”？(╬￣皿￣)=○ 很多回答这个问题的答案，都关注在契约测试的目的上。那么，什么是契约测试的目的呢？简单来说，契约测试就是为了发现契约破坏（Contract Breaking)而进行的测试活动。如果你使用过Pact或者Spring Cloud Contract，你会发现，契约测试本身也是通过调用Provider的API接口来获取Response，再与契约文件中期望的结果做对比，从而验证契约是否正确。形式上，这和我们的API接口测试，或者针对功能的集成测试（以下简称集成测试，因为我们这里不讨论API的安全、性能等问题）是非常类似的。换句话说，我们通过API的接口测试或者集成测试，也能达到检查契约的目的，那为什么还要做契约测试呢？这种思考逻辑是完全正确的，也是为什么很多初学者都认为契约测试没有必要的原因。 那再问，为什么我们还要做契约测试呢？真正能够回答这个问题的，不是契约测试的目的，而是契约测试可以带来的价值！ 契约测试的价值那什么是契约测试的价值呢？要说清楚契约测试的价值，就需要准确认识契约测试的精髓–”消费者驱动”。 消费者驱动的字面含义，大家都清楚，但往往容易忽略的是被驱动的对象。在讨论契约测试的范畴里，”消费者驱动”述及的对象是契约，而不是契约测试。 当某个provider正常上线后，某个consumer需要消费这个provider的服务，那么应该由consumer来提出期望建立它们之间的契约测试。因为，契约测试，形式上，虽然测试的是provider，但，价值上，保证的却是consumer的业务。如果consumer对自己都不上心，你还期望provider来时刻关注你的死活吗？别笑，在跨团队的微服务体系下，这些都是真切的痛点。 理清了消费者驱动，就让我们来看看契约测试真正的价值吧。一个经典的案例： 在上图一个简单的消费关系中，provider为consumer A，B，C提供服务。provider自己提供的schema包含name,age和gender三个简单的字段。请注意，这份包含name，age和gender的JSON，其本身，只是一个schema，并不是任何契约。契约一定是成对存在的，没有确切consumer的交互定义，只是schema，不是契约。一个列子，中介打印了一份合同，上面写好了房屋租赁的全部信息，但在房东和租客都签字之前，这份”合同”并不具有任何效力，所以它根本就不是一份有意义的合同，法律上，它叫”要约”。（…感谢我大学的法律老师，我居然还记得这个词儿） 现在，这里有三份契约（对应的，就应该有三份契约测试），consumer A消费provider的age和gender，consumer B消费name、age和gender，consumer C消费name和gender。就目前provider提供的schema来说，没有任何问题，大家相安无事。 某日，因为业务需求，consumer C期望provider提供更加详细的name信息，包括firstName和lastName。这个需求对provider并不困难，所以，provider打算对schema做类似下面的修改。 这样的修改，很明显，对consumer C是需要的，对consumer A无所谓，但对consumer B却是不可接受的，属于典型的契约破坏。此时，provider和consumer B之间的契约测试就会挂掉，从而对provider提出预警（至于，剩下的，怎么协调和consumer B的兼容问题，就不是契约测试关注的问题，那需要的是团队间的communication）。 上面这个示例中的一些细节，可以帮助我们发掘契约测试的价值点： “consumer A没有使用name，consumer C没有使用age”，基于消费者驱动的契约测试，契约的内容由consumer提供，其内容体现的是各个consumer对provider提供的schema的消费需求。这里的需求，不光包含consumer”需要什么”，还包含consumer”不需要什么”。这是非常有意义的，因为当你发现provider提供的schema的某些部分不被任何consumer消费时，就代表provider可以对schema的这些内容做任意的修改，完全不必担心会影响到任何consumer。这是契约测试非常重要的价值点。 “单个provider多个consumer”，要最大化的体现契约测试异于集成测试的价值，一定是在”单个provider对应多个consumer”的架构下来说的。因为，在只有一个provider和一个consumer的架构下，只存在一份契约，对该契约内容的任何修改，对这对provider和consumer来说，都是显而易见的，那么就不会出现契约破坏的情况。说人话，就是，如果是consumer提出要修改契约，consumer一定知道改怎么消费新的契约内容；如果是provider提出修改契约，对于唯一的一个consumer，provider能很方便的告知其将要对契约的修改。并且，在这种情况下，集成测试往往就已经完整的达到了契约测试的目的。 而在单个provider对应多个consumer的架构下，情况就大不一样了。provider和consumer C之间的契约修改，对consumer A无感，对consumer B却是契约破坏，对此，集成测试是无能为力的。仔细来看，这里有4个service，就会有4个集成测试。但每个集成测试都只会关注自己的业务正确性，具体来说： consumer A，因为不受影响，所以A的集成测试没有任何变化； consumer C，因为是契约修改的提出者，所以它会在provider提供新的schema后修改自己的集成测试，没有问题； provider，如果接受了consumer C的需求，大摇大摆地修改了schema，它也会相应的修改自己的集成测试，因为对provider来说，这个变更是正常的业务需求，也没有问题； consumer B，最倒霉，啥都没干就挂了，当然，它的集成测试会捕捉到这个failure，但那都是在provider的契约破坏生效之后的事情了，能做的也只有亡羊补牢。 可见，虽然4个集成测试都各司其职，但都不能对这个契约破坏的问题做到防患于未然！只有契约测试，才是这个问题的最佳答案！这就是契约测试最大的价值，它只会在”单provider多consumer”的环境下（这是微服务的常见场景，但不是必然场景），才能发挥出来。 “很显然，对consumer A无害，但对consumer B却是契约破坏”，&quot;很显然&quot;，仅仅是对于我们这个简单得不能再简单的示例而言，真正的业务场景下，特别是一些复杂的微服务集群，又或者是一些时间跨度很长的系统，对于某个provider，到底有多少个consumer？而provider的每一处修改，又到底会对哪些consumer的契约造成怎样的影响？这些往往都是很难确定的问题。我最近所在的一个集团项目上，一个搜索地址的基础服务provider，有十个左右的consumer，其中有八个consumer没有契约测试，就不清楚它们对provider的API具体是如何消费的，所以每次provider要更新，就得八方去通知这些consumer的团队来做回归测试。有时，一点小小的修改，回归测试一分钟就可以搞定，但人肉联系各个团队却会花上好几天…… 如果每个consumer都能和provider建立契约测试（这里我们暂且不考虑负载和去重的问题），通过类似Pact Broker这样的实践，我们就能很好的解决这些效率问题。 OK，理解透契约测试的这些价值后，对于”要不要做契约测试？”、”谁来做契约测试？”这些问题，相信你就不再疑惑了。想再次强调一下的是，契约测试很多情况下基于微服务而生，但并不代表每个微服务都一定需要契约测试。相对的，一些传统的单体服务，它的架构设计和部署实施，完全和微服务的理念相反，但它提供的服务却被众多的下游消费者使用，那么这样的服务，也有很强的契约测试需求。所以，千万不要把契约测试和微服务做”死绑定”，一定要基于服务的业务来考虑策略。 契约测试和接口测试、集成测试的区别“契约测试和接口测试、集成测试的区别”，从2015年我第一次在BQConf讲契约测试，到写这篇文章之前，最近一次和别人讨论契约测试，这都是一个一直被提起的问题。在上面的内容中，其实已经或多或少的提到了相关的内容。由于具体的测试方式，都是”调用API验证Response”，契约测试、接口测试、集成测试经常被放在一起来进行比较，甚至质疑彼此。 先让我们来看看接口测试和集成测试。说实话，对于测试理论夯实的QA来说，这里应该没有任何问题的，因为接口测试和集成测试，它们压根儿就是从完全不同的维度来描述测试活动的。 前面说过，如果要完整的描述一个测试活动，至少需要考虑三个内容：测试方式、被测对象、被测属性。然而，”接口测试”和”集成测试”，显然，都是我们根据上下文使用的简称，更准确的： 测试方式 被测对象 被测属性 接口测试 调用API接口 只能是API … 集成测试 … … 肯定是被测对象在于外部依赖集成时的行为表现 接口测试 被测属性 — 不定，可以是被测对象的性能或安全行为，但根据上下文，默认是功能行为； 集成测试 测试方式 — 不定，可以直接进行E2E的测试，也可以进行基于Mock的测试； 被测对象 — 不定，可以是UI，也可以是API，但根据上下文，默认是API； 所以，基于不同的维度，我们有”接口测试”和”集成测试”的表述，但，当放在和契约测试来讨论的时候，它们描述的可能是同样的测试活动。即，通过调用API接口，来测试API的功能行为。 这里，想强调一下集成测试中的”集成”。对于传统的瀑布开发模式，对应的测试流程按照测试级别（Test Level）划分，一般是：单元测试 -&gt; 集成测试 -&gt; 系统测试 -&gt; 验收测试，这是”集成测试”早期的由来。 那会儿的应用，往往是庞大的单体服务，服务内部有分工明细、边界分明的”模块”。这些模块被并行开发，就绪后就会进行彼此集成。集成的对象，一般可以简单分为：逻辑模块、数据库模块、外部服务模块。比如，在上古时代，对数据库的操作是比较繁琐的，开发人员往往需要自己组装SQL语句，然后封装成模块来供上层调用。单元测试可以保证这些模块自己的逻辑正确，但像”模块中的各个函数接受的参数个数和参数类型是否和模块使用者的需求相匹配”这样的问题，就需要集成测试来确保（集成不等于集成测试，内容所限，我就不过多说明了）。这些测试都是发生在单体服务内部的，类似于现在的组件测试。 如今，微服务的设计，将不同业务的”模块”拆分成了不同的服务，各个服务都是高内聚的。以Spring为例，Controller -&gt; Service -&gt; Repository，内部垂直划分，简单明了。像上面提到的手写SQL这样的数据持久化工作，已经基本不存在了，取而代之的是像spring-boot-starter-data-jpa或spring-boot-starter-data-mongodb这样功能强大、方便易用的公共组件，最重要的，这样的公共组件，一般都有很高的官方质量保证的。所以，结论就是，在上古时代的那种传统的集成测试，在微服务的体系下，已经基本不需要了。 而对于单个微服务的质量保障，特别是当这个微服务有外部集成的时候，比如数据库或者外部服务，我们仍然需要进行检查外部集成的测试。再结合微服务业务的单一性，我们可以很自然的将这种”检查外部集成的测试”合并到API的接口功能测试中。说人话就是，对于微服务，只进行API的接口功能测试，既涵盖对被测服务领域逻辑的检查，又覆盖其对外部集成的检查。 当然，这里已经讨论到了微服务测试策略了，我就不再过多展开了。话收回来，如果要和契约测试进行区别比较的话，我们只用考虑功能性的API接口测试就可以了。 理清了接口测试和集成测试的内部姻缘（下面我统称功能测试），我们就最后来说说它们和契约测试的区别吧~其实，上面那个示例，已经很好的展现了它们的区别，我就不过多解释了，简单来说： 功能测试关注的是provider的实现正确体现其设计，契约测试关注的是provider的实现（当然，肯定也包括设计）满足每一个consumer的需求。注意，功能测试只关注provider自身，契约测试关注每一个consumer； 功能测试的测试案例，由provider的团队提供，契约测试的测试案例，基于消费者驱动，由各个consumer团队提供； 一个provider只会有一个功能测试（谁要纠结”一个功能测试”是几个testcase，就把TA拖出去枪毙三分钟），但契约测试，理论上，可以无限，有多少consumer就可以有多少个契约测试； 同样的一个testcase，在功能测试里面出现一次，在契约测试里面出现N次，它们的含义是完全不同的。什么含义，自己琢磨琢磨； 一个testcase，出现在功能测试里面，却没有出现在契约测试里面，是非常有意义的。啥意义，再自己琢磨琢磨； 功能测试可以自娱自乐，契约测试必须组”对”上分； 契约测试可以替代集成测试吗？“契约测试替代集成测试”，说实话，第一次听见这个说法的时候，我是非常惊讶的，这得多大的脑洞才能给出这样的命题呀！ 提示一下，就题论题，这里的”集成测试”，并不全等与上面提到的”功能测试”，仅仅是一般论的集成测试。 先来揣测一下，为什么会有这样的问题吧。我们知道，在Pact（JVM）的实施过程中，第一步是在consumer端生成契约文件。这期间，Pact会根据自定义的契约，在consumer端启动一个mock server（如果你有看源码，就知道它只是一个普通的HttpServer实例），consumer向这个mock server发送request获取response，整个过程被记录成JSON的契约文件。 这个流程的最后一步，一直有一个大家乐于争论的话题：”要不要对response的内容做断言检查？”。这是一个很开放的问题，没有标准的答案。但我想强调的是，不加断言，这一切只是一个”流程”或者说”步骤”，加上断言，它就是测试。是的，对consumer来说，它就是consumer的一种集成测试（啥？”用的是Mock Server，都没有集成真正的provider，为什么叫集成测试？” 如果你有这个问题，可以再仔细想想集成测试的真正含义……）。 以上是解题背景。现在，让我们再来省一下题吧，”契约测试可以替代集成测试吗？”，这里，其实隐藏了很大的一个意识盲点。契约测试，描述的测试活动，一定是架设在一对consumer和provider之间的。那么题目里的集成测试呢？你是想替换consumer端的集成测试？还是想替换provider端的集成测试？还是说其实你也不清楚到我想替换哪一端的集成测试……”不！我想说的不是两个服务之间的集成的那种测试，而是整个系统，包括全部上下游服务，集成在一起的集成测试”……诶，好吧，那叫系统（E2E）测试…… 还是让我们回到一般论的集成测试上来吧（不然，要说的实在太多了 T_T），无论是consumer端还是provider端，集成测试的关注点，是consumer是否可以正确的消费provider的API，这里的”消费”包括调用接口和解析数据。它的被测对象，注意，一定是consumer，或者说，是一个服务作为consumer的角色（因为，某个服务经常既是consumer，又是provider）。而契约测试的被测对象，一定是provider。好了，这就是问题的核心，其它的细节，我想就不必再赘述了吧。 关于Pact和Spring Cloud Contract“用Pact还是Spring Cloud Contract？”，这是另一个经常被讨论的话题。它背后折射的却是另一个非常重要的概念博弈：契约测试 vs 基于契约的测试（契约驱动的测试）。 Pact的理念是消费者驱动的契约测试。什么是契约测试呢？目前，我没有找到任何”权威”的定义。其实，面向工程实践的理念，也许根本就没有权威，有的只是最适用于自身的实践总结。即便如此，我还是希望以个人的视角，提供一些解读： 如果你google搜索contract test，你得到的第一个答案肯定是Martin Fowler在2011年的这篇文章，但遗憾的是，老马这里讨论的契约测试，是解决在集成测试中，如何保证测试替身有效性的问题的，它和我们今天讨论的契约测试并不是一回事。但是，如果抛开契约测试的内容，而单论”契约测试”的定义的话，老马的文章其实表述了一个很有价值的点，那就是”契约是需要测试的”，这是非常有意义的。 Pact的官方文档，是另一个可以帮助我们理解契约测试的地方。它对契约测试给出了这样的定义：Contract testing is a way to ensure that services (such as an API provider and a client) can communicate with each other.，这里面需要关注的重点是communicate，它给出了Pact对契约测试范畴（scope）的定义。 对于任何以”XXX测试”命名的测试活动，我们都遵循同样的一个理解的公理：”XXX”一定是被测对象或被测属性。比如，UI测试，测试对象一定是UI；安全测试，测试的一定是被测对象的安全表现；兼容性测试，关注的一定是被测对象在兼容性方面的问题，等等。同样的，”契约测试”，被测对象一定是服务之间的契约。 好了，有了这三点重要的理论基础，就让我们来具体看看Pact和Spring Cloud Contract（以下简称SCC）的区别吧。 在上面的图中，给出了Pact和SCC具体的使用方式（逻辑路径）。当然，如果你有一些基本的Pact或SCC的使用经验，就再好不过了。 Pact，在consumer端生成契约文件，发布到Pact Broker，而后，provider从Pact Broker获取契约文件，触发provider端执行契约测试。 SCC，实际生成契约文件的工作是发生在provider端的，基于这份契约文件，在provider端，生成了Java的测试案例，这些测试案例用于provider的功能测试；而在Consumer端，使用同一份契约文件作为Stub，生成了基于WireMock的mock service，consumer可以使用该mock service来做集成测试。 可见，Pact作为消费者驱动契约测试的倡导者，真正地实践了消费者驱动的契约测试。相对的，SCC，既没有实际的将契约作为被测对象来进行测试，更没有确实地实现”消费者驱动”。SCC的做法，实际上是基于同一份契约，分别驱动了consumer端的集成测试和provider端的功能测试。所以，Pact和SCC的区别，就在于，前者做的是”契约测试”，后者做的是”基于契约的测试（契约驱动的测试）”。 如果有同学阅读过SCC的文档，一定会质疑，SCC明文写着”Spring Cloud Contract Verifier enables Consumer Driven Contract (CDC) development of JVM-based applications”，那为什么说它没有确实地实现”消费者驱动”呢？因为在SCC的设计中，原始契约文件是在provider端生成的。为了实现CDC，consumer需要在其本地克隆provider的代码仓库，”借”provider来生成原始的契约文件。显然，在现实的项目中，consumer团队不可能随心所欲的获取到provider代码仓库访问权限，所以有了后来的，基于Share Repo的解决方案，来实现契约的共享（编辑和使用）。所以说，从最初的设计思想来看，SCC并没有像Pact那样，”实实在在”地实践了消费者驱动的契约测试。 那么，到底是选择Pact（契约测试）还是SCC（基于契约的测试）呢？答案是”按需取舍”。比较Pact和SCC的目的，并不是区别彼此的好坏长短，而是阐述它们各自不同的测试理念。Pact的价值点，前面已经说过了，SCC，虽然做的并不是真正的契约测试，但它通过共享（同一份）契约的方式，实现了微服务测试中，consumer和provider之间E2E集成测试的解耦，这在实际项目中，也是有重要的现实意义的。感兴趣的同学可以自己下来多研究研究，我就不在这里扩展了。 一些问题至此，在我看来，契约测试相关的认识难点，就已经基本解读到了。但在结束全文之前，有两个问题，我还想再阐述一下： consumer端的集成测试需要做到什么程度？对于Pact，前面提到，在consumer端生成契约文件的时候，加上断言语句后，就”构成”了consumer端的集成测试。这个集成测试，从Pact的角度来说，是可选的，它的目的是保证consumer端生成的契约文件本身是正确的。但从consumer的角度来说，要不要进行这一层级的集成测试，取决于consumer团队自己的测试策略。我想说的是，如果要进行这一层级的集成测试，请一定合理把握你的测试粒度和测试范畴。 测试粒度，由于这里的集成测试是和契约测试强绑定的，如果为了增加集成测试的覆盖率而设定过小的测试粒度，会大大增加契约测试的测试案例。而其中的一些测试案例，对于关注功能的集成测试来说，可能是不同的等价类，但对关注schema的契约测试来说，则完全可能是相同的等价类，从而造成测试冗余。所以，合理的把握测试粒度，是非常重要的。当然，就个人意见，我是反对这种和契约测试绑定的集成测试的。功能测试和契约测试，是完全不同的测试活动，它们肩负各自的使命、体现各自的价值，应该各司其职。这是我和Beth Skurrie（Pact最主要的核心开发成员，没有之一）多次探讨的一致共识。 测试范畴，是另一个需要考虑的问题。上面提到过，Pact将契约测试的范畴定义在了communicate。什么是communicate呢？很简单，通过通讯获取信息。具体到契约测试中，（可）通讯，体现在API的endpoint接受request（request包括protocol，url，header，body等），返回response；（可）获取信息，体现在获取的response能够被按照期望的方式解析（反序列化）。需要强调的是，communicate的内容不应该包含”使用信息”。使用信息，是consumer的领域逻辑需要处理的问题，而信息使用得是否正确，则应该是consumer的功能测试关注的范畴。注意，这里的功能测试可以发生在单元测试、组件测试、集成测试等各个测试级别。这就是为什么Pact的官方示例文档中，在consumer端，仅仅断言了response的status code这些非常简单的数据。如果consumer团队确实有需求，跨出communicate的范畴来构建集成测试，那么请一定合理斟酌你们的测试范畴。 “生产者驱动的契约测试”？相较于到目前为止通篇强调的”消费者驱动的契约测试”，你可能在其他地方，或多或少的，看到过”生产者驱动的契约测试”的命题。单论契约，确实可以分为”消费者驱动的契约”和”生产者驱动的契约”，但述及契约测试，到目前为止，恕俺视野有限，我并不认为”生产者驱动的契约测试”是一种正确的表述。 契约不等于契约测试，这不必赘述； 无论是消费者驱动、还是生产者驱动，其实质一定都必须是契约测试。这点，消费者驱动的契约测试不必多说，但对于”生产者驱动的契约测试”，事实可能并不是这样。生产者驱动的契约测试，其实质，就是上面讨论过的基于契约的测试（契约驱动的测试）； 具体来说，生产者驱动的契约测试，强调的是，当provider有需求和计划更新既有服务的schema时，在实际部署变更之前，先更新相应的”契约”（为什么这里的契约要加引号，自己琢磨琢磨），新的”契约”，如果包含契约破坏，会导致consumer端的（契约驱动的集成）测试挂掉。由此，consumer端可以在provider端真正部署包含契约破坏的服务之前，获得预警，从而对consumer做必要的更新准备，来适配provider将会部署上线的更新内容； 在我看来，这是契约测试的一种反模式。在消费者驱动的契约测试中，契约是复数存在的，每一份契约都会被provider测试，如果有契约破坏，会被及时反馈，必要的时候会被修正；而”生产者驱动的契约测试”中，”契约”是唯一存在的，它的正确性是不会被测试和质疑的，它仅仅会被consumer用来验证自己能否正确消费这份”契约”，所以，”生产者驱动的契约测试”，测试的并不是”契约”，而是consumer。 “如果质疑生产者驱动的契约测试，是因为它测试的不是契约，而是consumer，那么是否也可以质疑消费者驱动的契约测试，测试的也不是契约，而是provider呢？” 形式上来看，好像确实如此。但如果我们进一步分析，不难发现，消费者驱动的契约测试，对于不可接受的契约破坏的最终结果，要么是provider自主的功能修改被驳回，要么就是consumer主张的契约变更被驳回。结论就是，消费者驱动的契约测试，是对契约的双方进行约束，这体现了契约的意义，另一方面，对于不可接受的契约破坏，无论是哪一方引入的，它都将会被驳回，这体现了测试的意义(任何“功能”，如果交付测试后，无论结果好坏，它都是不可逆的，那测试本身也就失去了意义)。再来看“生产者驱动的契约测试”，一旦provider发布了“契约”，无论是否发生（对任一consumer）不可接受的契约破坏，无论“测试”的结果如何，这份“契约”都不可能被驳回，这样的“测试”，如果还说它的测试对象是“契约”的话，那这种“测试”对契约来说是没有意义的。归根到底，还是”契约测试”和”基于契约的测试（契约驱动的测试）”的区别。 当然，这样的测试活动，并不是一无是处，在一些上下游非常不稳定的微服务集群中，特别是在一些服务集群跨部门，甚至跨公司的多团队合作项目中，由于缺乏及时有效的沟通，往往更容易造成这样那样的契约破坏，此时，这种基于契约的测试活动，能很好的预警provider的API schema变更对consumer的影响，这是非常有意义的。 最后关于契约测试本身，和契约测试实施的问题，我想，远不止上面诉及的方面。不同的人、不同的团队，对契约测试的理解也可能都不一样，特别是，当一种（比较）新的理念在不同的现实项目中付诸实践时，可能遇到的问题，和思考的方式又会有所迥异，这些都是我们理解一种理念的正常途径。 问题永远都是客观存在的，但解题的思路却可以千奇百怪。我们讨论Pact、Swagger和Spring Cloud Contract，我们辩驳消费者驱动和生产者驱动，我们思考是先写契约测试还是先写功能测试，这些思想的碰撞越多，越能帮助我们去思考、理解和总结，继而产生出更加富有想象力的答案。比如，当需要把provider的schema中的一个String改成Object，从契约的角度，我们还在纠结如何协调所有的consumer影响最小时，“聪明”的小伙伴已经给出了这样一个答案：不把String改成Object，而是直接添加这个Object。 最后，送上我经常讲的一个问题：你知道最简单靠谱的契约测试工具是什么吗？是邮箱！╮(￣▽￣)╭","categories":[],"tags":[]},{"title":"契约测试之Pact By Example","slug":"契约测试之Pact-By-Example","date":"2018-02-28T15:33:51.000Z","updated":"2021-05-16T06:36:37.008Z","comments":true,"path":"2018/02/28/契约测试之Pact-By-Example/","link":"","permalink":"http://yoursite.com/2018/02/28/%E5%A5%91%E7%BA%A6%E6%B5%8B%E8%AF%95%E4%B9%8BPact-By-Example/","excerpt":"如今，契约测试已经逐渐成为测试圈中一个炙手可热的话题，特别是在微服务大行其道的行业背景下，越来越多的团队开始关注服务之间的契约及其契约测试。 从2015年开始我就在Thoughtworks和QA Community里推广契约测试，收到了不错的成效，期间有不少同学和我讨论过如何上手契约测试，发现网上介绍契约测试的讲义、博客不乏其数（当然，质量也参差不齐），可手把手教你写契约测试的文章却几乎没有，原因恐怕就是契约测试的特性吧。契约测试是架设在消费者和服务者之间的一种比较特殊的测试活动，如果你只是想自己学习而又没有合适的项目环境，那你得自己先准备适当的消费者和服务者程序源代码，然后再开始写契约测试，而不是像写个Selenium测试那样，两三行代码就可以随随便便地调戏度娘。～(￣▽￣～) 所以，我花了些时间磨叽出了这片文章……","text":"如今，契约测试已经逐渐成为测试圈中一个炙手可热的话题，特别是在微服务大行其道的行业背景下，越来越多的团队开始关注服务之间的契约及其契约测试。 从2015年开始我就在Thoughtworks和QA Community里推广契约测试，收到了不错的成效，期间有不少同学和我讨论过如何上手契约测试，发现网上介绍契约测试的讲义、博客不乏其数（当然，质量也参差不齐），可手把手教你写契约测试的文章却几乎没有，原因恐怕就是契约测试的特性吧。契约测试是架设在消费者和服务者之间的一种比较特殊的测试活动，如果你只是想自己学习而又没有合适的项目环境，那你得自己先准备适当的消费者和服务者程序源代码，然后再开始写契约测试，而不是像写个Selenium测试那样，两三行代码就可以随随便便地调戏度娘。～(￣▽￣～) 所以，我花了些时间磨叽出了这片文章…… 本文不会涉及契约测试的基本概念，因为相应的文章网上太多了，请大家自己去捞吧。本文也不会讨论契约测试的使用场景以及对其的正确理解，这方面的话题我会在今后另文介绍（好吧，我承认我很懒ㄟ(▔,▔)ㄏ）。 OK，以下开始正文！ 契约测试的精髓在于消费者驱动，实践消费者驱动契约测试的工具主要有Pact，Pacto 和 Spring Cloud Contract，其中Pact是目前最为推荐的，我下面的例子都将使用Pact来练习。Pact最早是用Ruby实现的，目前已经扩展支撑Java，.NET，Javascript，Go，Swift，Python和PHP，其中Java（JVM）是我们目前项目中使用最频繁的，所以我的例子亦都是基于PACT JVM来实现（观众A:我们都用Pyhton，你丫给我说Java(╯°□°）╯︵┻━┻） 示例源码大家可以从Github上获取本文示例的源码，也可以从PACT JVM官网上面找到对应的PACT-JVM-Example链接 示例应用示例应用非常简单，一个服务提供者Provider，两个服务消费者Miku和Nanoha（啥？你不知道Miku和Nanoha是什么？……问度娘吧……(～o￣3￣)～……）。 ProviderProvider是一个简单的API，返回一些个人信息。启动Provider： 1./gradlew :example-provider:bootRun 然后访问 http://localhost:8080/information?name=Miku 或者访问 http://localhost:8080/information?name=Nanoha 消费者 Miku &amp; NanohaMiku和Nanoha调用Provider的API拿到各自的数据，然后显示在前端页面上。启动Miku： 1./gradlew :example-consumer-miku:bootRun 然后用浏览器访问 http://localhost:8081/miku 启动Nanoha： 1./gradlew :example-consumer-nanoha:bootRun 然后用浏览器访问 http://localhost:8082/nanoha Miku和Nanoha做的事情基本一样，差别就是Nanoha会去多拿.nationality这个字段，而.salary这个字段Miku和Nanoha都没有用到。 示例中的1个Provider和2个Consumer都在一个codebase里面，这只是为了方便管理示例代码，而实际的项目中，绝大多数的Provider和Consumer都是在不同的codebase里面管理的，请注意哟！ Provider与Miku间的契约测试好了，大概了解示例应用之后，我们就可以开始写契约测试了（当然，如果你还想再撩撩示例的源码，也是可以的啦，不过相信我，里面没多少油水的） 我们先从Provider和Miku之间的契约测试开始。 请注意”之间”这个关键词，当我们谈论契约测试时，一定要明确它是建立在某一对Provider和Consumer之间的测试活动。没有Provider，Consumer做不了契约测试；没有Consumer，Provider不需要做契约测试。 编写消费者Miku端的测试案例目前，PACT JVM在消费者端的契约测试主要有三种写法： 基本的Junit Junit Rule Junit DSL 它们都能完成消费者端契约文件的生成，只是写法有所不同，带来的代码简洁度和部分功能有些许差异。 所有的契约测试代码都已经写好了，你可以在src/test/java/ariman/pact/consumer下面找到。 基本的Junit“talk is cheap, show you the code” PactBaseConsumerTest.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class PactBaseConsumerTest extends ConsumerPactTestMk2 &#123; @Override @Pact(provider=&quot;ExampleProvider&quot;, consumer=&quot;BaseConsumer&quot;) public RequestResponsePact createPact(PactDslWithProvider builder) &#123; Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); headers.put(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;); return builder .given(&quot;&quot;) .uponReceiving(&quot;Pact JVM example Pact interaction&quot;) .path(&quot;/information&quot;) .query(&quot;fullName=Miku&quot;) .method(&quot;GET&quot;) .willRespondWith() .headers(headers) .status(200) .body(&quot;&#123;\\n&quot; + &quot; \\&quot;salary\\&quot;: 45000,\\n&quot; + &quot; \\&quot;fullName\\&quot;: \\&quot;Hatsune Miku\\&quot;,\\n&quot; + &quot; \\&quot;nationality\\&quot;: \\&quot;Japan\\&quot;,\\n&quot; + &quot; \\&quot;contact\\&quot;: &#123;\\n&quot; + &quot; \\&quot;Email\\&quot;: \\&quot;hatsune.miku@ariman.com\\&quot;,\\n&quot; + &quot; \\&quot;Phone Number\\&quot;: \\&quot;9090950\\&quot;\\n&quot; + &quot; &#125;\\n&quot; + &quot;&#125;&quot;) .toPact(); &#125; @Override protected String providerName() &#123; return &quot;ExampleProvider&quot;; &#125; @Override protected String consumerName() &#123; return &quot;BaseConsumer&quot;; &#125; @Override protected void runTest(MockServer mockServer) throws IOException &#123; ProviderHandler providerHandler = new ProviderHandler(); providerHandler.setBackendURL(mockServer.getUrl()); Information information = providerHandler.getInformation(); assertEquals(information.getName(), &quot;Hatsune Miku&quot;); &#125;&#125; 这里的关键是createPact和runTest这两个方法： createPact直接定义了契约交互的全部内容，比如Request的路径和参数，以及返回的Response的具体内容； runTest是执行测试的方法，其中ProviderHandler是Miku应用代码中的类，我们直接使用它来发送真正的Request，发给谁呢？发给mockServer，Pact会启动一个mockServer, 基于Java原生的HttpServer封装，用来代替真正的Provider应答createPact中定义好的响应内容，继而模拟了整个契约的内容； runTest中的断言可以用来保证我们编写的契约内容是符合Miku期望的，你可以把它理解为一种类似Consumer端的集成测试； Junit RulePactJunitRuleTest.java 12345678910111213141516171819202122232425262728293031323334353637383940public class PactJunitRuleTest &#123; @Rule public PactProviderRuleMk2 mockProvider = new PactProviderRuleMk2(&quot;ExampleProvider&quot;,this); @Pact(consumer=&quot;JunitRuleConsumer&quot;) public RequestResponsePact createPact(PactDslWithProvider builder) &#123; Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); headers.put(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;); return builder .given(&quot;&quot;) .uponReceiving(&quot;Pact JVM example Pact interaction&quot;) .path(&quot;/information&quot;) .query(&quot;fullName=Miku&quot;) .method(&quot;GET&quot;) .willRespondWith() .headers(headers) .status(200) .body(&quot;&#123;\\n&quot; + &quot; \\&quot;salary\\&quot;: 45000,\\n&quot; + &quot; \\&quot;fullName\\&quot;: \\&quot;Hatsune Miku\\&quot;,\\n&quot; + &quot; \\&quot;nationality\\&quot;: \\&quot;Japan\\&quot;,\\n&quot; + &quot; \\&quot;contact\\&quot;: &#123;\\n&quot; + &quot; \\&quot;Email\\&quot;: \\&quot;hatsune.miku@ariman.com\\&quot;,\\n&quot; + &quot; \\&quot;Phone Number\\&quot;: \\&quot;9090950\\&quot;\\n&quot; + &quot; &#125;\\n&quot; + &quot;&#125;&quot;) .toPact(); &#125; @Test @PactVerification public void runTest() &#123; ProviderHandler providerHandler = new ProviderHandler(); providerHandler.setBackendURL(mockProvider.getUrl()); Information information = providerHandler.getInformation(); assertEquals(information.getName(), &quot;Hatsune Miku&quot;); &#125;&#125; 相较于基本的Junit写法，PactProviderRuleMk2能够让代码更加的简洁，它还可以自定义Mock Provider的address和port。如果像上面的代码一样省略address和port，则会默认使用127.0.0.1和随机端口。Junit Rule还提供了方法让你可以同时对多个Provider进行测试，以及让Mock Provider使用HTTPS进行交互。 基于体力有限，本示例没有包含MultiProviders和HTTPS的例子，有需要的同学可以在PACT JVM官网上查询相关的用法……别，别打呀，俺承认，俺就是懒…还打…#$%^&amp;*!@#$%^&amp;…喂：110吗？俺要报警…… Junit DSLPactJunitDSLTest 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class PactJunitDSLTest &#123; private void checkResult(PactVerificationResult result) &#123; if (result instanceof PactVerificationResult.Error) &#123; throw new RuntimeException(((PactVerificationResult.Error)result).getError()); &#125; assertEquals(PactVerificationResult.Ok.INSTANCE, result); &#125; @Test public void testPact1() &#123; Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); headers.put(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;); RequestResponsePact pact = ConsumerPactBuilder .consumer(&quot;JunitDSLConsumer1&quot;) .hasPactWith(&quot;ExampleProvider&quot;) .given(&quot;&quot;) .uponReceiving(&quot;Query fullName is Miku&quot;) .path(&quot;/information&quot;) .query(&quot;fullName=Miku&quot;) .method(&quot;GET&quot;) .willRespondWith() .headers(headers) .status(200) .body(&quot;&#123;\\n&quot; + &quot; \\&quot;salary\\&quot;: 45000,\\n&quot; + &quot; \\&quot;fullName\\&quot;: \\&quot;Hatsune Miku\\&quot;,\\n&quot; + &quot; \\&quot;nationality\\&quot;: \\&quot;Japan\\&quot;,\\n&quot; + &quot; \\&quot;contact\\&quot;: &#123;\\n&quot; + &quot; \\&quot;Email\\&quot;: \\&quot;hatsune.miku@ariman.com\\&quot;,\\n&quot; + &quot; \\&quot;Phone Number\\&quot;: \\&quot;9090950\\&quot;\\n&quot; + &quot; &#125;\\n&quot; + &quot;&#125;&quot;) .toPact(); MockProviderConfig config = MockProviderConfig.createDefault(); PactVerificationResult result = runConsumerTest(pact, config, mockServer -&gt; &#123; ProviderHandler providerHandler = new ProviderHandler(); providerHandler.setBackendURL(mockServer.getUrl(), &quot;Miku&quot;); Information information = providerHandler.getInformation(); assertEquals(information.getName(), &quot;Hatsune Miku&quot;); &#125;); checkResult(result); &#125; @Test public void testPact2() &#123; Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); headers.put(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;); RequestResponsePact pact = ConsumerPactBuilder .consumer(&quot;JunitDSLConsumer2&quot;) .hasPactWith(&quot;ExampleProvider&quot;) .given(&quot;&quot;) .uponReceiving(&quot;Query fullName is Nanoha&quot;) .path(&quot;/information&quot;) .query(&quot;fullName=Nanoha&quot;) .method(&quot;GET&quot;) .willRespondWith() .headers(headers) .status(200) .body(&quot;&#123;\\n&quot; + &quot; \\&quot;salary\\&quot;: 80000,\\n&quot; + &quot; \\&quot;fullName\\&quot;: \\&quot;Takamachi Nanoha\\&quot;,\\n&quot; + &quot; \\&quot;nationality\\&quot;: \\&quot;Japan\\&quot;,\\n&quot; + &quot; \\&quot;contact\\&quot;: &#123;\\n&quot; + &quot; \\&quot;Email\\&quot;: \\&quot;takamachi.nanoha@ariman.com\\&quot;,\\n&quot; + &quot; \\&quot;Phone Number\\&quot;: \\&quot;9090940\\&quot;\\n&quot; + &quot; &#125;\\n&quot; + &quot;&#125;&quot;) .toPact(); MockProviderConfig config = MockProviderConfig.createDefault(); PactVerificationResult result = runConsumerTest(pact, config, mockServer -&gt; &#123; ProviderHandler providerHandler = new ProviderHandler(); providerHandler.setBackendURL(mockServer.getUrl(), &quot;Nanoha&quot;); Information information = providerHandler.getInformation(); assertEquals(information.getName(), &quot;Takamachi Nanoha&quot;); &#125;); checkResult(result); &#125;&#125; 基本的Junit和Junit Rule的写法只能在一个测试文件里面写一个Test Case，而使用Junit DSL则可以像上面的例子一样写多个Test Case。同样，你也可以通过MockProviderConfig.createDefault()配置Mock Server的address和port。上面的例子使用了默认配置。 PactJunitDSLJsonBodyTest 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class PactJunitDSLJsonBodyTest &#123; PactSpecVersion pactSpecVersion; private void checkResult(PactVerificationResult result) &#123; if (result instanceof PactVerificationResult.Error) &#123; throw new RuntimeException(((PactVerificationResult.Error)result).getError()); &#125; assertEquals(PactVerificationResult.Ok.INSTANCE, result); &#125; @Test public void testWithPactDSLJsonBody() &#123; Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); headers.put(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;); DslPart body = new PactDslJsonBody() .numberType(&quot;salary&quot;, 45000) .stringType(&quot;fullName&quot;, &quot;Hatsune Miku&quot;) .stringType(&quot;nationality&quot;, &quot;Japan&quot;) .object(&quot;contact&quot;) .stringValue(&quot;Email&quot;, &quot;hatsune.miku@ariman.com&quot;) .stringValue(&quot;Phone Number&quot;, &quot;9090950&quot;) .closeObject(); RequestResponsePact pact = ConsumerPactBuilder .consumer(&quot;JunitDSLJsonBodyConsumer&quot;) .hasPactWith(&quot;ExampleProvider&quot;) .given(&quot;&quot;) .uponReceiving(&quot;Query fullName is Miku&quot;) .path(&quot;/information&quot;) .query(&quot;fullName=Miku&quot;) .method(&quot;GET&quot;) .willRespondWith() .headers(headers) .status(200) .body(body) .toPact(); MockProviderConfig config = MockProviderConfig.createDefault(this.pactSpecVersion.V3); PactVerificationResult result = runConsumerTest(pact, config, mockServer -&gt; &#123; ProviderHandler providerHandler = new ProviderHandler(); providerHandler.setBackendURL(mockServer.getUrl()); Information information = providerHandler.getInformation(); assertEquals(information.getName(), &quot;Hatsune Miku&quot;); &#125;); checkResult(result); &#125; @Test public void testWithLambdaDSLJsonBody() &#123; Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); headers.put(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;); DslPart body = newJsonBody((root) -&gt; &#123; root.numberValue(&quot;salary&quot;, 45000); root.stringValue(&quot;fullName&quot;, &quot;Hatsune Miku&quot;); root.stringValue(&quot;nationality&quot;, &quot;Japan&quot;); root.object(&quot;contact&quot;, (contactObject) -&gt; &#123; contactObject.stringMatcher(&quot;Email&quot;, &quot;.*@ariman.com&quot;, &quot;hatsune.miku@ariman.com&quot;); contactObject.stringType(&quot;Phone Number&quot;, &quot;9090950&quot;); &#125;); &#125;).build(); RequestResponsePact pact = ConsumerPactBuilder .consumer(&quot;JunitDSLLambdaJsonBodyConsumer&quot;) .hasPactWith(&quot;ExampleProvider&quot;) .given(&quot;&quot;) .uponReceiving(&quot;Query fullName is Miku&quot;) .path(&quot;/information&quot;) .query(&quot;fullName=Miku&quot;) .method(&quot;GET&quot;) .willRespondWith() .headers(headers) .status(200) .body(body) .toPact(); MockProviderConfig config = MockProviderConfig.createDefault(this.pactSpecVersion.V3); PactVerificationResult result = runConsumerTest(pact, config, mockServer -&gt; &#123; ProviderHandler providerHandler = new ProviderHandler(); providerHandler.setBackendURL(mockServer.getUrl()); Information information = providerHandler.getInformation(); assertEquals(information.getName(), &quot;Hatsune Miku&quot;); &#125;); checkResult(result); &#125;&#125; 当然，Junit DSL的强大之处绝不仅仅是让你多写几个Test Case， 通过使用PactDslJsonBody和Lambda DSL你可以更好的编写你的契约测试文件： 对契约中Response Body的内容，使用JsonBody代替简单的字符串，可以让你的代码易读性更好； JsonBody提供了强大的Check By Type和Check By Value的功能，让你可以控制对Provider的Response测试精度。比如，对于契约中的某个字段，你是要确保Provider的返回必须是具体某个数值（check by Value），还是只要数据类型相同就可以（check by type），比如都是String或者Int。你甚至可以直接使用正则表达式来做更加灵活的验证； 目前支持的匹配验证方法： method description string, stringValue Match a string value (using string equality) number, numberValue Match a number value (using Number.equals)* booleanValue Match a boolean value (using equality) stringType Will match all Strings numberType Will match all numbers* integerType Will match all numbers that are integers (both ints and longs)* decimalType Will match all real numbers (floating point and decimal)* booleanType Will match all boolean values (true and false) stringMatcher Will match strings using the provided regular expression timestamp Will match string containing timestamps. If a timestamp format is not given, will match an ISO timestamp format date Will match string containing dates. If a date format is not given, will match an ISO date format time Will match string containing times. If a time format is not given, will match an ISO time format ipAddress Will match string containing IP4 formatted address. id Will match all numbers by type hexValue Will match all hexadecimal encoded strings uuid Will match strings containing UUIDs includesStr Will match strings containing the provided string equalsTo Will match using equals matchUrl Defines a matcher for URLs, given the base URL path and a sequence of path fragments. The path fragments could be strings or regular expression matchers 对于Array和Map这样的数据结构，DSL也有相应匹配验证方法，我这里就不罗列了，请参考官网的介绍； 执行Miku端的测试Test Case准备好后，我们就可以执行测试了。因为我们实际上是用的Junit的框架，所以和执行一般的单元测试是一样的： 1./gradlew :example-consumer-miku:clean test 成功执行后，你就可以在Pacts\\Miku下面找到所有测试生成的契约文件。 发布契约文件到Pact Broker契约文件，也就是Pacts\\Miku下面的那些JSON文件，可以用来驱动Provider端的契约测试。由于我们的示例把Consumer和Provider都放在了同一个Codebase下面，所以Pacts\\Miku下面的契约文件对Provider是直接可见的，而真实的项目中，往往不是这样，你需要通过某种途径把契约文件从Consumer端发送给Provider端。你可以选择把契约文件SCP到Provider的测试服务器去，也可以选择使用中间文件服务器来共享契约文件，你甚至可以直接人肉发邮件把契约文件扔给Provider的团队，然后告诉他们“这是我们的契约，你们看着办吧~”（当然，这样很Low …），这些都是可行的。显然，Pact提供了更加优雅的方式，那就是使用Pact Broker。 当你准备好Broker后，就可以用它来方便的实现真正的消费者驱动的契约测试了。 好吧，我得承认，“准备”这两个字我用得有些轻描淡写，实际的情况是你可能需要费一番周折才能弄好一个Broker服务。目前有好些方法可以搭建Broker服务，你可以直接下载官网的源码然后自己折腾，也可以使用Docker来个一键了事，更可以直接找Pact官方申请一个公共的Broker，当然，那样做就得暴露你的契约给第三方服务器，真实的产品项目多半是不行的，但如果只是学习，那就事半功倍了，比如我们当前的这个示例就是如此。 将契约文件上传到Broker服务器非常简单： 1./gradlew :example-consumer-miku:pactPublish 然后你会在命令行下面看到类似这样的输出： 12345678&gt; Task :example-consumer-miku:pactPublish Publishing JunitDSLConsumer1-ExampleProvider.json ... HTTP/1.1 200 OKPublishing JunitDSLJsonBodyConsumer-ExampleProvider.json ... HTTP/1.1 200 OKPublishing JunitDSLLambdaJsonBodyConsumer-ExampleProvider.json ... HTTP/1.1 200 OKPublishing BaseConsumer-ExampleProvider.json ... HTTP/1.1 200 OKPublishing JunitRuleConsumer-ExampleProvider.json ... HTTP/1.1 200 OKPublishing JunitRuleMultipleInteractionsConsumer-ExampleProvider.json ... HTTP/1.1 200 OKPublishing JunitDSLConsumer2-ExampleProvider.json ... HTTP/1.1 200 OK 上传完成之后，你就可以在我们的Broker服务器上面看到对于的契约内容了。 值得说明的是，你可以看到上面我们有7个Consumer对应1个Provdier。在真实的项目中，不应该是这样的，因为现在我们实际上只有一个Consumer Miku。我只是在不同的契约文件中对Consumer的名字做了不同的命名，目的只是展示一下Broker的这个漂亮的调用关系图。这只是一个示例，仅此而已。 至此，Pact测试中，Consumer端的工作我们就全部搞定了，剩下的就是Provider的活了。 Provider端的测试在Provider端，我们使用Gradle的Plugin来执行契约测试，非常的简单，不需要写一行测试代码： 1./gradlew :example-provider:pactVerify 在Provider端执行契约测试之前，我们需要先启动Provider的应用。虽然通过gradle我们可以配置自动关停应用，但对于初学者，我还是建议大家多手动捣鼓捣鼓，不然你都不知道这个测试是怎么个跑法。啥？不知道怎么启动Provider？自己去本文的开头部分找去 … 然后，你可以在命令行下面看到类似这样的输出： 1234567891011121314151617181920212223242526272829303132333435363738394041424344Arimans-MacBook-Pro:pact-jvm-example ariman$ ./gradlew :example-provider:pactVerify&gt; Task :example-provider:pactVerify_ExampleProviderVerifying a pact between Miku - Base contract and ExampleProvider [Using File /Users/ariman/Workspace/Pacting/pact-jvm-example/Pacts/Miku/BaseConsumer-ExampleProvider.json] Given WARNING: State Change ignored as there is no stateChange URL Consumer Miku returns a response which has status code 200 (OK) includes headers &quot;Content-Type&quot; with value &quot;application/json;charset=UTF-8&quot; (OK) has a matching body (OK) Given WARNING: State Change ignored as there is no stateChange URL Pact JVM example Pact interaction returns a response which has status code 200 (OK) includes headers &quot;Content-Type&quot; with value &quot;application/json;charset=UTF-8&quot; (OK) has a matching body (OK) ... Verifying a pact between JunitRuleMultipleInteractionsConsumer and ExampleProvider [from Pact Broker https://ariman.pact.dius.com.au/pacts/provider/ExampleProvider/consumer/JunitRuleMultipleInteractionsConsumer/version/1.0.0] Given WARNING: State Change ignored as there is no stateChange URL Miku returns a response which has status code 200 (OK) includes headers &quot;Content-Type&quot; with value &quot;application/json;charset=UTF-8&quot; (OK) has a matching body (OK) Given WARNING: State Change ignored as there is no stateChange URL Nanoha returns a response which has status code 200 (OK) includes headers &quot;Content-Type&quot; with value &quot;application/json;charset=UTF-8&quot; (OK) has a matching body (OK) 从上面的结果可以看出，我们的测试既使用了来自本地的契约文件，也使用了来自Broker的契约文件。 由于我们示例使用的Broker服务器是公共的，任何调戏我们这个示例应用的小伙伴都能上传他们自己的契约文件，其中难免会存在错误的契约。所以，如果你发现来自Broker的契约让你的测试挂掉了，请不要惊慌哟。当然，因为是公共服务器，我会不定时的清空里面的契约文件，所以哪天你要是发现你之前上传的契约文件没有了，也不必大惊小怪。 相关的Gradle配置OK，Provider和Miku感情故事我们就讲完了。在讲Nanoha之前，先让我们来看看Gradle的一些配置内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263project(&#x27;:example-consumer-miku&#x27;) &#123; ... test &#123; systemProperties[&#x27;pact.rootDir&#x27;] = &quot;$rootDir/Pacts/Miku&quot; &#125; pact &#123; publish &#123; pactDirectory = &quot;$rootDir/Pacts/Miku&quot; pactBrokerUrl = mybrokerUrl pactBrokerUsername = mybrokerUser pactBrokerPassword = mybrokerPassword &#125; &#125; ...&#125;project(&#x27;:example-consumer-nanoha&#x27;) &#123; ... test &#123; systemProperties[&#x27;pact.rootDir&#x27;] = &quot;$rootDir/Pacts/Nanoha&quot; &#125; ...&#125;import java.net.URLproject(&#x27;:example-provider&#x27;) &#123; ... pact &#123; serviceProviders &#123; ExampleProvider &#123; protocol = &#x27;http&#x27; host = &#x27;localhost&#x27; port = 8080 path = &#x27;/&#x27; // Test Pacts from local Miku hasPactWith(&#x27;Miku - Base contract&#x27;) &#123; pactSource = file(&quot;$rootDir/Pacts/Miku/BaseConsumer-ExampleProvider.json&quot;) &#125; hasPactsWith(&#x27;Miku - All contracts&#x27;) &#123; pactFileLocation = file(&quot;$rootDir/Pacts/Miku&quot;) &#125; // Test Pacts from Pact Broker hasPactsFromPactBroker(mybrokerUrl, authentication: [&#x27;Basic&#x27;, mybrokerUser, mybrokerPassword]) // Test Pacts from local Nanoha // hasPactWith(&#x27;Nanoha - With Nantionality&#x27;) &#123; // pactSource = file(&quot;$rootDir/Pacts/Nanoha/ConsumerNanohaWithNationality-ExampleProvider.json&quot;) // &#125; // hasPactWith(&#x27;Nanoha - No Nantionality&#x27;) &#123; // stateChangeUrl = new URL(&#x27;http://localhost:8080/pactStateChange&#x27;) // pactSource = file(&quot;$rootDir/Pacts/Nanoha/ConsumerNanohaNoNationality-ExampleProvider.json&quot;) // &#125; &#125; &#125; &#125; &#125; Gradle的配置也是非常的简单的，Provider，Miku和Nanoha作为三个单独的应用，都是独立配置的，其中的一些关键信息： systemProperties[&#39;pact.rootDir&#39;] 指定了我们生成契约文件的路径； Miku中的pact &#123; ... &#125;定义了我们Pact Broker的服务器地址，以及我们访问时需要的认证信息。 如果你想通过浏览器访问Broker，比如看上面的关系图，你也是需要这个认证信息的。这里的配置使用的是变量，真正的用户名和密码在哪儿？不告诉你，自己在代码里面找找吧(￣▽￣)~* Provider的hasPactWith()和hasPactsWith()指定了执行PactVerify时会去搜索的本地路径，相应的，hasPactsFromPactBroker则是指定了Broker的服务器地址； 为什么要注释掉Nanoha的契约文件路径呢？因为目前我们还没有生成Nanoha的契约文件，如果不注释掉它们的话，测试会报找不到文件的错误。我们可以在之后生成完Nanoha的契约文件后，再打开注释； Provider与Nanoha间的契约测试Nanoha端的契约测试和Miku端大同小异，只是我们会在Nanoha端使用ProviderState的特性。关于ProviderState的具体含义，大家可以参见官网的介绍. 准备Provider端的ProviderStateProvider会返回一个.nationality的字段，在真实项目里，它的值可能来自数据库（当然，也可能来自更下一层的API调用）。在我们的示例里面，简单起见，直接使用了Static的属性来模拟数据的存储：provider.ulti.Nationality 1234567891011public class Nationality &#123; private static String nationality = &quot;Japan&quot;; public static String getNationality() &#123; return nationality; &#125; public static void setNationality(String nationality) &#123; Nationality.nationality = nationality; &#125;&#125; 然后，通过修改.nationality就可以模拟对存储数据的修改。所以，我们定义了一个控制器pactController，在/pactStateChange上面接受POST的reqeust来修改.nationality：provider.PactController 123456789101112131415161718@Profile(&quot;pact&quot;)@RestControllerpublic class PactController &#123; @RequestMapping(value = &quot;/pactStateChange&quot;, method = RequestMethod.POST) public void providerState(@RequestBody PactState body) &#123; switch (body.getState()) &#123; case &quot;No nationality&quot;: Nationality.setNationality(null); System.out.println(&quot;Pact State Change &gt;&gt; remove nationality ...&quot;); break; case &quot;Default nationality&quot;: Nationality.setNationality(&quot;Japan&quot;); System.out.println(&quot;Pact Sate Change &gt;&gt; set default nationality ...&quot;); break; &#125; &#125;&#125; 因为这个控制器只是用来测试的，所以它应该只在非产品环境下才能可见，所以我们使用了一个pact的Profile Annotation来限制这个控制器只能在使用pact的profile时才能可见。 OK，总结一下就是：当Provider使用pact的profile运行时，它会在URL/pactStateChange上接受一个POST请求，来修改.nationality的值，再具体一些，可以被设置成默认值Japan，或者null。 Nanoha端的契约测试Nanoha端的测试文件和Miku端的差不多，我们使用Lambda DSL，在一个文件里面写两个TestCase。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class NationalityPactTest &#123; PactSpecVersion pactSpecVersion; private void checkResult(PactVerificationResult result) &#123; if (result instanceof PactVerificationResult.Error) &#123; throw new RuntimeException(((PactVerificationResult.Error)result).getError()); &#125; assertEquals(PactVerificationResult.Ok.INSTANCE, result); &#125; @Test public void testWithNationality() &#123; Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); headers.put(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;); DslPart body = newJsonBody((root) -&gt; &#123; root.numberType(&quot;salary&quot;); root.stringValue(&quot;fullName&quot;, &quot;Takamachi Nanoha&quot;); root.stringValue(&quot;nationality&quot;, &quot;Japan&quot;); root.object(&quot;contact&quot;, (contactObject) -&gt; &#123; contactObject.stringMatcher(&quot;Email&quot;, &quot;.*@ariman.com&quot;, &quot;takamachi.nanoha@ariman.com&quot;); contactObject.stringType(&quot;Phone Number&quot;, &quot;9090940&quot;); &#125;); &#125;).build(); RequestResponsePact pact = ConsumerPactBuilder .consumer(&quot;ConsumerNanohaWithNationality&quot;) .hasPactWith(&quot;ExampleProvider&quot;) .given(&quot;&quot;) .uponReceiving(&quot;Query fullName is Nanoha&quot;) .path(&quot;/information&quot;) .query(&quot;fullName=Nanoha&quot;) .method(&quot;GET&quot;) .willRespondWith() .headers(headers) .status(200) .body(body) .toPact(); MockProviderConfig config = MockProviderConfig.createDefault(this.pactSpecVersion.V3); PactVerificationResult result = runConsumerTest(pact, config, mockServer -&gt; &#123; ProviderHandler providerHandler = new ProviderHandler(); providerHandler.setBackendURL(mockServer.getUrl()); Information information = providerHandler.getInformation(); assertEquals(information.getName(), &quot;Takamachi Nanoha&quot;); assertEquals(information.getNationality(), &quot;Japan&quot;); &#125;); checkResult(result); &#125; @Test public void testNoNationality() &#123; Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); headers.put(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;); DslPart body = newJsonBody((root) -&gt; &#123; root.numberType(&quot;salary&quot;); root.stringValue(&quot;fullName&quot;, &quot;Takamachi Nanoha&quot;); root.stringValue(&quot;nationality&quot;, null); root.object(&quot;contact&quot;, (contactObject) -&gt; &#123; contactObject.stringMatcher(&quot;Email&quot;, &quot;.*@ariman.com&quot;, &quot;takamachi.nanoha@ariman.com&quot;); contactObject.stringType(&quot;Phone Number&quot;, &quot;9090940&quot;); &#125;); &#125;).build(); RequestResponsePact pact = ConsumerPactBuilder .consumer(&quot;ConsumerNanohaNoNationality&quot;) .hasPactWith(&quot;ExampleProvider&quot;) .given(&quot;No nationality&quot;) .uponReceiving(&quot;Query fullName is Nanoha&quot;) .path(&quot;/information&quot;) .query(&quot;fullName=Nanoha&quot;) .method(&quot;GET&quot;) .willRespondWith() .headers(headers) .status(200) .body(body) .toPact(); MockProviderConfig config = MockProviderConfig.createDefault(this.pactSpecVersion.V3); PactVerificationResult result = runConsumerTest(pact, config, mockServer -&gt; &#123; ProviderHandler providerHandler = new ProviderHandler(); providerHandler.setBackendURL(mockServer.getUrl()); Information information = providerHandler.getInformation(); assertEquals(information.getName(), &quot;Takamachi Nanoha&quot;); assertEquals(information.getNationality(), null); &#125;); checkResult(result); &#125;&#125; 这两个TestCase的主要区别是： 我们对nationality的期望一个Japan，一个是null； 通过.given()方法来指定我们的ProviderState，从而控制在Provider端运行测试之前修改对应nationality的值； Consumer端运行测试的方式还是一样的： 1./gradlew :example-consumer-nanoha:clean test 然后，就可以在Pacts\\Nanoha路径下面找到生成的契约文件了。 Provider端的契约测试启动Provider的应用上面我们提到，运行Provider需要使用pact的profile，所以现在启动Provider的命令会有所不同： 12export SPRING_PROFILES_ACTIVE=pact./gradlew :example-provider:bootRun 如果你之前已经启动了Provider，记得要kill掉哟，不然会端口占用的啦~ 修改Gradle配置文件我们在Consumer的契约中，使用.given()指定了ProviderState，但说到底，那里指定的只是一个字符串而已，真正干活的，还是Gradle，所以我们需要Gradle的相关配置：build.gralde 123456789hasPactWith(&#x27;Nanoha - With Nantionality&#x27;) &#123; pactSource = file(&quot;$rootDir/Pacts/Nanoha/ConsumerNanohaWithNationality-ExampleProvider.json&quot;)&#125;hasPactWith(&#x27;Nanoha - No Nantionality&#x27;) &#123; stateChangeUrl = new URL(&#x27;http://localhost:8080/pactStateChange&#x27;) pactSource = file(&quot;$rootDir/Pacts/Nanoha/ConsumerNanohaNoNationality-ExampleProvider.json&quot;)&#125; 这里，我们取消了之前对Nanoha的注释。第一个TestCase我们会测试使用默认的nationality=Japan。第二个TestCase，我们指定了stateChangeUrl，它会保证在测试运行之前，先发送一个POST请求给这个URL，然后我们的TestCase测试nationality=null。 执行契约测试同样的方法执行契约测试： 1./gradlew :example-provider:pactVerify 然后你就可以在命令行下面看见对应的输出了。 验证我们的测试如果你一字不漏的玩儿到了这里，那么恭喜你，你应该可以在自己的项目里去实践Pact了（好了，那个抄椅子的同学，你不用说了，我知道，你们用的是Python╮(╯_╰)╭）。 但是在离开本示例之前，还是发扬一下我们的测试精神吧，比如，搞点小破坏~ 在Provider返回的body里面，Miku和Nanoha都有使用字段.name。如果某天，Provider想把.name改成.fullname，估计Miku和Nanoha就要跪了。这是一种经典的契约破坏场景，用来做我们的玩儿法再适合不过了。可是要那么玩儿的话，需要修改Provider的好些代码，想必不少测试的同学，特别是对Spring Boot不了解的同学就又要拍砖了。 所以还是让我们来个简单的吧，比如霸王硬上弓，直接把.name给miku了，哦，不对，是null了。provider.InformationController 1234567@RestControllerpublic class InformationController &#123; ... information.setName(null); return information; &#125;&#125; 喂，喂，干坐着干嘛，动手改呀！这行代码可是需要你们自己加上去的哟，即便它已经简单到只有一行。然后，那个写Python的，别告诉我你看不懂information.setName(null)，Okay？￣▽￣ 最后，重新运行我们的契约测试，你就能看到一些长得像这样的东东啦~： 123456789101112131415161718...Verifying a pact between Nanoha - No Nantionality and ExampleProvider [Using File /Users/ariman/Workspace/Pacting/pact-jvm-example/Pacts/Nanoha/ConsumerNanohaNoNationality-ExampleProvider.json] Given No nationality Query name is Nanoha returns a response which has status code 200 (OK) includes headers &quot;Content-Type&quot; with value &quot;application/json;charset=UTF-8&quot; (OK) has a matching body (FAILED)Failures:0) Verifying a pact between Miku - Base contract and ExampleProvider - Pact JVM example Pact interactionVerifying a pact between Miku - Base contract and ExampleProvider - Pact JVM example Pact interaction Given returns a response which has a matching body $.name -&gt; Expected &#x27;Hatsune Miku&#x27; but received null...","categories":[],"tags":[]}]}