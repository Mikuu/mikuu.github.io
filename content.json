{"meta":{"title":"Ariman's Lazy Blog","subtitle":null,"description":"微服务 自动化测试 契约测试","author":"Ariman","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"图像对比在UI测试中的实践-技术篇","slug":"图像对比在UI测试中的实践-技术篇","date":"2021-05-16T01:05:51.000Z","updated":"2021-05-16T06:36:36.923Z","comments":true,"path":"2021/05/16/图像对比在UI测试中的实践-技术篇/","link":"","permalink":"http://yoursite.com/2021/05/16/%E5%9B%BE%E5%83%8F%E5%AF%B9%E6%AF%94%E5%9C%A8UI%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5-%E6%8A%80%E6%9C%AF%E7%AF%87/","excerpt":"什么是UI测试中的图像对比首先唠叨一下什么是UI测试，顾名思义，UI测试就是泛指对UI的测试工作。UI又分图形化UI和非图形化UI，即Graphic User Interface和Non-Graphic User Interface，常见的GUI主要有Web页面、移动应用界面、桌面应用界面、以及嵌入式设备的图形界面等。而非图形化用户界面则主要是各种命令行终端程序，比如docker，xcrun，kubectl等。我们这里讨论的UI，限定在GUI的范畴内，严谨的同学就别挑刺儿了哟。 对UI的测试，又可以分为功能性的测试和非功能性的测试。功能测试主要关注应用的业务实现，非功能测试则关注业务实现之外的其它方面，比如安全性、性能、易用性、兼容性等。那图像对比在UI测试中扮演怎样的角色呢？","text":"什么是UI测试中的图像对比首先唠叨一下什么是UI测试，顾名思义，UI测试就是泛指对UI的测试工作。UI又分图形化UI和非图形化UI，即Graphic User Interface和Non-Graphic User Interface，常见的GUI主要有Web页面、移动应用界面、桌面应用界面、以及嵌入式设备的图形界面等。而非图形化用户界面则主要是各种命令行终端程序，比如docker，xcrun，kubectl等。我们这里讨论的UI，限定在GUI的范畴内，严谨的同学就别挑刺儿了哟。 对UI的测试，又可以分为功能性的测试和非功能性的测试。功能测试主要关注应用的业务实现，非功能测试则关注业务实现之外的其它方面，比如安全性、性能、易用性、兼容性等。那图像对比在UI测试中扮演怎样的角色呢？ 我们先来看看下面这个，白宫官网的页脚: 然后，同样是白宫官网的页脚： 你能一眼看出它们的区别吗？比较困难是吧，那如果再给你提供下面这个呢： 是不是瞬间就能发现它们之间的差异了。然后我们来仔细品味一下它俩的差异，最上面白宫图标的粗细变化，我们可以认为是截图噪音而忽略不计，那么左下角的单词错误，应该是文本的错别字，不涉及功能，属于用户体验的问题。而右下角缺失YouTube图标，则是实打实的功能缺陷。所以，图像对比在UI测试中并不是某种具体的专项测试，而是一种辅助手段，帮助我们方便快捷地定位各种可以被其捕获的、泛化的UI异常。 当然，称呼“UI测试中的图像对比”实在太拗口，所以平常交流中，更多的是使用它的英文及其译名，即Visual Testing和”视觉测试”。 图像对比在UI测试中的价值在UI测试、特别是UI自动化测试中应用图像对比能够带来非常直观的价值，它们包括： 替代自动化测试中的断言语句，提高自动化测试的维护效率和测试执行的稳定性； 实现对图表等绘图元素的回归测试； 能够捕获意料之外的UI异常； 更加适应敏捷项目中UI的频繁变更； 更好的描述UI的变化； 替代自动化测试中的断言语句，提高自动化测试的维护效率和测试执行的稳定性长久以来，UI自动化测试中的测试期望都是通过断言语句来实现的，比如 1cy.get(&#x27;div.main-content-article-wrapper &gt; article &gt; div &gt; div:nth-child(34)&#x27;).should(&#x27;contain&#x27;, &#x27;Price&#x27;) 期望一个特定位置的元素内容应该包含’Price’，但如果页面重构，变成了 1cy.get(&#x27;div.main-content-article-wrapper &gt; article &gt; div:nth-child(34)&#x27;).should(&#x27;contain&#x27;, &#x27;Price&#x27;) 那我们的自动化测试就会失败。相信凡是写过UI自动化测试的同学，都遇到过类似的问题，即我们对特定元素的断言，都依赖其相应的元素定位器，如果UI界面发生了结构性的调整（这些调整有时对用户还是无感的），已有的元素定位器很容易受影响。特别是当需要断言的页面元素很多时，这样的重构往往是UI自动化测试的噩梦。 而图像对比完全不需要使用断言语句来校验页面元素的特征，从而可以大幅简化使用断言语句的工作量，并且极大的提高执行自动化测试的稳定性，特别是对于那些内容丰富的页面，无论是校验的工作量、还是校验的稳定性，都远远优于传统的断言语句。 实现对图表等绘图元素的回归测试另一个“长久以来”，对绘图元素的回归校验始终是UI自动化测试中的痛点。前端获取后端提供的数据，使用Javascript和CSS动态地将其绘制在UI界面上，面对这些圈圈点点、条条框框，传统的UI自动化测试，无论是爷爷辈儿的Selenium、还是高富帅的Cypress，都只能望图心叹，而唯独图像对比可以“以图攻图”。这对于那些需要展示图形报表的应用，比如大数据前端，是非常有益的。 能够捕获意料之外的UI异常这是我对图像对比在UI自动化测试中最赞赏的价值！传统的、基于断言的UI自动化测试，只能做到“期望A在B有C的表现”，即只能期望某事按照希望的方式发生，可捕获的异常仅仅是“期望的事件没有发生”。而在此基础上，使用图像对比的UI自动化测试还能期望“不希望的事情不要发生”，即对于那些无中生有、完全意料之外的UI异常也能进行捕获。 曾经的一个客户项目，项目的产品是一个微前端，上线后会被嵌入到上一层的页面当中。某次，我们的图像对比测试在UAT测试环境中意外的发现，自己页面的某个widget居然被替换成了广告，整个团队大吃一惊，因为我们根本就没干过“这活儿”。经过几番技术调研和需求确认，最终才知道这是我们被要求引入的某个上层页面的Javascript“偷偷修改”的，而且是正确的业务需求。当时的那个广告很显眼，容易被人肉捕捉到，但如果是某个不起眼的小改动呢，常规的自动化测试方式都束手无策，即便是单元级别的snapshot测试也做不到，因为它是在部署后才会出现的”问题”。 更加适应敏捷项目中UI的频繁变更对于UI自动化测试，有一条金句：“只在UI稳定后再进行自动化回归测试”。而对于敏捷项目来说，不好意思，UI稳定的那一天多半就是上线的那一天。UI的频繁变更，对于自动化测试来说，主要考验的是咋们的体力和（忍）耐力，看你有没有足够的体力、三天两头的跟着UI变更来修改你的测试案例，以及面对一言不合就红红火火的pipeline、你能憋着多久不拍桌骂娘。而使用图像对比的UI自动化测试，虽然不能完全解除你发飙的风险，但得益于对断言需求的大量降低、以及图像对比服务的一键rebase，至少能让你每天少灭亡5000单位的脑细胞（大误），阿弥陀佛，善哉善哉！ 更好的描述UI的变化这一点，我坦白，很主观。当UI出现变化、需要跟Dev或BA去确认时，相较于查看日志或报告中的描述语言，我更喜欢眼见为实和看图说话。当然，随着自动失败截图和视频录制功能的丰富，像Cypress、Detox这样的测试工具，在这方面也做得很不错。 值得强调的是，尽管再高效和准确，图像对比也只是UI测试中的一种辅助手段，单独依靠图像对比是无法独立完成整个UI自动化测试的，我们仍然需要Selenium、Cypress那样的测试工具和框架来对浏览器和页面进行基本的操作，比如打开一个网站、填写某个表单、点击一些按钮等等。所以，图像对比是高效UI自动化测试的助推器，但并不是全部。 图像对比在UI测试中的自动化实施模式图像对比是一种高效的测试手段，理念非常清晰、简单。在具体的UI自动化测试中，图像对比的实施基本都遵循相同的模式，如下图： 其中： 初始化baseline的步骤一定是手动的，而且也是必须的； 图像对比和差异报告是自动完成的； 差异判定目前基本都是手动完成的，自动化能做的仅仅是发现差异，但差异并不等于缺陷，对于设计变更、新的需求、以及既有缺陷修复带来的UI差异，都是业务的正确表现； 显而易见，更新baseline的步骤也一定是手动的，当报告的差异属于正确的业务表现时，就应该将当前版本的UI截图设置为最新的baseline，否则后续测试会继续沿用之前的baseline； 当前的自动化图像对比方案如今的视觉测试工具已经非常多了，这里罗列了目前市面上绝大多数的相关工具。他们的主要区别在于： 获取途径，开源 vs 商业； 实现方案，工具&amp;框架型 vs 服务型； 测试流程，交互式 vs 批处理式； 商业和开源的区别不必多说。开源软件绝大多数都是本地工具或框架型的实现方案，服务型的实现方案主要集中在各种商业服务中，比如领头羊的Applitools就是远程服务型解决方案，非常类似于BroswerStack。 无论是工具型的实现方案（以下简称视觉测试工具）、还是服务型的实现方案（以下简称视觉测试服务），它们都遵循上面提到的自动化实施模式，UI操作和截图都发生在执行功能测试的本地环境。两者的关键区别在于图片的对比和Baseline的管理，一个是发生在本地环境，一个是发生在远端服务内。具体来讲，当测试获取到UI的截图后，视觉测试工具会将截图与本地的Baseline进行比较，得出差异报告，需要更新的Baseline也保存在本地环境。而使用视觉测试服务时，截图会被上传到远端的视觉测试服务，在服务端完成图片对比，当需要更新Baseline时，也是在服务端保存新的Baseline。 本地视觉测试工具 vs 远端视觉测试服务大量的实践告诉我们，UI测试中使用远端视觉测试服务要远远优于使用本地视觉测试工具，主要体现在： Baseline的管理和共享视觉测试工具将Baseline保存在本地环境，如果是一直个人使用，并没有多大问题，但如果要多人共享，麻烦就来了。以网页应用为例，图像都是来自于浏览器对应用界面渲染的结果，如果两个人的操作系统、浏览器版本、显示器分辨率等不同，即便面对相同UI，也可能得出不一致的图像。A、B分别在各自的电脑上、使用各自的Baseline通过了视觉测试，但最终发现两人的Baseline其实并不相同。当然，这里的差异更多属于噪音，但对于像素级别的图像对比来说，这样的噪音是难以忽略的。 所以，对于本地视觉测试工具来说，一种变通的使用方式就是将Baseline保存在代码的版本管理系统内，然后让组员共享相同的Baseline。该方式可行，但使用代码管理系统来存储二进制的图片文件、而且还是经常变动的图片文件，其本身并不是一种好的工程实践。 而视觉测试服务则完全不存在这样的问题，因为Baseline都是保存在服务端的，共享使用完全没有任何问题。 更新Baseline的难易程度图像对比替代语句断言的优势之一就是能更好的适应被测UI的频繁变更，这就要求图像对比能够更好的频繁更新Baseline。视觉测试工具一般使用单独的命令来更新Baseline，集成到持续集成环境后，则通常需要设定一个单独的Job来执行该命令。如果使用了版本管理系统来存储Baseline，那还得将本地的Baseline上传回版本管理系统才能完成整个操作。 而视觉测试服务则相对要简单得多，往往只需要点击服务页面上的一个按钮就全搞定了。 历史版本的可追溯性本地视觉测试工具通常都有一个硬伤，它们只会保存当前的Baseline，当需要更新Baseline时，会用新的Baseline覆盖掉之前的Baseline，整个环境中永远只会有最新的Baseline。然而对于Baseline来说，除了使用当前的Baseline来对比最新截图之外，有时候我们还希望能够浏览历史的Baseline，因为Baseline的历史版本，其本身就是对被测应用的迭代描述，甚至是各个里程碑的图像记录，是有其工程意义的。 显然，本地视觉测试工具无法提供这样的可追溯性，而视觉测试服务通常都会保留全部的图片历史，所以能够更好的满足这一特性。 基准版本的回滚举个例子，Dev提交部署了版本v005，告诉QA这是新的实现，QA在测试“确认”后，将图像对比的Baseline更新为v005版本，稍后，BA提出v005版本的“需求”是错误的，此时，Dev需要把代码回滚到v004版本，那问题来了，如果是本地的视觉测试工具，v004版本的Baseline已经被v005版本给替换了，缺少v004版本的Baseline，QA只能人肉确保版本回滚的正确性了。 所以，具备基准版本的回滚功能，可以在必要的时候，更好的实现视觉测试，而只有视觉测试服务才具备回滚基准版本的能力。 当然，视觉测试服务也不是无懈可击的。相较于本地的视觉测试工具，使用视觉测试服务的高成本是显而易见的，第三方商业服务的费用是实实在在的Money，即便使用开源的视觉测试服务，在服务部署上，对团队也多多少少有一些DevOps的技能要求。如果为了更好的使用效果，将开源视觉测试服务部署到云端，也会产生相应的计算资源费用。 交互式的图像对比 vs 批处理式的图像对比无论是本地的视觉测试工具，还是远端的视觉测试服务，在测试流程上，一般都可以分为交互式和批处理式两种。 交互式的测试流程一般如下图所示。在该流程中，图像对比的工作的全部嵌入到功能测试的步骤当中，每一步视觉测试都会将被测图像传递给图像对比的工具或服务，然后等待工具或服务返回图像对比的结果，就类似平常使用的断言语句。 批处理式的测试流程一般如下图所示。该流程的特点是视觉测试的步骤和功能测试的步骤完全分离，功能测试仅仅需要将图像保存到指定的路径下，待整个功能测试都结束后，再将所有的图像、一次性全部传递给视觉测试工具或服务进行对比。 交互式视觉测试和批处理式视觉测试在流程上的不同，造成了两者在呈现测试结果上的差异。对于交互式视觉测试，每一步测试都会即时获取到对比结果，从而使视觉测试的结果直接体现在功能测试的结得当中。而批处理式视觉测试，其步骤和功能测试完全隔离，测试结果由视觉测试工具或服务单独呈现。 至于视觉测试结果要不要和功能测试结果绑定在一起，并没有什么公理可依，大家尽可按照自己的实际需求进行取舍。只不过就个人而言，我更倾向于将二者分离，因为严格来讲，视觉测试给出的自动化结果，其本身仅仅是图像对比的结果，而图像对比结果并不等于测试结果。我们说过，图像对比只是UI测试的一种辅助手段，帮助我们从UI差异中去快速发现问题，图像对比仅仅揭示差异，而差异并不等于缺陷。所以，自动化视觉测试给出的结果不应该被直接用来表征UI测试的结果，否则它会大大的降低功能测试结果的可信度，失去可信度的测试是没有有价值的。 关于Micoo的一点啰嗦基于以上的考虑，Micoo选择了服务型的实现方式和批处理式的测试流程。Micoo的理念是聚焦最核心的图像对比工作，仅此。所以从功能上来说，Micoo仅仅是一个图像对比服务，它将操作UI应用和截取图片的工作，全权留给了功能测试去完成。这样貌似偷了个大懒，但实则拓宽了实施视觉测试的对象。理论上，任何UI应用，无论是Web应用、移动应用、桌面应用，只要它能被自动化测试并且截图，就能借由Micoo完成视觉测试。而将来，无论这些被测应用如何更新演进，只要其相应的自动化功能测试手段能同步跟进，Micoo就永远能为它们提供视觉测试的解决方案，这样就从根本上避开了当年BackstopJS在PhantomJS身上踩下的天坑（如果对这段内容感到很突兀，可以参阅之前的故事篇获取一些上下文）。 视觉测试在CI中的实施方式目前，基于视觉测试与功能测试的相互关系，它们在CI中的构建方式主要有四种，分别为：独立型、混合型、同步型、以及异步型的构建方式。 独立型的CI构建方式下图是独立型的自动化测试在CI中的构建方式，其特征是功能测试和视觉测试完全独立，互不依赖也互不影响。BackstopJS这类的工具就通常使用独立型的方式构建到CI当中。 混合型的CI构建方式然后是混合型的构建方式，其特点是视觉测试的步骤完全跟功能测试绑定在一起，即使用一套自动化测试实现功能和视觉的双重校验。不用多想，这就是标准的交互式视觉测试方案在CI中的构建方式，比如Applitools。 同步型的CI构建方式同步型的构建方式中，视觉测试依赖前置功能测试的产出，即先由功能测试获取到UI截图，再将截图交给视觉测试进行图像对比。其后续步骤，比如部署UAT环境，需要视觉测试通过才能进行。 异步型的CI构建方式异步型的构建方式与同步型的构建方式有相似之处，其视觉测试都要依赖功能测试的截图，不同的是，其后续步骤，比如部署UAT环境，可以不依赖视觉测试的结果，只要功能测试通过就可以自动部署。 实践中，不同CI构建方式的选择没有太明显的倾向性，主要还是根据所使用的视觉测试方案来制定，比如，独立的视觉测试工具多选择独立型的构建方式，交互式的视觉测试方案肯定是混合型的构建方式，而批处理式的视觉测试方案则可以在同步型和异步型构建方式中灵活选择。 视觉测试的有益实践最后，作为对大家耐心阅读至此的感谢，特此奉上一些实施视觉测试时的有益实践，纯干货： 什么样的项目适合引入视觉测试？视觉测试的实质是UI的一种自动化回归测试。在考虑是否引入视觉测试之前，先要确定是否需要建立UI的自动化回归测试。视觉测试对UI回归测试的帮助，概括起来就四个字：减负增效。通过大大降低测试断言的使用来减小自动化测试的编写和维护负担，同时提高测试的效能和稳定性。由此可见，真正适合引入视觉测试的项目，一般来说都是那些UI内容复杂、同时迭代变更又比较频繁的项目。此外，那些对UI呈现效果要求较高的项目，比如客户全是像素眼的PO，那么视觉测试也是不错的辅助手段。 什么样的项目不适合使用视觉测试？要明确的是，只要能被自动化测试的UI，技术上都能进行视觉测试，但视觉测试是否对任何UI项目都适用，却是不一定的： 如果项目连UI自动化测试都不需要，那自然就更谈不上视觉测试了； 过于简单的UI，有基本的自动化功能测试就足够了，没必要再加上视觉测试，毕竟视觉测试也是有”成本”的； 过于复杂的UI，注意，这里的复杂不是指UI内容的复杂，而是指UI操作的复杂。比如，一个需要进行满篇填写内容来提交表单的UI，在其功能测试的步骤中，就几乎已经遍历完了所有的界面元素，再对它进行视觉测试，并不能降低多少元素定位的成本。那么对这样的UI引入视觉测试，收益是不大的； 可以使用图像对比测试视频播放器，但视觉测试一个主要内嵌视频播放器的网页或移动端UI，一般来说不是一个好想法； 想玩儿服务型的视觉测试，但没有资源怎么办？“没有就要呗，不然还能咋地？” 当然，这是半句玩笑话。这里真正想说的是，长久以来，在项目的计算资源分配上，测试一直是二等公民。当我们计算启动项目需要使用的资源费用时，比如购买哪些云服务、需要多少计算实例、需要怎样的数据库或缓存等，通常只会考虑开发的需求，而不会也不需要顾及测试的需求。历史上，这是正确的，随便找一个CI的Agent，就能把我们常用的测试框架给打发了。然而，伴随着容器技术助推传统测试工具、框架向测试服务的转型，计算资源也开始成为自动化测试策略中需要规划的要素。这一点，对早就完成测试平台化、测试服务化的大厂来说，不是问题，但对玩儿敏捷的TW团队来说，却还是一个新的思考。所以，言归正传，想在项目中使用视觉测试服务，那么就尽量在项目早期阶段，将此需求体现到测试策略当中，呈现给团队和客户，从而提前准备和规划。 视觉测试中如何解决UI对象动态变化的问题？来了来了，这个凡是做视觉测试就一定绕不过去的问题： 页面中有视频，怎么办？ 图片slideshow会自动滚动，怎么办？ 显示的时间每秒钟都不一样，怎么办？ 那个ID每次请求都不一样，怎么办？ 这些UI中动态变化的元素，对实施图像对比是非常大的阻碍。当然，解决办法也是有的，比如： 掉包，UI显示的数据大多来自后端（或远端），有些数据是不恒定的，比如一些每次请求后端都会变化的信息，如动态ID、数字签名、特征码等等，又或者一些自己团队不可控的信息，比如一个显示价格的UI，自己团队只负责在UI中将价格显示出来，具体的数字则受后端或后台的控制而可变。对于这样的场景，我们可以使用服务虚拟化的技术来替换掉相应的后端，从而使用恒定不变的数据来保障视觉测试的可行。 作弊，使用虚拟服务来掉包测试数据的成本是很高的，另外，有些前端显示的内容并不是从后端获取的，而是前端自己生成的随机数据，那么对于这些无论是来自后端还是前端的动态数据，另一种”廉价”的处理方式，就是在功能测试中将它们直接修改成固定的假数据。比如，在Web的测试中，如果需要进行视觉测试的当前页面包含有动态数据，我们可以使用Javascript直接修改DOM的内容，将某个本应该是动态计算或获取的值替换成固定的内容，然后再对当前页面截图对比。 抹黑，至于那些频繁变化的视频或者图片，我们甚至可以来得更狠，直接修改DOM将其修改成相同大小的色块，从而保障视觉测试的可行。除了抹黑，还有抠图的操作，即直接删除视频或者图片的DOM节点，但一般不建议，因为大多数情况下，删除DOM节点可能会影响到页面的布局展示。 后门，有时为了实现视觉测试，但又不想修改DOM结构，就可以让Dev在测试环境中设置一些功能或者特效开关，比如，当开关关闭时，图片slideshow只显示第一张图片而不自动切换其它图片，从而使视觉测试成为可能。一旦使用的功能开关，就增加了UI的实现复杂度，测试也需要相应的关注这些功能开关不会影响到产品环境的表现。 罢工，如果上面这些都解决不了动态数据的问题，又或者能解决但成本太高，那么就应该考虑放弃进行视觉测试。合理适当的手动测试有时才是性价比最高的解决方案。 尽管我们有这些解决动态元素问题的方法，但显而易见的是，它们要么成本高昂，要么对被测DOM修修改改，带来收益的同时也引入了风险。所以对页面动态元素的评估，也是在策略上是否引入视觉测试的重要参考。 如何解决视觉测试中截图环境不一致的问题？初次接触视觉测试的同学，通常关注的是截谁的图、怎么截图，而只有在视觉测试中栽过跟头的人，才会更关注在哪儿去截图。比如，对Web应用来说，哪怕使用相同版本的Chrome和Puppeteer，在MacOS和Windows上截的图，可能是有差异的。更别说，在你的MacBook上截取的图像，和CI的Agent机器上截取的图像，差异可能更大。那么该如何避免这种差异呢？目前来说，最合适的方法，是在容器中进行截图。比如，将你需要的Chrome或者Chromium版本，打到特定的容器里，而后无论在本地环境还是CI环境，都将自动化测试运行在这个相同的容器内部，那么你得到的截图就一定是相同的。 当然，如果你使用Applitools服务，那么也不会存在截图环境不一致的问题，因为Applitools是将DOM片段上传到服务器上，在服务端使用指定的浏览器进行渲染和截图。 如何设定差异阈值最合适？不使用差异阈值最合适！使用差异阈值的目的，通常都是在一定程度内容忍对比差异，比如设置3%的差异阈值，就可以使视觉测试在自动报告对比结果时，对于图片差异区域低于整张图像的3%的测试，视为对比结果一致而通过测试。差异阈值主要用在一些容易产生截图噪音、或者对比经常出现一些小范围且无意义的差异的测试中，用来提高测试的鲁棒性。从测试方案设计的角度来说，差异阈值是很不错的想法，但真正的项目实践中，却并不是那么回事。原因很简单，差异阈值提高测试鲁棒性的代价是牺牲图像对比的敏感性。基于像素对比的视觉测试，高敏感性是其最大的优势，同时也是建立其测试结果可信度的根基。使用了差异阈值的视觉测试，其对比结果就从完全可信变成了部分可信，哪怕其可信阈达到99.99%，只要不是100%的完全可信，其测试结果就会受到质疑，任何存在可质疑结果的自动化测试都是无益的。具体来说，设置1%的差异阈值，测试就会自动容忍1%的图像差异，然而，没人能确保这1%的差异永远都发生在那些期望的、无关紧要的边角料区域，如果下一次这1%的差异正好就发生在一些关键的地方，比如价格的单位符号，那么测试遗漏的结果就可能很严重。另外，差异阈值是绝对的，但差异区域却是相对的。请问，3%的差异和1%的差异谁大？答案是不确定，比如，200x400图像的3%的差异，和1920x1080图像的1%的差异，后者的差异明显比前者要大得多。所以，请一定慎用差异阈值。 视觉测试挂得太频繁，怎么办？恭喜你，咋要的就是这效果！图像对比作为UI回归测试的一种辅助手段，当它频繁”挂掉”的时候，说明UI正在经历快速的变更，这其实并不是什么坏事。传统的功能性自动化测试，面对UI的快速变更，测试断言会频繁失效，给自动化测试的维护工作带来极大的工作量，搞得我们心烦意乱，这时往往需要评估继续进行自动化测试的ROI。而图像对比测试在更新baseline上的优势，极大的减少甚至部分消除了这些维护工作，让我们可以泰然面对频繁的测试失败。所以，不同的测试方式带来不同的测试体验，同时也改变着我们面对测试失败的心态。 最后最后想说的是，UI测试中的图像对比并不是什么技术含量很高的工作，但它却一定是效能很高的手段，把简单的事情做到精致、做到极致，也能得到非同寻常的收获。","categories":[],"tags":[]},{"title":"图像对比在UI测试中的实践-故事篇","slug":"图像对比在UI测试中的实践-故事篇","date":"2021-05-16T00:14:30.000Z","updated":"2021-05-16T06:36:36.946Z","comments":true,"path":"2021/05/16/图像对比在UI测试中的实践-故事篇/","link":"","permalink":"http://yoursite.com/2021/05/16/%E5%9B%BE%E5%83%8F%E5%AF%B9%E6%AF%94%E5%9C%A8UI%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5-%E6%95%85%E4%BA%8B%E7%AF%87/","excerpt":"这是一份在UI自动化测试中使用图像对比的实践分享，分为故事篇和技术篇两部分，故事篇会首先回顾这几年在视觉测试上的历程，技术篇则会介绍一些视觉测试上的技术总结。 六年前刚入职到ThoughtWorks成都办公室后，第一次参加QA社区的Catch Up，那时的我在新环境中还分不清谁是张三谁是李四。 会上，依稀记得有两位貌似道行深厚的人物，就某个工具的使用反馈，询问在座的众生，现场一片寂静。会后，回到组上，我好奇的 问了一下我们的TL（请允许这里隐去TA的名字，不然我多半会被怼的）那是什么东西、我们有没有使用，面对TL一番风卷残云的 介绍，作为刚刚从通讯行业跨入互联网行业才三天的菜鸟，小的我真的是屁都没听懂，唯一听明白并且记下来的就是“它还需要部署服务器，很难用”。 那个工具的名字叫做Viff，在后来很长的一段时间内，我仍然不知道它是干嘛的，而这，就是我第一次和UI测试中的图像对比的擦肩而过。","text":"这是一份在UI自动化测试中使用图像对比的实践分享，分为故事篇和技术篇两部分，故事篇会首先回顾这几年在视觉测试上的历程，技术篇则会介绍一些视觉测试上的技术总结。 六年前刚入职到ThoughtWorks成都办公室后，第一次参加QA社区的Catch Up，那时的我在新环境中还分不清谁是张三谁是李四。 会上，依稀记得有两位貌似道行深厚的人物，就某个工具的使用反馈，询问在座的众生，现场一片寂静。会后，回到组上，我好奇的 问了一下我们的TL（请允许这里隐去TA的名字，不然我多半会被怼的）那是什么东西、我们有没有使用，面对TL一番风卷残云的 介绍，作为刚刚从通讯行业跨入互联网行业才三天的菜鸟，小的我真的是屁都没听懂，唯一听明白并且记下来的就是“它还需要部署服务器，很难用”。 那个工具的名字叫做Viff，在后来很长的一段时间内，我仍然不知道它是干嘛的，而这，就是我第一次和UI测试中的图像对比的擦肩而过。 一不小心，摸到了图像对比的大门有时候，接触某种技术、思考某种解决方案，靠的真不是大咖的演讲，而就是那么点儿缘分和灵光一现。 时间来到2016年10月，某澳洲项目S。有一次，从王小礼的桌旁溜过，看她一副愁眉苦脸、生无可恋的样子，就猜到多半有”戏”。本着有“戏”大家乐的心态，随便打听了一下。 原来，她们组最近在给客户做产品换肤。了解S项目的同学应该都知道，客户是一个集团企业，旗下有八九个品牌，所以通常一个产品就会有八九套UI。 而她们组在做的，就是给其中的多个品牌同时换肤。面对每天都在变化的UI，有时甚至是往复修改的CSS，别说写自动化测试了，每张卡的人肉检查早都已经应接不暇了。 当时的闲聊中，我提到的建议是，不知道有没有什么工具能帮着检查这类UI快速变更的页面。下来再琢磨这个问题，经过一番折腾，最终发现原来有种手段叫做“Visual Regression Testing”。 至于后来王小礼是怎么熬出她们的品牌换肤的，我就不知道咯，阿弥陀佛~ 出师未捷身先死既然摸到了图像对比的大门，不进去捣腾捣腾，就说不过去了是吧！当时，开源社区中的当家花旦是BackstopJS，使用配置文件的方式来编写和管理测试案例，完全没有多大的上手难度，输出的报告对于从来没接触过视觉测试的人来说，还是让人眼前一亮。 当时，我们组的工作也是维护一个S项目下的某个前端应用，所以在项目上通过BackstopJS来实践视觉测试，便成了非常正儿八经的选项。然而、可是、没想到，仅仅用BackstopJS遍历了两三个页面，测试就…崩了!是的，你没看错，崩了！经过几番调查，问题很快确定了：BackstopJS基于配置文件来组织测试案例，执行测试时为了能够做到Headless，使用的驱动是PhantomJS（是的，就是那个作者半途跑路的PhantomJS），而PhantomJS原生不支持ES6。所以，解决办法就是……没有办法！什么，你说BackstopJS支持Puppeteer？Puppeteer发布v1版本是在2018年的一月，至于BackstopJS完成使用Puppeteer替换PhantomJS，那更是猴年马月的事情咯~ 找准目标，二次开发刚刚开门就撞上了叹息之墙，有够背的，可即便没能取得开门红，图像对比在UI测试中的巨大潜力，仍旧让我深信这是一滩值得去趟的“浑水”。 换个工具继续尝试，接下来盯上的就是Dpxdt（我用办公室阿姨擦桌子的抹布打赌，你第一次绝对不知道这玩意儿怎么念）。选择Dpxdt是有一番考量的，包括： 作者是Google的工程师，貌似很靠谱； 源码是Python，逼不得已了还能自己抢救抢救； 支持以服务化的方式来进行测试； 其中，服务化的测试方式是选择Dpxdt的重中之重！之前虽然在BackstopJS身上出师不利，但却发现了对视觉测试来说非常重要的关键点：视觉测试的最大价值在于图像对比，其它诸如浏览器驱动、页面操作、截图等工作，都不是也不应该是视觉测试的核心内容，它们应该由其它更擅长、更专注于此类活动的技术组件来负责，即术业有专攻，从自动化实施的层面考虑，尽量做到技术组件的功能内聚，这样，无论将来前端技术如何演进，也只需要更新相应的驱动组件即可，而图像对比作为视觉测试的核心，则不会受到影响。 想法很丰满，现实却很骨感。原生的Dpxdt，在实现上与BackstopJS有相似之处，比如，同样使用配置文件来管理测试案例，同样使用PhantomJS来驱动浏览器，但在架构上，Dpxdt实现了测试端和服务端的分离。在测试端，使用PhantomJS驱动浏览器进行页面操作和截图，然后将截取的图片上传到服务端，服务端使用ImageMagic进行图像对比，最后以一个Web应用的方式来管理和展示图像对比的结果。 很明显，直接使用Dpxdt是不可行的，因为绕不过PhantomJS的死结，但Dpxdt两端分离的架构设计，给移花接木带来了可能。为了在项目上进行视觉测试，只能对Dpxdt进行二次开发，包括： 封装Dpxdt暴露的API接口，重新构建可独立使用的客户端库； 解决一些Dpxdt在Windows环境下的兼容性问题，因为UI测试运行在Windows的EC2上； 加入了Ghost功能； 重建了部分服务的UI界面，原版的实在有些丑； Dpxdt在使用ImageMagic对比不同尺寸的图片时容易出错，使用compose进行了相应的预处理操作； 经过以上的修改，2017年5月，定制版的Dpxdt基本具备了相对稳定的图像对比功能。其带来的收益也是杠杠的，像素对比带来极高的测试敏感度，不会漏掉UI的任何异常，同时，去掉了UI测试中的几乎所有断言语句，大大的提高了测试的稳定性，这在那个Selenium的年代，是非常有价值的。 费劲心思修改出来的Dpxdt，肯定不会仅仅服务于一个项目。通过将Dpxdt部署到独立的EC2上（不得不说当年的客户真的是金主爸爸，EC2基本就是随意开)，这个视觉测试服务在TW和该客户合作的最后两年里，先后服务过6个项目产品，完成了超过5000次的图像对比，给合作的客户团队也留下了非常深的印象。 自力更生“如果让我再选择一次，我绝不会再用Dpxdt”，这是后来TW结束S项目后，正荷在一次QA社区的Catch Up上分享我们的视觉测试实践时，留下的让我记忆最深的话。原因很简单，除了我们当时整套自动化测试架构过于复杂之外，最让人难以忍受的就是Dpxdt的慢！贼慢！比贼还慢！其主要原因有二，一是Dpxdt将图片保存进了sqlite数据库文件，使得历史数据多了之后，数据库读写会非常慢。二是ImageMagic进行图片对比的速度实在是太慢了。久而久之，使用Dpxdt服务浏览图片和进行差异判定，就成了一件非常痛苦的事情。 在Dpxdt服务上近两年的视觉测试实践，让我更加确幸了一件事情：服务型的视觉测试方案，才是UI测试中图像对比的王道，原因我会在之后的技术篇中细聊。 时间来到2020年初，得知春节后将会入场的一个新加坡项目对Web UI有很高的要求（高到啥程度？后来的一次Sign Off，PO说：“你把F12打开，让我看看”，然后，“看吧，这个margin和设计差了2个px吧” ……想知道当时QA和BA的心情吗？），视觉测试自然就被我提上了日程。然而，Dpxdt毕竟已经是六七年前的作品，方案实现落后太多，继续改造已无益处。放眼此时的开源市场，提供图像对比的UI测试工具已经比比皆是了，光Cypress的插件就有一大堆。可是，服务型的解决方案却只有商业软件，比如大名鼎鼎的Applitools，可开源解决方案，一个都没有，这，就有些玩儿不动了。 人不折腾，天诛地灭，没有现成的，就自己撸一个呗！天意弄人，赶上新冠疫情，10天的闭门春节假期，还真就让我码了一个出来，取了个很俗气的名字叫Team Visual Test，简称TVT（是不是很囧）。TVT在考虑之初，就奔着跨团队和开源共享去做的，所以使用的都是非工作时间进行的开发和维护。 为了最大程度的提高视觉测试的速度，TVT在具体的图像对比技术上，选择了native-image-diff，虽然这是一个名不见经传的NodeJS图像对比工具，但它的实测速度是非常理想的，通过比较，native-image-diff的图像对比速度要比ImageMagick和OpenCV快得多。比如，下图是之前做的native-image-diff和ImageMagick在对比不通尺寸图片时的速度表现，native-image-diff的对比速度几乎是ImageMagick的三倍。 除了对图像对比技术的甄选，TVT还在项目上因地制宜的实现了一个图片文件共享的方案。我们使用容器化的方式来执行功能测试，然后将功能测试的容器和TVT服务的容器运行在相同的ECS Fargate实例的Task上，这样功能测试和TVT服务就能通过Bing Mounts的方式共享文件存储，从而实现了功能测试获取的截图，可以被TVT服务直接使用，从而避免了文件上传带来的耗时，使得整个视觉测试方案的速度可以更快。这样的实施方案，既有它的特性，比如项目上本来就使用Fargate实例，也有它的共性，比如即便不使用Fargate，随便一个Docker Swarm的环境，都能使用共享存储的方式实现类似的效果。 另外，不同于Dpxdt的单体服务，TVT在架构上是一个简单的微服务系统，将负责图片对比的图像对比服务和负责测试结果呈现的主服务分离开来。这样，如果将来有更强大的图片对比技术，只需要单独更新图像对比服务，就可以对TVT进行升级。 后来，在那个新加坡项目上，配上与Telegram的消息集成，TVT取得了非常好的效果。 然而，TVT毕竟只是一个春节假期赶工出来的成果，在服务部署、易用性、安全性、以及多客户端支持上都有不少欠缺。下项目后，又陆陆续续的花了一些时间来对TVT进行修修补补，于是打磨出了如今的开源视觉测试服务Micoo。关于Micoo，这里就不多言了，在稍后的技术篇中也许会提到部分内容，更多的细节，感兴趣的同学可以查看: Github主页 文档 写在最后目前，在SEA，在没有任何推广的情况下，已经和正在使用Micoo（包括其前身TVT）的客户项目已有4个。所以，故事讲到这里，故事也还在发生。","categories":[],"tags":[]},{"title":"微服务环境下的测试策略与落地实践","slug":"微服务环境下的测试策略与落地实践","date":"2019-07-02T09:04:27.000Z","updated":"2021-05-16T06:36:37.033Z","comments":true,"path":"2019/07/02/微服务环境下的测试策略与落地实践/","link":"","permalink":"http://yoursite.com/2019/07/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5%E4%B8%8E%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/","excerpt":"这篇文章原本是当年（具体当的哪一年，忘了…T_T)抱着学习的心态，翻译的Toby Clemson的文章《Testing Strategies in a Microservice Architecture》，后来又加入了一些自己在项目上的实践总结。最近在清理磁盘文件的时候，偶然又给刨了出来，索性就搬到博客里来吧~ 如果你在Google上面搜索”microservice test strategy”，你一定会找到下面这个结果：伴随着Martin Flower的大名赫然在目，但是，这篇文章的作者，不是老马，而是Toby Clemson。之所以提这个，是因为已经多次听到有小伙伴在述及这篇文章时，张口就是”Martin Fowler的那篇微服务测试策略的文章……”，所以，尊重作者，还是从记住他们的名字开始吧~","text":"这篇文章原本是当年（具体当的哪一年，忘了…T_T)抱着学习的心态，翻译的Toby Clemson的文章《Testing Strategies in a Microservice Architecture》，后来又加入了一些自己在项目上的实践总结。最近在清理磁盘文件的时候，偶然又给刨了出来，索性就搬到博客里来吧~ 如果你在Google上面搜索”microservice test strategy”，你一定会找到下面这个结果：伴随着Martin Flower的大名赫然在目，但是，这篇文章的作者，不是老马，而是Toby Clemson。之所以提这个，是因为已经多次听到有小伙伴在述及这篇文章时，张口就是”Martin Fowler的那篇微服务测试策略的文章……”，所以，尊重作者，还是从记住他们的名字开始吧~ 微服务作为一种新的系统架构设计风格，开始被越来越多的团队接受和应用，它在给团队带来新的开发体验的同时，也给产品的质量保证提出了新的议题，如何测试我们使用微服务构建的应用？有哪些问题是在我们测试微服务的过程中需要考虑的？等等这样的问题也开始随着微服务的普及，而成为越来越多质量保证工程师需要面临的问题。于是，我们总结并提出了一些在实际的微服务项目中有益的实践方式，它们中有的是在任何产品质量保证过程中都会涉及的内容，比如单元测试和集成测试，而有的则在微服务架构中才会突显作用的内容，比如契约测试。但无论是哪种类型的测试，我们都希望通过对微服务针对性的应用，来为我们的微服务系统应用提供最可靠的质量保证体系。 单元测试单元测试是对一个可测试应用的最小单元进行测试的活动。那么多小的可测单元才是最小的可测单元呢？这个问题没有统一的答案，一个函数、一个类、一个库等等都可能被选择作为一个最小的可测单元来进行单元测试。从软件开发的角度来看，这取决于软件的架构设计，如果我们在软件设计的时候就赋予了一个类甚至是一个函数高价值的功能，那么这个类或者函数就有成为单元测试被测对象的意义。而从软件测试的角度来看，在选择单元测试的被测对象时，策略上还需要考虑被测对象的可测性，看它是否可以进行单独的测试，或者存在复杂的对外依赖关系，进行单元测试的代价太高，比如需要准备过多的测试桩数据或测试桩服务等。 当一个单元具备了合理的被测价值和可接受的可测性时，我们就可以对其进行测试设计了。单就单元测试的设计而言，我们期望被测单元在大小上越小越好、在功能上越简单越好，以及在对外部依赖上越少越好，这样能更加方便我们设计可读性好、维护性强的单元测试案例。 在设计和进行单元测试的时候，根据对被测单元外部依赖的处理方式的不同，单元测试常被分成关联型的单元测试和独立型的单元测试。其中，关联型的单元测试就是将被测单元和它相关的外部依赖（其它的单元）作为一个整体，进行黑盒测试。它的优点是你不需要对复杂的依赖关系进行任何处理，通过测试可以得到关联单元之间真实的状态转换带来的被测单元的行为表现，而缺点就是当发现失效时，难于定位缺陷是来自被测单元还是外部依赖。 相对的，独立型的单元测试则是将被测单元之外的全部外部依赖使用测试替身替换，保证发现的任何失效都是来自被测单元的缺陷。独立型的单元测试因为使用了测试替身，所以它既可以测试被测单元作为服务或数据生产者的行为正确性，也可以检查被测单元作为服务或数据使用者时是否正确调用和解析了来自外部依赖的数据源。当然，在提供这些优势的同时，独立型的单元测试的缺点就是需要创建和维护测试替身，有时甚至是很复杂的测试替身。 值得一提的是，关联型的单元测试和独立型的单元测试并不是相互冲突的，实践当中，有时还会对同样的被测对象同时设计这两种测试类型。 那么对于一个如上图的微服务架构，我们进行单元测试的一般策略可以是： Domain，使用关联型的单元测试；因为领域层部分的代码通常都是进行各种状态转换和数据计算的复杂功能区，它和外部依赖的部分，比如Service Layer和Gateways都是数据强相关，对于这样的功能代码，使用测试替身的代价太高。 Gateways 和 Repositories，使用独立型的单元测试；这个部分的代码主要的功能是数据的传输和预处理，与之交互的数据主要都是来自外部依赖的单元，比如数据库和外部服务，对这部分单元测试的目的是验证获取的数据可以被正确的传输和解析，而不是测试和外部的交互过程，于是我们使用测试替身来模拟外部依赖的数据源可以得到更高的测试效率，另外，使用测试替身还可以帮助我们触发各种异常处理的测试场景，比如数据库返回异常的数值，这在使用外部依赖的时候是很难真实的重复测试的。 Service Layer，使用独立型的单元测试；这部分代码和上面的Gateways类似，它主要的功能是传输和预处理这个微服务与其调用者之间的数据，对其单元测试的目的同样是关注数据传输和处理的正确性，无论这个数据是微服务调用者发起的请求数据，还是Domain计算完成后返回的响应数据，都可以通过使用测试替身来获取很好的测试效果。 有时，一些微服务会在体量上设计得很小，只包含领域层与最简单的对外数据交互部分，比如一些功能单一却逻辑复杂的数据适配微服务，对于这样的微服务，较之单元测试，组件测试往往能得到更好的性价比。 单元测试是一项技术性比较强的测试活动，理论上，通过使用测试替身我们可以对每一个测试单元进行非常完备的测试，但那样做的代价也是很高的，无论是创建测试替身还是维护测试替身，所以在设计和进行单元测试时，应该时常审视我们的测试目的，避免进行过度的测试，使我们的单元测试套件有一个合适的体量，这既便于我们对单元测试本身进行维护，同样也保证我们的单元测试在持续集成的过程中能在较短的时间里完成执行。 最后，就像我们在任何敏捷实践中强调的一样，我们希望由开发人员来主导单元测试的编写，测试人员适度的参与评审，这样既可以较好的保证单元测试在案例场景上的质量。至于要不要做到TDD，团队应该根据自身的情况来决定。 集成测试集成测试是测试被测对象与其他外部组件进行交互的测试活动。集成测试的时候，被测对象都是和与之相关的外部组件共同协作的，他们共同组成了一个子系统。需要注意的是，虽然集成测试会贯穿整个子系统，但我们的测试对象始终只是其中的一个组件或模块，而不是整改子系统。这其实有点类似于单元测试中的关联型测试。 集成测试是所有测试类型中的万金油，我们既能在单元测试中看到集成测试的形式，也能在系统测试或端到端测试中讨论集成测试，这都取决于我们的测试策略如何来界定和执行集成测试。在微服务的集成测试当中，对测试的粒度没有固定的要求，我们通常强调的集成测试是指在微服务与外部系统交互的层面上的测试活动，比如微服务与数据库的交互，或者是一个微服务与另一个微服务的交互等等。 在一个类似上图的微服务当中，我们的集成测试关注的是当前这个微服务与数据库及外部服务的数据交互，我们的测试对象是Data Mapper和Gateways。这个我们在前面的单元测试部分也有提到，当时我们是选择将外部服务和数据库用测试替身进行模拟来提高测试效率，因为我们只关注外部的数据是否可以被内部的单元正确处理和传输。而对于集成测试，我们关注则应该是全部的交互场景，比如正向交互有多少场景、负向交互有多少场景，这些场景都应该体现在集成测试的测试案例当中。 Gateway 集成测试，我们应该测试各种协议错误，比如丢失报文头或无效的报文头，错误的SSL处理，以及各种收发消息的格式匹配问题。另外，外部服务超时无响应等异常案例也应该纳入集成测试当中。 当然，在使用真实的外部服务的时候，往往比较难实现各种负向或异常的交互场景，这时可以选择使用桩服务来进行测试，但其带来的效能开销需要被很好的权衡。 这部分测试还有一个难点是对特定数据的状态要求。比如你需要通过外部服务来获取某个数据的状态，而该状态又和时间相关，导致你在两次获取数据之间其状态就已经发生了改变，这种情况会给自动化的集成测试带来不小的麻烦。所以在策略上我们应该尽量选择或构造固定的数据来进行集成测试。 原文发表于2014年，其述及的”桩服务”、”数据状态改变”等内容，在当时，确实是集成测试中的一些难点。但随着技术的革新，目前这类问题已经有了更好解决方案，那就是服务虚拟化。至于服务虚拟化的内容，以后有时间，我再另文介绍吧，这里就不细讲了。我在今年成都的BQConf上面，正好有介绍这方面的话题，感兴趣的同学可以参考一下这里。另外，这本书《Testing Microservices with Mountebank》则更加详尽的介绍了虚拟化服务在微服务场景下的使用，值得推荐。 Data Mappers/ORM 集成测试，对于数据持久层的集成测试，关注的重点是获取的数据源能够被正确的映射和转换。特别是那些成熟的ORM组件，他们往往有非常复杂的数据处理逻辑，我们的集成测试应该尽量的覆盖所有可能涉及的数据操作，比如各种增删查改和断言处理等等。另外，越来越多的外部数据存储使用了网络分隔或分布式存储，那么就有可能会面临响应超时等网络异常问题，这些场景也应该在数据持久层的集成测试中予以考虑。 通过这样的集成测试，特别是持续的自动化集成测试，在对微服务的集成模块进行修改或重构时，我们就可以得到快速有效的反馈。有时，内部集成模块的功能回滚，或者外部模块的修改，都可能造成我们的集成测试的失效，而光靠集成测试是无法快速的发现造成失效的问题，这时如果需要通过测试来快速定位缺陷，就要依赖于足够的单元测试、集成测试以及必要的契约测试。 组件测试组件测试是指在系统内部，对一部分整合在一起的具备独立功能的模块进行的测试。组件内部的模块应该是强耦合的，其本身也应该具备良好的封装性，而且可以被独立的替换。组件是模块的组合，不同的组件又共同组成了整个应用系统，组件测试的目的是测试单个特定组件的正确性，而不同组件之间往往都是协同工作才能完成各自的功能的，所以在组件测试中，常常用到测试替身模拟被测组件的外部依赖，这样既可以避免去和复杂的外部组件交互（特别是当失效发生时，难于定位缺陷的位置），又可以确保测试环境是固定和可控的，而且还便于触发各种异常的测试场景。 在微服务中，从组件的定义就可以知道每个微服务本身就是最完整的组件。但测试某一个微服务时，其它与之相关联的微服务就使用测试替身来替换，从而限定我们的测试范围和缺陷可能发生的范围都在被测的微服务当中。 对微服务的组件测试是一种动态的测试，需要在微服务的运行时进行测试。在策略上我们有许多地方需要考虑，比如测试应该和微服务运行在同一个进程当中，还是单独运行再通过网络来访问被测微服务？我们的测试替身应该建立在微服务内部，还是单独搭建再和被测微服务交互？外部数据库应该连接真实的数据库，还是只是和加载在内存中的数据库镜像进行交互？一般说来，与内存中通过测试替身实例化的外部微服务或数据存储进行交互，都能够得到较快的测试运行速度，并且减少测试系统的复杂度。但这也要求我们的被测组件有比较灵活的配置管理方式，能够通过配置来很好的在测试模式和生产模式之间切换。比如我需要被测组件根据配置文件来自动的识别应该访问测试用的内存镜像数据，还是直接访问真实的外部依赖服务。为此，我们既可以使用配置文件来手动配置，也可以使用依赖注入框架。 同进程组件测试，使用同进程组件测试，就是在微服务本身的内部模块之外，构建用于测试的子模块，运行测试就会将测试数据和被测的微服务加载和运行在同一个进程当中。 同进程组件测试通常会自定义shim这样的套件，来给被测微服务发送请求消息和检索返回消息，当然，也有现成的工具可供使用，比如JVM的inproctester和.NET的plasma。不管是使用自定义套件还是使用现成工具，我们的目的都是替代真实的服务调用者，来和被测微服务进行尽量最多的消息交互。由于这样的交互过程完全是在内存中进行的，所以速度是远远高于真实的网络访问的。 前面我们提到，组件功能的完成往往都还需要依赖与其它组件或微服务的交互，所以我们还需要将这部分和其它组件交互的过程在同进程中实现，一般的做法就是使用内部数据源和测试桩客户端，由此，通过使用我们预定义的测试数据，不仅可以加快获取“外部”数据的速度，还可以重复、稳定的模拟外部依赖出现异常的情况，比如通讯超时、返回脏数据等等。 对于有挂载外部数据库的微服务来说，我们还可以使用内存数据存储来断开真正的数据库访问，它在提高测试性能方面的优势是不言而喻的。内存数据存储的实现，根据情况，我们既可以简单的自定义实现，也可以选择使用专门的数据存储工具，比如H2数据库引擎。需要提到的是，在使用内存数据存储的时候，我们需要足够的集成测试来确保数据持久层和真正的外部数据库交互的正确性。 最后，由于同进程组件测试隔绝了所有的外部依赖，这就保证了当需要依赖的外部组件，比如其他的微服务甚至是数据库，在进行他们自己的修改更新时，不会对我们被测微服务的组件测试造成影响，从而保证了测试的稳定性。 异进程组件测试，相较于同进程的组件测试，异进程的组件测试将被测的组件单独的运行起来，外部依赖使用桩服务或真实的数据源来进行测试。异进程的组件测试在测试组件的基本功能的同时，还能验证和部署相关的事物，比如对配置外部依赖的配置文件的读取是否正确等。而由于把外部依赖都纳入了组件测试的边界，所以我们在执行测试的时候，就必须还要兼顾外部依赖的启动关闭、端口配置等等额外的问题。当然，在异进程的组件测试中，因为使用了通过网络访问的桩服务和真实的数据库，测试运行的速度势必会低于同进程的测试，可是，如果被测的微服务存在非常复杂的外部依赖，或者持久层和数据库的集成很繁琐，那么异进程的组件测试方式还是比较推荐的。 异进程的组件测试中，微服务本身是监听真实的服务端口，所以我们在测试其基本的消息处理功能之外，还可以验证其网络配置的正确性，这是同进程组件测试做不到的。同样的，对外部桩服务的访问，以及持久层和数据库的交互，都可以验证微服务对依赖的配置是否正确，比如是否可以正确的访问配置的URL和端口。 当然，搭建外部依赖的桩服务是不可缺少的，我们可以选择使用动态的API访问，也可以使用固定的死数据，或者使用通过记录回放机制进行的交互。比如moco，stubby4j和mountebank既可以提供动态的API访问，又可以读取固定数据，而vcr则可以提供记录回放的功能。 在有了足够的单元测试、集成测试和组件测试的基础上，我们的微服务就已经有了一定的质量保证了。但这样的质量保证只对于单个的微服务。使用微服务构建的应用不可能只是单个微服务，都是多个微服务协同工作的来实现业务价值的，所以为了保证整个应用系统的质量，我们还需要使用契约测试来时刻保证微服务之间相互契约的完备，以及使用端到端测试来保证所有微服务作为一个整体能够满足真实的业务需求。 契约测试契约测试是用来验证服务生产者和服务消费者彼此之间契约完备正确的测试活动（这里的服务不仅限于微服务，也可以是传统的单体服务）。 什么事契约呢？当一个微服务被另一个微服务访问的时候，被访问的微服务称之为服务的“生产者”，发起访问的微服务称之为服务的“消费者”，生产者与消费者之间进行的交互就是他们两者之间的契约。比如消费者发起的请求消息，以及生产者返回的应答消息都是契约的组成部分。契约是存在于一对消费者与生产者之间的，如果有多对消费者和生产者，那么就会有多种契约的存在。比如，同一个生产者被三个不同的消费者访问，就存在三个不同的契约，类似的，同一个消费者访问三个不同的生产者，也存在三个不同的契约。 契约测试在形式上比较类似组件测试，因为它们都是通过收发消息来模拟服务的调用，但组件测试需要关注全部的调用场景，比如各种正向和负向的消息交互，而契约测试则不会深入的检测消息交互的场景，它一般只关注正向的消息结构是否完备正确，比如对于一个返回消息，契约测试关注它有多少个属性、每个属性的值是什么类型，而不会像组件测试那样去验证在什么情况下每个属性的值具体是多少。所以契约测试并不是组件测试。 一般而言，每个具体的契约测试都是由各个消费者来编写，它们只关注自己与生产者之间的契约关系，而执行这个契约测试则往往是在生产者的持续集成环境中进行的。也就是说，对于某一个服务生产者，在它的持续集成环境中可能同时运行多份和不同服务消费者之间的契约测试，其目的就是去发现每一次生产者的自身更新是否会对任何它的服务消费者造成影响。这一点对于内部由微服务构成的管道型结构的应用来说，是非常有意义的，因为其内部时常存在着复杂的相互调用关系，在这种关系下，对每个微服务的变更（无论是正确还是错误的）都有可能导致其它微服务的局部失效，致使整个系统可能会出现错综复杂的异常，而契约测试通过预警每个服务生产者的变更是否会造成已有契约的失效，来最大程度的避免了这种乱象的产生。 我们来看一个例子，如图的一个调用关系，四个微服务，其中，一个生产者，它提供的服务消息里面包含id、name和age三条数据。三个消费者A、B、C，它们都与生产者有着各自的契约，消费者A只需要生产者提供的id和name，即为契约A；消费者B只需要生产者提供的id和age，即为契约B；消费者C则需要生产者提供的全部id，name和age，即为契约C。此时，如果生产者需要对name进行修改，将字符串改成一个包含firstname和surname的对象，那么消费者A和消费者C就很可能因为这样的修改而在解析消息的时候出现错误，但消费者B则不会受到影响。所有，通过在生产者的开发环境中进行契约测试，我们便可以在部署之前预警这样的风险。那么对于生产者来说，如果这样的修改是必须的，那么就应该告知消费者A和C在适当的时候进行相应的修改，然后更新契约测试。 在上面的列子中，如果对name的修改不是生产者计划的，而是某个消费者期望生产者改变的，那对生产者而言，这就形成了一种“消费者驱动”的设计开发模式，这种消费者驱动的模式可以更好的确保生产者的开发工作从设计上都是满足其消费者需求的，避免了不必要的开发。 目前主流的契约测试工具，主要是Pact和Spring Cloud Contract。 E2E测试端到端的测试活动是为了验证整个系统能够满足预定的设计需求，它完全抛开系统内部任何的微服务架构，只从整体全局上去检验系统的业务价值是否得以实现。所以，在端到端的测试当中，我们进行的是对整个系统的黑盒测试，测试的方法也是遍历真实的GUI界面或者调用真实的API接口。而为了体现真正的业务价值，在端到端测试中设计测试案例往往也使用面向业务的DSL。 端到端测试除了展现整个系统的业务功能，还能确保与整个系统相关的外围环境可以正常的协作，比如防火墙、代理以及负载均衡等等问题。另外，当整个系统架构需要进行较大规模的修改，甚至重构的时候，端到端测试还能始终保证系统业务功能的正确性。 对于端到端的测试是所有测试类型中粒度最大的，我们需要模拟真实的用户场景来进行测试。对于GUI的应用，我们可以使用Selenium来进行Web的自动化测试，而对于没有GUI的单纯的API服务，我们可以使用Postman进行手动测试，或者REST Assured进行自动化测试。 测试边界对于端到端测试来说是一个需要权衡的问题，特别是在我们的应用系统存在外部依赖，而被依赖的对象又不在我们团队的控制范围之内时，是否要将外部依赖纳入我们的测试边界就值得去思考了。如果将依赖至于测试边界之外，每次测试的时候都去访问正在的依赖对象，我们就可以得到最真实的系统行为结果，但问题是这样的结果有可能不是稳定和可复现的，比如当依赖对象发生异常时，就会给端到端测试带来不小的麻烦，特别是对于运行在持续集成系统中的自动化端到端测试而言，更是如此；如果将依赖至于测试边界之内，就意味着我们需要自己搭建被依赖的桩服务，这样虽然可以保证测试的稳定性，但却给测试的真实性打上了折扣。所以如何选择针对外部依赖的端到端测试边界，是需要团队根据项目的整体开发策略，特别是风险策略来判断的。 除了测试的边界问题，端到端测试还面临一些普遍的难点，比如由系统的消息异步问题，所以我们总结了一些小的策略来帮助更好的进行端到端测试: 编写尽量少的端到端测试，因为通过其它低层级的测试，我们已经对微服务有了不错的质量保证，而端到端测试只是确保系统业务功能达到设计要求，所以不需要在过多的场景上消耗时间，比如一些很少遇到的场景或者是负向的场景。一个不错的实践方式是使用“时间预算”，团队成员共同决定一个可接受的以分钟为单位的端到端测试时间长度，之后所有的端到端测试都只运行这么长的时间，如果有新的测试案例需要添加进来，那就移除一些老旧的案例，始终保证测试的总时长不变。（不要告诉我你不知道我们这里说的是’自动化的端到端测试’） 测试的设计关注用户角色和场景，设计案例的时候，保证系统中每一种用户角色和他会进行的使用场景都被纳入测试范围就可以了，而其他的一些极端的场景就可以交由另外的测试去检验。 合理的选择你的测试端点，就像我们在前面讨论测试边界时一样，如果你的端到端测试严重受限于GUI或外部依赖，那么就应该考虑将依赖和GUI的部分放到测试边界之外，以确保测试的稳定性。 使用代码来描述和管理基础设施，雪花状的系统环境在给系统部署带来一定麻烦的同时，也给端到端测试带来一些额外的配置管理工作，特别是需要搭建一个新的测试环境时，需要顾及不少的环境部署问题，所以一个比较好的实践就是通过代码化的方式来实现全部基础环境的可重复式的构建，比如使用Ansible工具。（嗯，2014年，DevOps肯定不像现在这么深入人心~） 使用独立的测试数据； 测试数据是端到端测试的一个重点问题，特别是当测试数据不稳定，或是跟随时间基进行状态变化的时候，同样的测试往往可能失效，而这种“假失效”无法反应系统的问题，却会给测试带来困惑。所以保证测试数据的独立和可重复是非常重要的，比较好的方法就是在每次测试运行时，往数据库中单独加载固定的测试数据集合。 以上的这些策略在技术实现上有一定的难度，所以有的团队会选择绕过测试环境，而直接在生产环境上进行端到端测试。这样的做法也是无可厚非的，虽然它的测试效率会受到限制，但它能够反映最真实的系统行为，甚至发现一些只有在生产环境上才可能发现的问题。 总结 总的来说，微服务的环境下，以上的这些策略能够给测试哪些和怎么测试带来一些方向，虽然它们中的一些观点同样适用于传统的单体应用，但我们更希望它能给微服务的测试带来更多的针对性。当然，在实际的项目运行中，基于成本的考虑（包括人员、技术、时间等），很少有团队会实践所有上面述及的策略和方法，所以如何去制定一个最适合自己项目的微服务测试策略，永远都是留给团队自己需要回答的问题。","categories":[],"tags":[]},{"title":"契约测试之核心解惑","slug":"契约测试之核心解惑","date":"2019-05-19T11:36:10.000Z","updated":"2021-05-16T06:36:37.020Z","comments":true,"path":"2019/05/19/契约测试之核心解惑/","link":"","permalink":"http://yoursite.com/2019/05/19/%E5%A5%91%E7%BA%A6%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%A0%B8%E5%BF%83%E8%A7%A3%E6%83%91/","excerpt":"在之前写的《契约测试之Pact By Example》中，我曾提到会再写一篇文章，来聊聊如何正确地认识和理解契约测试（好吧，至少是我认为的”正确地”）。但在随后的一年多时间里，对契约测试的讨论渐渐淡出了我的视野。我的理解是，随着微服务的大行其道，契约测试作为带刀护卫，已经深入人心了，所以没必要再去炒这碗冷饭，就像现在已经没有谁会再来码字吹Selenium一样（…请相信，我一定不是因为懒才这么说的o(*￣3￣)o）。 然而，在最近参加的一次面向Dev的后端分享的讨论中，我意外的发现，契约测试作为构建微服务重要的一环工程实践，虽然确实已经被团队原生接受，但对于契约测试的理解，还存在一些认识上的盲点，特别是当契约测试与集成测试、接口测试一起讨论的时候，理解的偏差往往会被放大不少。所以，我想必要的码点字，分享一下我对契约测试的理解，还是有益的。","text":"在之前写的《契约测试之Pact By Example》中，我曾提到会再写一篇文章，来聊聊如何正确地认识和理解契约测试（好吧，至少是我认为的”正确地”）。但在随后的一年多时间里，对契约测试的讨论渐渐淡出了我的视野。我的理解是，随着微服务的大行其道，契约测试作为带刀护卫，已经深入人心了，所以没必要再去炒这碗冷饭，就像现在已经没有谁会再来码字吹Selenium一样（…请相信，我一定不是因为懒才这么说的o(*￣3￣)o）。 然而，在最近参加的一次面向Dev的后端分享的讨论中，我意外的发现，契约测试作为构建微服务重要的一环工程实践，虽然确实已经被团队原生接受，但对于契约测试的理解，还存在一些认识上的盲点，特别是当契约测试与集成测试、接口测试一起讨论的时候，理解的偏差往往会被放大不少。所以，我想必要的码点字，分享一下我对契约测试的理解，还是有益的。 “契约测试，是建立在服务的消费者和生产者之间的……”(此处省略废话N多字)，如果您要继续看下去，请注意： 以下的内容不会涉及基本的契约测试概念，比如消费者、生产者、契约、消费者驱动等等，如果您对这些基本概念还不是很清楚，建议您可以花点儿时间先google一下，当然，Pact的官方文档可以是一个很好的开始； 以下的内容不会涉及具体的契约测试编写和执行步骤，相关的内容，您可以参看我之前的文章《契约测试之Pact By Example》； 如果您之前在任何地方、通过任何方式，看到过一些我对契约测试的观点的分享，并且觉得我就是在胡说八道，那您也不用看下去了，因为后面都是胡说十六道，而已； 关于测试的表述在聊契约测试之前，让我们先来说一些平时看似毫不起眼的小话题—“测试的表述”。 “我们可以在E2E测试中覆盖这个场景，而不是单元测试…” 或者 “你们的E2E测试是怎么做的？…” 这里的E2E测试可能经常出现在我们的日常交流中，那你知道它的准确含义吗？答案是没有含义！它基本等价于你们一伙人去食堂吃饭（…笑啥，俺就是食堂党，咋的！），A：”今天吃啥？”，B：”新鲜的”。新鲜的啥？炒饭？面条？饺子？套餐？…… E2E，End To End，端到端，字面意思简单明了，但它只是一个副词（组），而不是一种测试类型。所以，我们真正想表述的，可能是E2E API Test。那么”E2E API Test”就完整的表述了一项测试活动了吗？不是的！E2E表示的是测试方式，API表示的是被测对象，但这里，我们还缺少被测对象的被测属性，比如，Function、Performance, Security等等，所以，一个比较完整的表述，往往可以是这样的： 当然，平常的交流中，一般不会这么文绉绉地去抠字眼，因为我们彼此都清楚讨论问题的上下文，这点很重要。特别是针对E2E测试这样的表述。比如，我们有一个前后端分离、后端是微服务集群的系统应用，同样的E2E测试可能就代表着完全不同的测试活动： 如果从更多的维度来思考，比如套上测试四象限的模式，那么对于测试活动的表述，还会有更多考量。但今天的主题是关于契约测试的，所以就不过多的展开了。为什么要在讨论契约测试之前来废话”测试表述”呢？因为契约测试其实是多种测试方式的和思维的复合产物，比如，契约测试是E2E的测试吗？还是说是基于Mock的？契约测试是服务的接口测试还是集成测试？等等。所以，如果对这些基本的测试概念不是很清楚的，很容易迷失在契约测试的理念中。 为什么要做契约测试？为什么要做契约测试？”因为我们是微服务”？(╬￣皿￣)=○ 很多回答这个问题的答案，都关注在契约测试的目的上。那么，什么是契约测试的目的呢？简单来说，契约测试就是为了发现契约破坏（Contract Breaking)而进行的测试活动。如果你使用过Pact或者Spring Cloud Contract，你会发现，契约测试本身也是通过调用Provider的API接口来获取Response，再与契约文件中期望的结果做对比，从而验证契约是否正确。形式上，这和我们的API接口测试，或者针对功能的集成测试（以下简称集成测试，因为我们这里不讨论API的安全、性能等问题）是非常类似的。换句话说，我们通过API的接口测试或者集成测试，也能达到检查契约的目的，那为什么还要做契约测试呢？这种思考逻辑是完全正确的，也是为什么很多初学者都认为契约测试没有必要的原因。 那再问，为什么我们还要做契约测试呢？真正能够回答这个问题的，不是契约测试的目的，而是契约测试可以带来的价值！ 契约测试的价值那什么是契约测试的价值呢？要说清楚契约测试的价值，就需要准确认识契约测试的精髓–”消费者驱动”。 消费者驱动的字面含义，大家都清楚，但往往容易忽略的是被驱动的对象。在讨论契约测试的范畴里，”消费者驱动”述及的对象是契约，而不是契约测试。 当某个provider正常上线后，某个consumer需要消费这个provider的服务，那么应该由consumer来提出期望建立它们之间的契约测试。因为，契约测试，形式上，虽然测试的是provider，但，价值上，保证的却是consumer的业务。如果consumer对自己都不上心，你还期望provider来时刻关注你的死活吗？别笑，在跨团队的微服务体系下，这些都是真切的痛点。 理清了消费者驱动，就让我们来看看契约测试真正的价值吧。一个经典的案例： 在上图一个简单的消费关系中，provider为consumer A，B，C提供服务。provider自己提供的schema包含name,age和gender三个简单的字段。请注意，这份包含name，age和gender的JSON，其本身，只是一个schema，并不是任何契约。契约一定是成对存在的，没有确切consumer的交互定义，只是schema，不是契约。一个列子，中介打印了一份合同，上面写好了房屋租赁的全部信息，但在房东和租客都签字之前，这份”合同”并不具有任何效力，所以它根本就不是一份有意义的合同，法律上，它叫”要约”。（…感谢我大学的法律老师，我居然还记得这个词儿） 现在，这里有三份契约（对应的，就应该有三份契约测试），consumer A消费provider的age和gender，consumer B消费name、age和gender，consumer C消费name和gender。就目前provider提供的schema来说，没有任何问题，大家相安无事。 某日，因为业务需求，consumer C期望provider提供更加详细的name信息，包括firstName和lastName。这个需求对provider并不困难，所以，provider打算对schema做类似下面的修改。 这样的修改，很明显，对consumer C是需要的，对consumer A无所谓，但对consumer B却是不可接受的，属于典型的契约破坏。此时，provider和consumer B之间的契约测试就会挂掉，从而对provider提出预警（至于，剩下的，怎么协调和consumer B的兼容问题，就不是契约测试关注的问题，那需要的是团队间的communication）。 上面这个示例中的一些细节，可以帮助我们发掘契约测试的价值点： “consumer A没有使用name，consumer C没有使用age”，基于消费者驱动的契约测试，契约的内容由consumer提供，其内容体现的是各个consumer对provider提供的schema的消费需求。这里的需求，不光包含consumer”需要什么”，还包含consumer”不需要什么”。这是非常有意义的，因为当你发现provider提供的schema的某些部分不被任何consumer消费时，就代表provider可以对schema的这些内容做任意的修改，完全不必担心会影响到任何consumer。这是契约测试非常重要的价值点。 “单个provider多个consumer”，要最大化的体现契约测试异于集成测试的价值，一定是在”单个provider对应多个consumer”的架构下来说的。因为，在只有一个provider和一个consumer的架构下，只存在一份契约，对该契约内容的任何修改，对这对provider和consumer来说，都是显而易见的，那么就不会出现契约破坏的情况。说人话，就是，如果是consumer提出要修改契约，consumer一定知道改怎么消费新的契约内容；如果是provider提出修改契约，对于唯一的一个consumer，provider能很方便的告知其将要对契约的修改。并且，在这种情况下，集成测试往往就已经完整的达到了契约测试的目的。 而在单个provider对应多个consumer的架构下，情况就大不一样了。provider和consumer C之间的契约修改，对consumer A无感，对consumer B却是契约破坏，对此，集成测试是无能为力的。仔细来看，这里有4个service，就会有4个集成测试。但每个集成测试都只会关注自己的业务正确性，具体来说： consumer A，因为不受影响，所以A的集成测试没有任何变化； consumer C，因为是契约修改的提出者，所以它会在provider提供新的schema后修改自己的集成测试，没有问题； provider，如果接受了consumer C的需求，大摇大摆地修改了schema，它也会相应的修改自己的集成测试，因为对provider来说，这个变更是正常的业务需求，也没有问题； consumer B，最倒霉，啥都没干就挂了，当然，它的集成测试会捕捉到这个failure，但那都是在provider的契约破坏生效之后的事情了，能做的也只有亡羊补牢。 可见，虽然4个集成测试都各司其职，但都不能对这个契约破坏的问题做到防患于未然！只有契约测试，才是这个问题的最佳答案！这就是契约测试最大的价值，它只会在”单provider多consumer”的环境下（这是微服务的常见场景，但不是必然场景），才能发挥出来。 “很显然，对consumer A无害，但对consumer B却是契约破坏”，&quot;很显然&quot;，仅仅是对于我们这个简单得不能再简单的示例而言，真正的业务场景下，特别是一些复杂的微服务集群，又或者是一些时间跨度很长的系统，对于某个provider，到底有多少个consumer？而provider的每一处修改，又到底会对哪些consumer的契约造成怎样的影响？这些往往都是很难确定的问题。我最近所在的一个集团项目上，一个搜索地址的基础服务provider，有十个左右的consumer，其中有八个consumer没有契约测试，就不清楚它们对provider的API具体是如何消费的，所以每次provider要更新，就得八方去通知这些consumer的团队来做回归测试。有时，一点小小的修改，回归测试一分钟就可以搞定，但人肉联系各个团队却会花上好几天…… 如果每个consumer都能和provider建立契约测试（这里我们暂且不考虑负载和去重的问题），通过类似Pact Broker这样的实践，我们就能很好的解决这些效率问题。 OK，理解透契约测试的这些价值后，对于”要不要做契约测试？”、”谁来做契约测试？”这些问题，相信你就不再疑惑了。想再次强调一下的是，契约测试很多情况下基于微服务而生，但并不代表每个微服务都一定需要契约测试。相对的，一些传统的单体服务，它的架构设计和部署实施，完全和微服务的理念相反，但它提供的服务却被众多的下游消费者使用，那么这样的服务，也有很强的契约测试需求。所以，千万不要把契约测试和微服务做”死绑定”，一定要基于服务的业务来考虑策略。 契约测试和接口测试、集成测试的区别“契约测试和接口测试、集成测试的区别”，从2015年我第一次在BQConf讲契约测试，到写这篇文章之前，最近一次和别人讨论契约测试，这都是一个一直被提起的问题。在上面的内容中，其实已经或多或少的提到了相关的内容。由于具体的测试方式，都是”调用API验证Response”，契约测试、接口测试、集成测试经常被放在一起来进行比较，甚至质疑彼此。 先让我们来看看接口测试和集成测试。说实话，对于测试理论夯实的QA来说，这里应该没有任何问题的，因为接口测试和集成测试，它们压根儿就是从完全不同的维度来描述测试活动的。 前面说过，如果要完整的描述一个测试活动，至少需要考虑三个内容：测试方式、被测对象、被测属性。然而，”接口测试”和”集成测试”，显然，都是我们根据上下文使用的简称，更准确的： 测试方式 被测对象 被测属性 接口测试 调用API接口 只能是API … 集成测试 … … 肯定是被测对象在于外部依赖集成时的行为表现 接口测试 被测属性 — 不定，可以是被测对象的性能或安全行为，但根据上下文，默认是功能行为； 集成测试 测试方式 — 不定，可以直接进行E2E的测试，也可以进行基于Mock的测试； 被测对象 — 不定，可以是UI，也可以是API，但根据上下文，默认是API； 所以，基于不同的维度，我们有”接口测试”和”集成测试”的表述，但，当放在和契约测试来讨论的时候，它们描述的可能是同样的测试活动。即，通过调用API接口，来测试API的功能行为。 这里，想强调一下集成测试中的”集成”。对于传统的瀑布开发模式，对应的测试流程按照测试级别（Test Level）划分，一般是：单元测试 -&gt; 集成测试 -&gt; 系统测试 -&gt; 验收测试，这是”集成测试”早期的由来。 那会儿的应用，往往是庞大的单体服务，服务内部有分工明细、边界分明的”模块”。这些模块被并行开发，就绪后就会进行彼此集成。集成的对象，一般可以简单分为：逻辑模块、数据库模块、外部服务模块。比如，在上古时代，对数据库的操作是比较繁琐的，开发人员往往需要自己组装SQL语句，然后封装成模块来供上层调用。单元测试可以保证这些模块自己的逻辑正确，但像”模块中的各个函数接受的参数个数和参数类型是否和模块使用者的需求相匹配”这样的问题，就需要集成测试来确保（集成不等于集成测试，内容所限，我就不过多说明了）。这些测试都是发生在单体服务内部的，类似于现在的组件测试。 如今，微服务的设计，将不同业务的”模块”拆分成了不同的服务，各个服务都是高内聚的。以Spring为例，Controller -&gt; Service -&gt; Repository，内部垂直划分，简单明了。像上面提到的手写SQL这样的数据持久化工作，已经基本不存在了，取而代之的是像spring-boot-starter-data-jpa或spring-boot-starter-data-mongodb这样功能强大、方便易用的公共组件，最重要的，这样的公共组件，一般都有很高的官方质量保证的。所以，结论就是，在上古时代的那种传统的集成测试，在微服务的体系下，已经基本不需要了。 而对于单个微服务的质量保障，特别是当这个微服务有外部集成的时候，比如数据库或者外部服务，我们仍然需要进行检查外部集成的测试。再结合微服务业务的单一性，我们可以很自然的将这种”检查外部集成的测试”合并到API的接口功能测试中。说人话就是，对于微服务，只进行API的接口功能测试，既涵盖对被测服务领域逻辑的检查，又覆盖其对外部集成的检查。 当然，这里已经讨论到了微服务测试策略了，我就不再过多展开了。话收回来，如果要和契约测试进行区别比较的话，我们只用考虑功能性的API接口测试就可以了。 理清了接口测试和集成测试的内部姻缘（下面我统称功能测试），我们就最后来说说它们和契约测试的区别吧~其实，上面那个示例，已经很好的展现了它们的区别，我就不过多解释了，简单来说： 功能测试关注的是provider的实现正确体现其设计，契约测试关注的是provider的实现（当然，肯定也包括设计）满足每一个consumer的需求。注意，功能测试只关注provider自身，契约测试关注每一个consumer； 功能测试的测试案例，由provider的团队提供，契约测试的测试案例，基于消费者驱动，由各个consumer团队提供； 一个provider只会有一个功能测试（谁要纠结”一个功能测试”是几个testcase，就把TA拖出去枪毙三分钟），但契约测试，理论上，可以无限，有多少consumer就可以有多少个契约测试； 同样的一个testcase，在功能测试里面出现一次，在契约测试里面出现N次，它们的含义是完全不同的。什么含义，自己琢磨琢磨； 一个testcase，出现在功能测试里面，却没有出现在契约测试里面，是非常有意义的。啥意义，再自己琢磨琢磨； 功能测试可以自娱自乐，契约测试必须组”对”上分； 契约测试可以替代集成测试吗？“契约测试替代集成测试”，说实话，第一次听见这个说法的时候，我是非常惊讶的，这得多大的脑洞才能给出这样的命题呀！ 提示一下，就题论题，这里的”集成测试”，并不全等与上面提到的”功能测试”，仅仅是一般论的集成测试。 先来揣测一下，为什么会有这样的问题吧。我们知道，在Pact（JVM）的实施过程中，第一步是在consumer端生成契约文件。这期间，Pact会根据自定义的契约，在consumer端启动一个mock server（如果你有看源码，就知道它只是一个普通的HttpServer实例），consumer向这个mock server发送request获取response，整个过程被记录成JSON的契约文件。 这个流程的最后一步，一直有一个大家乐于争论的话题：”要不要对response的内容做断言检查？”。这是一个很开放的问题，没有标准的答案。但我想强调的是，不加断言，这一切只是一个”流程”或者说”步骤”，加上断言，它就是测试。是的，对consumer来说，它就是consumer的一种集成测试（啥？”用的是Mock Server，都没有集成真正的provider，为什么叫集成测试？” 如果你有这个问题，可以再仔细想想集成测试的真正含义……）。 以上是解题背景。现在，让我们再来省一下题吧，”契约测试可以替代集成测试吗？”，这里，其实隐藏了很大的一个意识盲点。契约测试，描述的测试活动，一定是架设在一对consumer和provider之间的。那么题目里的集成测试呢？你是想替换consumer端的集成测试？还是想替换provider端的集成测试？还是说其实你也不清楚到我想替换哪一端的集成测试……”不！我想说的不是两个服务之间的集成的那种测试，而是整个系统，包括全部上下游服务，集成在一起的集成测试”……诶，好吧，那叫系统（E2E）测试…… 还是让我们回到一般论的集成测试上来吧（不然，要说的实在太多了 T_T），无论是consumer端还是provider端，集成测试的关注点，是consumer是否可以正确的消费provider的API，这里的”消费”包括调用接口和解析数据。它的被测对象，注意，一定是consumer，或者说，是一个服务作为consumer的角色（因为，某个服务经常既是consumer，又是provider）。而契约测试的被测对象，一定是provider。好了，这就是问题的核心，其它的细节，我想就不必再赘述了吧。 关于Pact和Spring Cloud Contract“用Pact还是Spring Cloud Contract？”，这是另一个经常被讨论的话题。它背后折射的却是另一个非常重要的概念博弈：契约测试 vs 基于契约的测试（契约驱动的测试）。 Pact的理念是消费者驱动的契约测试。什么是契约测试呢？目前，我没有找到任何”权威”的定义。其实，面向工程实践的理念，也许根本就没有权威，有的只是最适用于自身的实践总结。即便如此，我还是希望以个人的视角，提供一些解读： 如果你google搜索contract test，你得到的第一个答案肯定是Martin Fowler在2011年的这篇文章，但遗憾的是，老马这里讨论的契约测试，是解决在集成测试中，如何保证测试替身有效性的问题的，它和我们今天讨论的契约测试并不是一回事。但是，如果抛开契约测试的内容，而单论”契约测试”的定义的话，老马的文章其实表述了一个很有价值的点，那就是”契约是需要测试的”，这是非常有意义的。 Pact的官方文档，是另一个可以帮助我们理解契约测试的地方。它对契约测试给出了这样的定义：Contract testing is a way to ensure that services (such as an API provider and a client) can communicate with each other.，这里面需要关注的重点是communicate，它给出了Pact对契约测试范畴（scope）的定义。 对于任何以”XXX测试”命名的测试活动，我们都遵循同样的一个理解的公理：”XXX”一定是被测对象或被测属性。比如，UI测试，测试对象一定是UI；安全测试，测试的一定是被测对象的安全表现；兼容性测试，关注的一定是被测对象在兼容性方面的问题，等等。同样的，”契约测试”，被测对象一定是服务之间的契约。 好了，有了这三点重要的理论基础，就让我们来具体看看Pact和Spring Cloud Contract（以下简称SCC）的区别吧。 在上面的图中，给出了Pact和SCC具体的使用方式（逻辑路径）。当然，如果你有一些基本的Pact或SCC的使用经验，就再好不过了。 Pact，在consumer端生成契约文件，发布到Pact Broker，而后，provider从Pact Broker获取契约文件，触发provider端执行契约测试。 SCC，实际生成契约文件的工作是发生在provider端的，基于这份契约文件，在provider端，生成了Java的测试案例，这些测试案例用于provider的功能测试；而在Consumer端，使用同一份契约文件作为Stub，生成了基于WireMock的mock service，consumer可以使用该mock service来做集成测试。 可见，Pact作为消费者驱动契约测试的倡导者，真正地实践了消费者驱动的契约测试。相对的，SCC，既没有实际的将契约作为被测对象来进行测试，更没有确实地实现”消费者驱动”。SCC的做法，实际上是基于同一份契约，分别驱动了consumer端的集成测试和provider端的功能测试。所以，Pact和SCC的区别，就在于，前者做的是”契约测试”，后者做的是”基于契约的测试（契约驱动的测试）”。 如果有同学阅读过SCC的文档，一定会质疑，SCC明文写着”Spring Cloud Contract Verifier enables Consumer Driven Contract (CDC) development of JVM-based applications”，那为什么说它没有确实地实现”消费者驱动”呢？因为在SCC的设计中，原始契约文件是在provider端生成的。为了实现CDC，consumer需要在其本地克隆provider的代码仓库，”借”provider来生成原始的契约文件。显然，在现实的项目中，consumer团队不可能随心所欲的获取到provider代码仓库访问权限，所以有了后来的，基于Share Repo的解决方案，来实现契约的共享（编辑和使用）。所以说，从最初的设计思想来看，SCC并没有像Pact那样，”实实在在”地实践了消费者驱动的契约测试。 那么，到底是选择Pact（契约测试）还是SCC（基于契约的测试）呢？答案是”按需取舍”。比较Pact和SCC的目的，并不是区别彼此的好坏长短，而是阐述它们各自不同的测试理念。Pact的价值点，前面已经说过了，SCC，虽然做的并不是真正的契约测试，但它通过共享（同一份）契约的方式，实现了微服务测试中，consumer和provider之间E2E集成测试的解耦，这在实际项目中，也是有重要的现实意义的。感兴趣的同学可以自己下来多研究研究，我就不在这里扩展了。 一些问题至此，在我看来，契约测试相关的认识难点，就已经基本解读到了。但在结束全文之前，有两个问题，我还想再阐述一下： consumer端的集成测试需要做到什么程度？对于Pact，前面提到，在consumer端生成契约文件的时候，加上断言语句后，就”构成”了consumer端的集成测试。这个集成测试，从Pact的角度来说，是可选的，它的目的是保证consumer端生成的契约文件本身是正确的。但从consumer的角度来说，要不要进行这一层级的集成测试，取决于consumer团队自己的测试策略。我想说的是，如果要进行这一层级的集成测试，请一定合理把握你的测试粒度和测试范畴。 测试粒度，由于这里的集成测试是和契约测试强绑定的，如果为了增加集成测试的覆盖率而设定过小的测试粒度，会大大增加契约测试的测试案例。而其中的一些测试案例，对于关注功能的集成测试来说，可能是不同的等价类，但对关注schema的契约测试来说，则完全可能是相同的等价类，从而造成测试冗余。所以，合理的把握测试粒度，是非常重要的。当然，就个人意见，我是反对这种和契约测试绑定的集成测试的。功能测试和契约测试，是完全不同的测试活动，它们肩负各自的使命、体现各自的价值，应该各司其职。这是我和Beth Skurrie（Pact最主要的核心开发成员，没有之一）多次探讨的一致共识。 测试范畴，是另一个需要考虑的问题。上面提到过，Pact将契约测试的范畴定义在了communicate。什么是communicate呢？很简单，通过通讯获取信息。具体到契约测试中，（可）通讯，体现在API的endpoint接受request（request包括protocol，url，header，body等），返回response；（可）获取信息，体现在获取的response能够被按照期望的方式解析（反序列化）。需要强调的是，communicate的内容不应该包含”使用信息”。使用信息，是consumer的领域逻辑需要处理的问题，而信息使用得是否正确，则应该是consumer的功能测试关注的范畴。注意，这里的功能测试可以发生在单元测试、组件测试、集成测试等各个测试级别。这就是为什么Pact的官方示例文档中，在consumer端，仅仅断言了response的status code这些非常简单的数据。如果consumer团队确实有需求，跨出communicate的范畴来构建集成测试，那么请一定合理斟酌你们的测试范畴。 “生产者驱动的契约测试”？相较于到目前为止通篇强调的”消费者驱动的契约测试”，你可能在其他地方，或多或少的，看到过”生产者驱动的契约测试”的命题。单论契约，确实可以分为”消费者驱动的契约”和”生产者驱动的契约”，但述及契约测试，到目前为止，恕俺视野有限，我并不认为”生产者驱动的契约测试”是一种正确的表述。 契约不等于契约测试，这不必赘述； 无论是消费者驱动、还是生产者驱动，其实质一定都必须是契约测试。这点，消费者驱动的契约测试不必多说，但对于”生产者驱动的契约测试”，事实可能并不是这样。生产者驱动的契约测试，其实质，就是上面讨论过的基于契约的测试（契约驱动的测试）； 具体来说，生产者驱动的契约测试，强调的是，当provider有需求和计划更新既有服务的schema时，在实际部署变更之前，先更新相应的”契约”（为什么这里的契约要加引号，自己琢磨琢磨），新的”契约”，如果包含契约破坏，会导致consumer端的（契约驱动的集成）测试挂掉。由此，consumer端可以在provider端真正部署包含契约破坏的服务之前，获得预警，从而对consumer做必要的更新准备，来适配provider将会部署上线的更新内容； 在我看来，这是契约测试的一种反模式。在消费者驱动的契约测试中，契约是复数存在的，每一份契约都会被provider测试，如果有契约破坏，会被及时反馈，必要的时候会被修正；而”生产者驱动的契约测试”中，”契约”是唯一存在的，它的正确性是不会被测试和质疑的，它仅仅会被consumer用来验证自己能否正确消费这份”契约”，所以，”生产者驱动的契约测试”，测试的并不是”契约”，而是consumer。 “如果质疑生产者驱动的契约测试，是因为它测试的不是契约，而是consumer，那么是否也可以质疑消费者驱动的契约测试，测试的也不是契约，而是provider呢？” 形式上来看，好像确实如此。但如果我们进一步分析，不难发现，消费者驱动的契约测试，对于不可接受的契约破坏的最终结果，要么是provider自主的功能修改被驳回，要么就是consumer主张的契约变更被驳回。结论就是，消费者驱动的契约测试，是对契约的双方进行约束，这体现了契约的意义，另一方面，对于不可接受的契约破坏，无论是哪一方引入的，它都将会被驳回，这体现了测试的意义(任何“功能”，如果交付测试后，无论结果好坏，它都是不可逆的，那测试本身也就失去了意义)。再来看“生产者驱动的契约测试”，一旦provider发布了“契约”，无论是否发生（对任一consumer）不可接受的契约破坏，无论“测试”的结果如何，这份“契约”都不可能被驳回，这样的“测试”，如果还说它的测试对象是“契约”的话，那这种“测试”对契约来说是没有意义的。归根到底，还是”契约测试”和”基于契约的测试（契约驱动的测试）”的区别。 当然，这样的测试活动，并不是一无是处，在一些上下游非常不稳定的微服务集群中，特别是在一些服务集群跨部门，甚至跨公司的多团队合作项目中，由于缺乏及时有效的沟通，往往更容易造成这样那样的契约破坏，此时，这种基于契约的测试活动，能很好的预警provider的API schema变更对consumer的影响，这是非常有意义的。 最后关于契约测试本身，和契约测试实施的问题，我想，远不止上面诉及的方面。不同的人、不同的团队，对契约测试的理解也可能都不一样，特别是，当一种（比较）新的理念在不同的现实项目中付诸实践时，可能遇到的问题，和思考的方式又会有所迥异，这些都是我们理解一种理念的正常途径。 问题永远都是客观存在的，但解题的思路却可以千奇百怪。我们讨论Pact、Swagger和Spring Cloud Contract，我们辩驳消费者驱动和生产者驱动，我们思考是先写契约测试还是先写功能测试，这些思想的碰撞越多，越能帮助我们去思考、理解和总结，继而产生出更加富有想象力的答案。比如，当需要把provider的schema中的一个String改成Object，从契约的角度，我们还在纠结如何协调所有的consumer影响最小时，“聪明”的小伙伴已经给出了这样一个答案：不把String改成Object，而是直接添加这个Object。 最后，送上我经常讲的一个问题：你知道最简单靠谱的契约测试工具是什么吗？是邮箱！╮(￣▽￣)╭","categories":[],"tags":[]},{"title":"契约测试之Pact By Example","slug":"契约测试之Pact-By-Example","date":"2018-02-28T15:33:51.000Z","updated":"2021-05-16T06:36:37.008Z","comments":true,"path":"2018/02/28/契约测试之Pact-By-Example/","link":"","permalink":"http://yoursite.com/2018/02/28/%E5%A5%91%E7%BA%A6%E6%B5%8B%E8%AF%95%E4%B9%8BPact-By-Example/","excerpt":"如今，契约测试已经逐渐成为测试圈中一个炙手可热的话题，特别是在微服务大行其道的行业背景下，越来越多的团队开始关注服务之间的契约及其契约测试。 从2015年开始我就在Thoughtworks和QA Community里推广契约测试，收到了不错的成效，期间有不少同学和我讨论过如何上手契约测试，发现网上介绍契约测试的讲义、博客不乏其数（当然，质量也参差不齐），可手把手教你写契约测试的文章却几乎没有，原因恐怕就是契约测试的特性吧。契约测试是架设在消费者和服务者之间的一种比较特殊的测试活动，如果你只是想自己学习而又没有合适的项目环境，那你得自己先准备适当的消费者和服务者程序源代码，然后再开始写契约测试，而不是像写个Selenium测试那样，两三行代码就可以随随便便地调戏度娘。～(￣▽￣～) 所以，我花了些时间磨叽出了这片文章……","text":"如今，契约测试已经逐渐成为测试圈中一个炙手可热的话题，特别是在微服务大行其道的行业背景下，越来越多的团队开始关注服务之间的契约及其契约测试。 从2015年开始我就在Thoughtworks和QA Community里推广契约测试，收到了不错的成效，期间有不少同学和我讨论过如何上手契约测试，发现网上介绍契约测试的讲义、博客不乏其数（当然，质量也参差不齐），可手把手教你写契约测试的文章却几乎没有，原因恐怕就是契约测试的特性吧。契约测试是架设在消费者和服务者之间的一种比较特殊的测试活动，如果你只是想自己学习而又没有合适的项目环境，那你得自己先准备适当的消费者和服务者程序源代码，然后再开始写契约测试，而不是像写个Selenium测试那样，两三行代码就可以随随便便地调戏度娘。～(￣▽￣～) 所以，我花了些时间磨叽出了这片文章…… 本文不会涉及契约测试的基本概念，因为相应的文章网上太多了，请大家自己去捞吧。本文也不会讨论契约测试的使用场景以及对其的正确理解，这方面的话题我会在今后另文介绍（好吧，我承认我很懒ㄟ(▔,▔)ㄏ）。 OK，以下开始正文！ 契约测试的精髓在于消费者驱动，实践消费者驱动契约测试的工具主要有Pact，Pacto 和 Spring Cloud Contract，其中Pact是目前最为推荐的，我下面的例子都将使用Pact来练习。Pact最早是用Ruby实现的，目前已经扩展支撑Java，.NET，Javascript，Go，Swift，Python和PHP，其中Java（JVM）是我们目前项目中使用最频繁的，所以我的例子亦都是基于PACT JVM来实现（观众A:我们都用Pyhton，你丫给我说Java(╯°□°）╯︵┻━┻） 示例源码大家可以从Github上获取本文示例的源码，也可以从PACT JVM官网上面找到对应的PACT-JVM-Example链接 示例应用示例应用非常简单，一个服务提供者Provider，两个服务消费者Miku和Nanoha（啥？你不知道Miku和Nanoha是什么？……问度娘吧……(～o￣3￣)～……）。 ProviderProvider是一个简单的API，返回一些个人信息。启动Provider： 1./gradlew :example-provider:bootRun 然后访问 http://localhost:8080/information?name=Miku 或者访问 http://localhost:8080/information?name=Nanoha 消费者 Miku &amp; NanohaMiku和Nanoha调用Provider的API拿到各自的数据，然后显示在前端页面上。启动Miku： 1./gradlew :example-consumer-miku:bootRun 然后用浏览器访问 http://localhost:8081/miku 启动Nanoha： 1./gradlew :example-consumer-nanoha:bootRun 然后用浏览器访问 http://localhost:8082/nanoha Miku和Nanoha做的事情基本一样，差别就是Nanoha会去多拿.nationality这个字段，而.salary这个字段Miku和Nanoha都没有用到。 示例中的1个Provider和2个Consumer都在一个codebase里面，这只是为了方便管理示例代码，而实际的项目中，绝大多数的Provider和Consumer都是在不同的codebase里面管理的，请注意哟！ Provider与Miku间的契约测试好了，大概了解示例应用之后，我们就可以开始写契约测试了（当然，如果你还想再撩撩示例的源码，也是可以的啦，不过相信我，里面没多少油水的） 我们先从Provider和Miku之间的契约测试开始。 请注意”之间”这个关键词，当我们谈论契约测试时，一定要明确它是建立在某一对Provider和Consumer之间的测试活动。没有Provider，Consumer做不了契约测试；没有Consumer，Provider不需要做契约测试。 编写消费者Miku端的测试案例目前，PACT JVM在消费者端的契约测试主要有三种写法： 基本的Junit Junit Rule Junit DSL 它们都能完成消费者端契约文件的生成，只是写法有所不同，带来的代码简洁度和部分功能有些许差异。 所有的契约测试代码都已经写好了，你可以在src/test/java/ariman/pact/consumer下面找到。 基本的Junit“talk is cheap, show you the code” PactBaseConsumerTest.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class PactBaseConsumerTest extends ConsumerPactTestMk2 &#123; @Override @Pact(provider=&quot;ExampleProvider&quot;, consumer=&quot;BaseConsumer&quot;) public RequestResponsePact createPact(PactDslWithProvider builder) &#123; Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); headers.put(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;); return builder .given(&quot;&quot;) .uponReceiving(&quot;Pact JVM example Pact interaction&quot;) .path(&quot;/information&quot;) .query(&quot;fullName=Miku&quot;) .method(&quot;GET&quot;) .willRespondWith() .headers(headers) .status(200) .body(&quot;&#123;\\n&quot; + &quot; \\&quot;salary\\&quot;: 45000,\\n&quot; + &quot; \\&quot;fullName\\&quot;: \\&quot;Hatsune Miku\\&quot;,\\n&quot; + &quot; \\&quot;nationality\\&quot;: \\&quot;Japan\\&quot;,\\n&quot; + &quot; \\&quot;contact\\&quot;: &#123;\\n&quot; + &quot; \\&quot;Email\\&quot;: \\&quot;hatsune.miku@ariman.com\\&quot;,\\n&quot; + &quot; \\&quot;Phone Number\\&quot;: \\&quot;9090950\\&quot;\\n&quot; + &quot; &#125;\\n&quot; + &quot;&#125;&quot;) .toPact(); &#125; @Override protected String providerName() &#123; return &quot;ExampleProvider&quot;; &#125; @Override protected String consumerName() &#123; return &quot;BaseConsumer&quot;; &#125; @Override protected void runTest(MockServer mockServer) throws IOException &#123; ProviderHandler providerHandler = new ProviderHandler(); providerHandler.setBackendURL(mockServer.getUrl()); Information information = providerHandler.getInformation(); assertEquals(information.getName(), &quot;Hatsune Miku&quot;); &#125;&#125; 这里的关键是createPact和runTest这两个方法： createPact直接定义了契约交互的全部内容，比如Request的路径和参数，以及返回的Response的具体内容； runTest是执行测试的方法，其中ProviderHandler是Miku应用代码中的类，我们直接使用它来发送真正的Request，发给谁呢？发给mockServer，Pact会启动一个mockServer, 基于Java原生的HttpServer封装，用来代替真正的Provider应答createPact中定义好的响应内容，继而模拟了整个契约的内容； runTest中的断言可以用来保证我们编写的契约内容是符合Miku期望的，你可以把它理解为一种类似Consumer端的集成测试； Junit RulePactJunitRuleTest.java 12345678910111213141516171819202122232425262728293031323334353637383940public class PactJunitRuleTest &#123; @Rule public PactProviderRuleMk2 mockProvider = new PactProviderRuleMk2(&quot;ExampleProvider&quot;,this); @Pact(consumer=&quot;JunitRuleConsumer&quot;) public RequestResponsePact createPact(PactDslWithProvider builder) &#123; Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); headers.put(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;); return builder .given(&quot;&quot;) .uponReceiving(&quot;Pact JVM example Pact interaction&quot;) .path(&quot;/information&quot;) .query(&quot;fullName=Miku&quot;) .method(&quot;GET&quot;) .willRespondWith() .headers(headers) .status(200) .body(&quot;&#123;\\n&quot; + &quot; \\&quot;salary\\&quot;: 45000,\\n&quot; + &quot; \\&quot;fullName\\&quot;: \\&quot;Hatsune Miku\\&quot;,\\n&quot; + &quot; \\&quot;nationality\\&quot;: \\&quot;Japan\\&quot;,\\n&quot; + &quot; \\&quot;contact\\&quot;: &#123;\\n&quot; + &quot; \\&quot;Email\\&quot;: \\&quot;hatsune.miku@ariman.com\\&quot;,\\n&quot; + &quot; \\&quot;Phone Number\\&quot;: \\&quot;9090950\\&quot;\\n&quot; + &quot; &#125;\\n&quot; + &quot;&#125;&quot;) .toPact(); &#125; @Test @PactVerification public void runTest() &#123; ProviderHandler providerHandler = new ProviderHandler(); providerHandler.setBackendURL(mockProvider.getUrl()); Information information = providerHandler.getInformation(); assertEquals(information.getName(), &quot;Hatsune Miku&quot;); &#125;&#125; 相较于基本的Junit写法，PactProviderRuleMk2能够让代码更加的简洁，它还可以自定义Mock Provider的address和port。如果像上面的代码一样省略address和port，则会默认使用127.0.0.1和随机端口。Junit Rule还提供了方法让你可以同时对多个Provider进行测试，以及让Mock Provider使用HTTPS进行交互。 基于体力有限，本示例没有包含MultiProviders和HTTPS的例子，有需要的同学可以在PACT JVM官网上查询相关的用法……别，别打呀，俺承认，俺就是懒…还打…#$%^&amp;*!@#$%^&amp;…喂：110吗？俺要报警…… Junit DSLPactJunitDSLTest 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class PactJunitDSLTest &#123; private void checkResult(PactVerificationResult result) &#123; if (result instanceof PactVerificationResult.Error) &#123; throw new RuntimeException(((PactVerificationResult.Error)result).getError()); &#125; assertEquals(PactVerificationResult.Ok.INSTANCE, result); &#125; @Test public void testPact1() &#123; Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); headers.put(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;); RequestResponsePact pact = ConsumerPactBuilder .consumer(&quot;JunitDSLConsumer1&quot;) .hasPactWith(&quot;ExampleProvider&quot;) .given(&quot;&quot;) .uponReceiving(&quot;Query fullName is Miku&quot;) .path(&quot;/information&quot;) .query(&quot;fullName=Miku&quot;) .method(&quot;GET&quot;) .willRespondWith() .headers(headers) .status(200) .body(&quot;&#123;\\n&quot; + &quot; \\&quot;salary\\&quot;: 45000,\\n&quot; + &quot; \\&quot;fullName\\&quot;: \\&quot;Hatsune Miku\\&quot;,\\n&quot; + &quot; \\&quot;nationality\\&quot;: \\&quot;Japan\\&quot;,\\n&quot; + &quot; \\&quot;contact\\&quot;: &#123;\\n&quot; + &quot; \\&quot;Email\\&quot;: \\&quot;hatsune.miku@ariman.com\\&quot;,\\n&quot; + &quot; \\&quot;Phone Number\\&quot;: \\&quot;9090950\\&quot;\\n&quot; + &quot; &#125;\\n&quot; + &quot;&#125;&quot;) .toPact(); MockProviderConfig config = MockProviderConfig.createDefault(); PactVerificationResult result = runConsumerTest(pact, config, mockServer -&gt; &#123; ProviderHandler providerHandler = new ProviderHandler(); providerHandler.setBackendURL(mockServer.getUrl(), &quot;Miku&quot;); Information information = providerHandler.getInformation(); assertEquals(information.getName(), &quot;Hatsune Miku&quot;); &#125;); checkResult(result); &#125; @Test public void testPact2() &#123; Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); headers.put(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;); RequestResponsePact pact = ConsumerPactBuilder .consumer(&quot;JunitDSLConsumer2&quot;) .hasPactWith(&quot;ExampleProvider&quot;) .given(&quot;&quot;) .uponReceiving(&quot;Query fullName is Nanoha&quot;) .path(&quot;/information&quot;) .query(&quot;fullName=Nanoha&quot;) .method(&quot;GET&quot;) .willRespondWith() .headers(headers) .status(200) .body(&quot;&#123;\\n&quot; + &quot; \\&quot;salary\\&quot;: 80000,\\n&quot; + &quot; \\&quot;fullName\\&quot;: \\&quot;Takamachi Nanoha\\&quot;,\\n&quot; + &quot; \\&quot;nationality\\&quot;: \\&quot;Japan\\&quot;,\\n&quot; + &quot; \\&quot;contact\\&quot;: &#123;\\n&quot; + &quot; \\&quot;Email\\&quot;: \\&quot;takamachi.nanoha@ariman.com\\&quot;,\\n&quot; + &quot; \\&quot;Phone Number\\&quot;: \\&quot;9090940\\&quot;\\n&quot; + &quot; &#125;\\n&quot; + &quot;&#125;&quot;) .toPact(); MockProviderConfig config = MockProviderConfig.createDefault(); PactVerificationResult result = runConsumerTest(pact, config, mockServer -&gt; &#123; ProviderHandler providerHandler = new ProviderHandler(); providerHandler.setBackendURL(mockServer.getUrl(), &quot;Nanoha&quot;); Information information = providerHandler.getInformation(); assertEquals(information.getName(), &quot;Takamachi Nanoha&quot;); &#125;); checkResult(result); &#125;&#125; 基本的Junit和Junit Rule的写法只能在一个测试文件里面写一个Test Case，而使用Junit DSL则可以像上面的例子一样写多个Test Case。同样，你也可以通过MockProviderConfig.createDefault()配置Mock Server的address和port。上面的例子使用了默认配置。 PactJunitDSLJsonBodyTest 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class PactJunitDSLJsonBodyTest &#123; PactSpecVersion pactSpecVersion; private void checkResult(PactVerificationResult result) &#123; if (result instanceof PactVerificationResult.Error) &#123; throw new RuntimeException(((PactVerificationResult.Error)result).getError()); &#125; assertEquals(PactVerificationResult.Ok.INSTANCE, result); &#125; @Test public void testWithPactDSLJsonBody() &#123; Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); headers.put(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;); DslPart body = new PactDslJsonBody() .numberType(&quot;salary&quot;, 45000) .stringType(&quot;fullName&quot;, &quot;Hatsune Miku&quot;) .stringType(&quot;nationality&quot;, &quot;Japan&quot;) .object(&quot;contact&quot;) .stringValue(&quot;Email&quot;, &quot;hatsune.miku@ariman.com&quot;) .stringValue(&quot;Phone Number&quot;, &quot;9090950&quot;) .closeObject(); RequestResponsePact pact = ConsumerPactBuilder .consumer(&quot;JunitDSLJsonBodyConsumer&quot;) .hasPactWith(&quot;ExampleProvider&quot;) .given(&quot;&quot;) .uponReceiving(&quot;Query fullName is Miku&quot;) .path(&quot;/information&quot;) .query(&quot;fullName=Miku&quot;) .method(&quot;GET&quot;) .willRespondWith() .headers(headers) .status(200) .body(body) .toPact(); MockProviderConfig config = MockProviderConfig.createDefault(this.pactSpecVersion.V3); PactVerificationResult result = runConsumerTest(pact, config, mockServer -&gt; &#123; ProviderHandler providerHandler = new ProviderHandler(); providerHandler.setBackendURL(mockServer.getUrl()); Information information = providerHandler.getInformation(); assertEquals(information.getName(), &quot;Hatsune Miku&quot;); &#125;); checkResult(result); &#125; @Test public void testWithLambdaDSLJsonBody() &#123; Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); headers.put(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;); DslPart body = newJsonBody((root) -&gt; &#123; root.numberValue(&quot;salary&quot;, 45000); root.stringValue(&quot;fullName&quot;, &quot;Hatsune Miku&quot;); root.stringValue(&quot;nationality&quot;, &quot;Japan&quot;); root.object(&quot;contact&quot;, (contactObject) -&gt; &#123; contactObject.stringMatcher(&quot;Email&quot;, &quot;.*@ariman.com&quot;, &quot;hatsune.miku@ariman.com&quot;); contactObject.stringType(&quot;Phone Number&quot;, &quot;9090950&quot;); &#125;); &#125;).build(); RequestResponsePact pact = ConsumerPactBuilder .consumer(&quot;JunitDSLLambdaJsonBodyConsumer&quot;) .hasPactWith(&quot;ExampleProvider&quot;) .given(&quot;&quot;) .uponReceiving(&quot;Query fullName is Miku&quot;) .path(&quot;/information&quot;) .query(&quot;fullName=Miku&quot;) .method(&quot;GET&quot;) .willRespondWith() .headers(headers) .status(200) .body(body) .toPact(); MockProviderConfig config = MockProviderConfig.createDefault(this.pactSpecVersion.V3); PactVerificationResult result = runConsumerTest(pact, config, mockServer -&gt; &#123; ProviderHandler providerHandler = new ProviderHandler(); providerHandler.setBackendURL(mockServer.getUrl()); Information information = providerHandler.getInformation(); assertEquals(information.getName(), &quot;Hatsune Miku&quot;); &#125;); checkResult(result); &#125;&#125; 当然，Junit DSL的强大之处绝不仅仅是让你多写几个Test Case， 通过使用PactDslJsonBody和Lambda DSL你可以更好的编写你的契约测试文件： 对契约中Response Body的内容，使用JsonBody代替简单的字符串，可以让你的代码易读性更好； JsonBody提供了强大的Check By Type和Check By Value的功能，让你可以控制对Provider的Response测试精度。比如，对于契约中的某个字段，你是要确保Provider的返回必须是具体某个数值（check by Value），还是只要数据类型相同就可以（check by type），比如都是String或者Int。你甚至可以直接使用正则表达式来做更加灵活的验证； 目前支持的匹配验证方法： method description string, stringValue Match a string value (using string equality) number, numberValue Match a number value (using Number.equals)* booleanValue Match a boolean value (using equality) stringType Will match all Strings numberType Will match all numbers* integerType Will match all numbers that are integers (both ints and longs)* decimalType Will match all real numbers (floating point and decimal)* booleanType Will match all boolean values (true and false) stringMatcher Will match strings using the provided regular expression timestamp Will match string containing timestamps. If a timestamp format is not given, will match an ISO timestamp format date Will match string containing dates. If a date format is not given, will match an ISO date format time Will match string containing times. If a time format is not given, will match an ISO time format ipAddress Will match string containing IP4 formatted address. id Will match all numbers by type hexValue Will match all hexadecimal encoded strings uuid Will match strings containing UUIDs includesStr Will match strings containing the provided string equalsTo Will match using equals matchUrl Defines a matcher for URLs, given the base URL path and a sequence of path fragments. The path fragments could be strings or regular expression matchers 对于Array和Map这样的数据结构，DSL也有相应匹配验证方法，我这里就不罗列了，请参考官网的介绍； 执行Miku端的测试Test Case准备好后，我们就可以执行测试了。因为我们实际上是用的Junit的框架，所以和执行一般的单元测试是一样的： 1./gradlew :example-consumer-miku:clean test 成功执行后，你就可以在Pacts\\Miku下面找到所有测试生成的契约文件。 发布契约文件到Pact Broker契约文件，也就是Pacts\\Miku下面的那些JSON文件，可以用来驱动Provider端的契约测试。由于我们的示例把Consumer和Provider都放在了同一个Codebase下面，所以Pacts\\Miku下面的契约文件对Provider是直接可见的，而真实的项目中，往往不是这样，你需要通过某种途径把契约文件从Consumer端发送给Provider端。你可以选择把契约文件SCP到Provider的测试服务器去，也可以选择使用中间文件服务器来共享契约文件，你甚至可以直接人肉发邮件把契约文件扔给Provider的团队，然后告诉他们“这是我们的契约，你们看着办吧~”（当然，这样很Low …），这些都是可行的。显然，Pact提供了更加优雅的方式，那就是使用Pact Broker。 当你准备好Broker后，就可以用它来方便的实现真正的消费者驱动的契约测试了。 好吧，我得承认，“准备”这两个字我用得有些轻描淡写，实际的情况是你可能需要费一番周折才能弄好一个Broker服务。目前有好些方法可以搭建Broker服务，你可以直接下载官网的源码然后自己折腾，也可以使用Docker来个一键了事，更可以直接找Pact官方申请一个公共的Broker，当然，那样做就得暴露你的契约给第三方服务器，真实的产品项目多半是不行的，但如果只是学习，那就事半功倍了，比如我们当前的这个示例就是如此。 将契约文件上传到Broker服务器非常简单： 1./gradlew :example-consumer-miku:pactPublish 然后你会在命令行下面看到类似这样的输出： 12345678&gt; Task :example-consumer-miku:pactPublish Publishing JunitDSLConsumer1-ExampleProvider.json ... HTTP/1.1 200 OKPublishing JunitDSLJsonBodyConsumer-ExampleProvider.json ... HTTP/1.1 200 OKPublishing JunitDSLLambdaJsonBodyConsumer-ExampleProvider.json ... HTTP/1.1 200 OKPublishing BaseConsumer-ExampleProvider.json ... HTTP/1.1 200 OKPublishing JunitRuleConsumer-ExampleProvider.json ... HTTP/1.1 200 OKPublishing JunitRuleMultipleInteractionsConsumer-ExampleProvider.json ... HTTP/1.1 200 OKPublishing JunitDSLConsumer2-ExampleProvider.json ... HTTP/1.1 200 OK 上传完成之后，你就可以在我们的Broker服务器上面看到对于的契约内容了。 值得说明的是，你可以看到上面我们有7个Consumer对应1个Provdier。在真实的项目中，不应该是这样的，因为现在我们实际上只有一个Consumer Miku。我只是在不同的契约文件中对Consumer的名字做了不同的命名，目的只是展示一下Broker的这个漂亮的调用关系图。这只是一个示例，仅此而已。 至此，Pact测试中，Consumer端的工作我们就全部搞定了，剩下的就是Provider的活了。 Provider端的测试在Provider端，我们使用Gradle的Plugin来执行契约测试，非常的简单，不需要写一行测试代码： 1./gradlew :example-provider:pactVerify 在Provider端执行契约测试之前，我们需要先启动Provider的应用。虽然通过gradle我们可以配置自动关停应用，但对于初学者，我还是建议大家多手动捣鼓捣鼓，不然你都不知道这个测试是怎么个跑法。啥？不知道怎么启动Provider？自己去本文的开头部分找去 … 然后，你可以在命令行下面看到类似这样的输出： 1234567891011121314151617181920212223242526272829303132333435363738394041424344Arimans-MacBook-Pro:pact-jvm-example ariman$ ./gradlew :example-provider:pactVerify&gt; Task :example-provider:pactVerify_ExampleProviderVerifying a pact between Miku - Base contract and ExampleProvider [Using File /Users/ariman/Workspace/Pacting/pact-jvm-example/Pacts/Miku/BaseConsumer-ExampleProvider.json] Given WARNING: State Change ignored as there is no stateChange URL Consumer Miku returns a response which has status code 200 (OK) includes headers &quot;Content-Type&quot; with value &quot;application/json;charset=UTF-8&quot; (OK) has a matching body (OK) Given WARNING: State Change ignored as there is no stateChange URL Pact JVM example Pact interaction returns a response which has status code 200 (OK) includes headers &quot;Content-Type&quot; with value &quot;application/json;charset=UTF-8&quot; (OK) has a matching body (OK) ... Verifying a pact between JunitRuleMultipleInteractionsConsumer and ExampleProvider [from Pact Broker https://ariman.pact.dius.com.au/pacts/provider/ExampleProvider/consumer/JunitRuleMultipleInteractionsConsumer/version/1.0.0] Given WARNING: State Change ignored as there is no stateChange URL Miku returns a response which has status code 200 (OK) includes headers &quot;Content-Type&quot; with value &quot;application/json;charset=UTF-8&quot; (OK) has a matching body (OK) Given WARNING: State Change ignored as there is no stateChange URL Nanoha returns a response which has status code 200 (OK) includes headers &quot;Content-Type&quot; with value &quot;application/json;charset=UTF-8&quot; (OK) has a matching body (OK) 从上面的结果可以看出，我们的测试既使用了来自本地的契约文件，也使用了来自Broker的契约文件。 由于我们示例使用的Broker服务器是公共的，任何调戏我们这个示例应用的小伙伴都能上传他们自己的契约文件，其中难免会存在错误的契约。所以，如果你发现来自Broker的契约让你的测试挂掉了，请不要惊慌哟。当然，因为是公共服务器，我会不定时的清空里面的契约文件，所以哪天你要是发现你之前上传的契约文件没有了，也不必大惊小怪。 相关的Gradle配置OK，Provider和Miku感情故事我们就讲完了。在讲Nanoha之前，先让我们来看看Gradle的一些配置内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263project(&#x27;:example-consumer-miku&#x27;) &#123; ... test &#123; systemProperties[&#x27;pact.rootDir&#x27;] = &quot;$rootDir/Pacts/Miku&quot; &#125; pact &#123; publish &#123; pactDirectory = &quot;$rootDir/Pacts/Miku&quot; pactBrokerUrl = mybrokerUrl pactBrokerUsername = mybrokerUser pactBrokerPassword = mybrokerPassword &#125; &#125; ...&#125;project(&#x27;:example-consumer-nanoha&#x27;) &#123; ... test &#123; systemProperties[&#x27;pact.rootDir&#x27;] = &quot;$rootDir/Pacts/Nanoha&quot; &#125; ...&#125;import java.net.URLproject(&#x27;:example-provider&#x27;) &#123; ... pact &#123; serviceProviders &#123; ExampleProvider &#123; protocol = &#x27;http&#x27; host = &#x27;localhost&#x27; port = 8080 path = &#x27;/&#x27; // Test Pacts from local Miku hasPactWith(&#x27;Miku - Base contract&#x27;) &#123; pactSource = file(&quot;$rootDir/Pacts/Miku/BaseConsumer-ExampleProvider.json&quot;) &#125; hasPactsWith(&#x27;Miku - All contracts&#x27;) &#123; pactFileLocation = file(&quot;$rootDir/Pacts/Miku&quot;) &#125; // Test Pacts from Pact Broker hasPactsFromPactBroker(mybrokerUrl, authentication: [&#x27;Basic&#x27;, mybrokerUser, mybrokerPassword]) // Test Pacts from local Nanoha // hasPactWith(&#x27;Nanoha - With Nantionality&#x27;) &#123; // pactSource = file(&quot;$rootDir/Pacts/Nanoha/ConsumerNanohaWithNationality-ExampleProvider.json&quot;) // &#125; // hasPactWith(&#x27;Nanoha - No Nantionality&#x27;) &#123; // stateChangeUrl = new URL(&#x27;http://localhost:8080/pactStateChange&#x27;) // pactSource = file(&quot;$rootDir/Pacts/Nanoha/ConsumerNanohaNoNationality-ExampleProvider.json&quot;) // &#125; &#125; &#125; &#125; &#125; Gradle的配置也是非常的简单的，Provider，Miku和Nanoha作为三个单独的应用，都是独立配置的，其中的一些关键信息： systemProperties[&#39;pact.rootDir&#39;] 指定了我们生成契约文件的路径； Miku中的pact &#123; ... &#125;定义了我们Pact Broker的服务器地址，以及我们访问时需要的认证信息。 如果你想通过浏览器访问Broker，比如看上面的关系图，你也是需要这个认证信息的。这里的配置使用的是变量，真正的用户名和密码在哪儿？不告诉你，自己在代码里面找找吧(￣▽￣)~* Provider的hasPactWith()和hasPactsWith()指定了执行PactVerify时会去搜索的本地路径，相应的，hasPactsFromPactBroker则是指定了Broker的服务器地址； 为什么要注释掉Nanoha的契约文件路径呢？因为目前我们还没有生成Nanoha的契约文件，如果不注释掉它们的话，测试会报找不到文件的错误。我们可以在之后生成完Nanoha的契约文件后，再打开注释； Provider与Nanoha间的契约测试Nanoha端的契约测试和Miku端大同小异，只是我们会在Nanoha端使用ProviderState的特性。关于ProviderState的具体含义，大家可以参见官网的介绍. 准备Provider端的ProviderStateProvider会返回一个.nationality的字段，在真实项目里，它的值可能来自数据库（当然，也可能来自更下一层的API调用）。在我们的示例里面，简单起见，直接使用了Static的属性来模拟数据的存储：provider.ulti.Nationality 1234567891011public class Nationality &#123; private static String nationality = &quot;Japan&quot;; public static String getNationality() &#123; return nationality; &#125; public static void setNationality(String nationality) &#123; Nationality.nationality = nationality; &#125;&#125; 然后，通过修改.nationality就可以模拟对存储数据的修改。所以，我们定义了一个控制器pactController，在/pactStateChange上面接受POST的reqeust来修改.nationality：provider.PactController 123456789101112131415161718@Profile(&quot;pact&quot;)@RestControllerpublic class PactController &#123; @RequestMapping(value = &quot;/pactStateChange&quot;, method = RequestMethod.POST) public void providerState(@RequestBody PactState body) &#123; switch (body.getState()) &#123; case &quot;No nationality&quot;: Nationality.setNationality(null); System.out.println(&quot;Pact State Change &gt;&gt; remove nationality ...&quot;); break; case &quot;Default nationality&quot;: Nationality.setNationality(&quot;Japan&quot;); System.out.println(&quot;Pact Sate Change &gt;&gt; set default nationality ...&quot;); break; &#125; &#125;&#125; 因为这个控制器只是用来测试的，所以它应该只在非产品环境下才能可见，所以我们使用了一个pact的Profile Annotation来限制这个控制器只能在使用pact的profile时才能可见。 OK，总结一下就是：当Provider使用pact的profile运行时，它会在URL/pactStateChange上接受一个POST请求，来修改.nationality的值，再具体一些，可以被设置成默认值Japan，或者null。 Nanoha端的契约测试Nanoha端的测试文件和Miku端的差不多，我们使用Lambda DSL，在一个文件里面写两个TestCase。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class NationalityPactTest &#123; PactSpecVersion pactSpecVersion; private void checkResult(PactVerificationResult result) &#123; if (result instanceof PactVerificationResult.Error) &#123; throw new RuntimeException(((PactVerificationResult.Error)result).getError()); &#125; assertEquals(PactVerificationResult.Ok.INSTANCE, result); &#125; @Test public void testWithNationality() &#123; Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); headers.put(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;); DslPart body = newJsonBody((root) -&gt; &#123; root.numberType(&quot;salary&quot;); root.stringValue(&quot;fullName&quot;, &quot;Takamachi Nanoha&quot;); root.stringValue(&quot;nationality&quot;, &quot;Japan&quot;); root.object(&quot;contact&quot;, (contactObject) -&gt; &#123; contactObject.stringMatcher(&quot;Email&quot;, &quot;.*@ariman.com&quot;, &quot;takamachi.nanoha@ariman.com&quot;); contactObject.stringType(&quot;Phone Number&quot;, &quot;9090940&quot;); &#125;); &#125;).build(); RequestResponsePact pact = ConsumerPactBuilder .consumer(&quot;ConsumerNanohaWithNationality&quot;) .hasPactWith(&quot;ExampleProvider&quot;) .given(&quot;&quot;) .uponReceiving(&quot;Query fullName is Nanoha&quot;) .path(&quot;/information&quot;) .query(&quot;fullName=Nanoha&quot;) .method(&quot;GET&quot;) .willRespondWith() .headers(headers) .status(200) .body(body) .toPact(); MockProviderConfig config = MockProviderConfig.createDefault(this.pactSpecVersion.V3); PactVerificationResult result = runConsumerTest(pact, config, mockServer -&gt; &#123; ProviderHandler providerHandler = new ProviderHandler(); providerHandler.setBackendURL(mockServer.getUrl()); Information information = providerHandler.getInformation(); assertEquals(information.getName(), &quot;Takamachi Nanoha&quot;); assertEquals(information.getNationality(), &quot;Japan&quot;); &#125;); checkResult(result); &#125; @Test public void testNoNationality() &#123; Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); headers.put(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;); DslPart body = newJsonBody((root) -&gt; &#123; root.numberType(&quot;salary&quot;); root.stringValue(&quot;fullName&quot;, &quot;Takamachi Nanoha&quot;); root.stringValue(&quot;nationality&quot;, null); root.object(&quot;contact&quot;, (contactObject) -&gt; &#123; contactObject.stringMatcher(&quot;Email&quot;, &quot;.*@ariman.com&quot;, &quot;takamachi.nanoha@ariman.com&quot;); contactObject.stringType(&quot;Phone Number&quot;, &quot;9090940&quot;); &#125;); &#125;).build(); RequestResponsePact pact = ConsumerPactBuilder .consumer(&quot;ConsumerNanohaNoNationality&quot;) .hasPactWith(&quot;ExampleProvider&quot;) .given(&quot;No nationality&quot;) .uponReceiving(&quot;Query fullName is Nanoha&quot;) .path(&quot;/information&quot;) .query(&quot;fullName=Nanoha&quot;) .method(&quot;GET&quot;) .willRespondWith() .headers(headers) .status(200) .body(body) .toPact(); MockProviderConfig config = MockProviderConfig.createDefault(this.pactSpecVersion.V3); PactVerificationResult result = runConsumerTest(pact, config, mockServer -&gt; &#123; ProviderHandler providerHandler = new ProviderHandler(); providerHandler.setBackendURL(mockServer.getUrl()); Information information = providerHandler.getInformation(); assertEquals(information.getName(), &quot;Takamachi Nanoha&quot;); assertEquals(information.getNationality(), null); &#125;); checkResult(result); &#125;&#125; 这两个TestCase的主要区别是： 我们对nationality的期望一个Japan，一个是null； 通过.given()方法来指定我们的ProviderState，从而控制在Provider端运行测试之前修改对应nationality的值； Consumer端运行测试的方式还是一样的： 1./gradlew :example-consumer-nanoha:clean test 然后，就可以在Pacts\\Nanoha路径下面找到生成的契约文件了。 Provider端的契约测试启动Provider的应用上面我们提到，运行Provider需要使用pact的profile，所以现在启动Provider的命令会有所不同： 12export SPRING_PROFILES_ACTIVE=pact./gradlew :example-provider:bootRun 如果你之前已经启动了Provider，记得要kill掉哟，不然会端口占用的啦~ 修改Gradle配置文件我们在Consumer的契约中，使用.given()指定了ProviderState，但说到底，那里指定的只是一个字符串而已，真正干活的，还是Gradle，所以我们需要Gradle的相关配置：build.gralde 123456789hasPactWith(&#x27;Nanoha - With Nantionality&#x27;) &#123; pactSource = file(&quot;$rootDir/Pacts/Nanoha/ConsumerNanohaWithNationality-ExampleProvider.json&quot;)&#125;hasPactWith(&#x27;Nanoha - No Nantionality&#x27;) &#123; stateChangeUrl = new URL(&#x27;http://localhost:8080/pactStateChange&#x27;) pactSource = file(&quot;$rootDir/Pacts/Nanoha/ConsumerNanohaNoNationality-ExampleProvider.json&quot;)&#125; 这里，我们取消了之前对Nanoha的注释。第一个TestCase我们会测试使用默认的nationality=Japan。第二个TestCase，我们指定了stateChangeUrl，它会保证在测试运行之前，先发送一个POST请求给这个URL，然后我们的TestCase测试nationality=null。 执行契约测试同样的方法执行契约测试： 1./gradlew :example-provider:pactVerify 然后你就可以在命令行下面看见对应的输出了。 验证我们的测试如果你一字不漏的玩儿到了这里，那么恭喜你，你应该可以在自己的项目里去实践Pact了（好了，那个抄椅子的同学，你不用说了，我知道，你们用的是Python╮(╯_╰)╭）。 但是在离开本示例之前，还是发扬一下我们的测试精神吧，比如，搞点小破坏~ 在Provider返回的body里面，Miku和Nanoha都有使用字段.name。如果某天，Provider想把.name改成.fullname，估计Miku和Nanoha就要跪了。这是一种经典的契约破坏场景，用来做我们的玩儿法再适合不过了。可是要那么玩儿的话，需要修改Provider的好些代码，想必不少测试的同学，特别是对Spring Boot不了解的同学就又要拍砖了。 所以还是让我们来个简单的吧，比如霸王硬上弓，直接把.name给miku了，哦，不对，是null了。provider.InformationController 1234567@RestControllerpublic class InformationController &#123; ... information.setName(null); return information; &#125;&#125; 喂，喂，干坐着干嘛，动手改呀！这行代码可是需要你们自己加上去的哟，即便它已经简单到只有一行。然后，那个写Python的，别告诉我你看不懂information.setName(null)，Okay？￣▽￣ 最后，重新运行我们的契约测试，你就能看到一些长得像这样的东东啦~： 123456789101112131415161718...Verifying a pact between Nanoha - No Nantionality and ExampleProvider [Using File /Users/ariman/Workspace/Pacting/pact-jvm-example/Pacts/Nanoha/ConsumerNanohaNoNationality-ExampleProvider.json] Given No nationality Query name is Nanoha returns a response which has status code 200 (OK) includes headers &quot;Content-Type&quot; with value &quot;application/json;charset=UTF-8&quot; (OK) has a matching body (FAILED)Failures:0) Verifying a pact between Miku - Base contract and ExampleProvider - Pact JVM example Pact interactionVerifying a pact between Miku - Base contract and ExampleProvider - Pact JVM example Pact interaction Given returns a response which has a matching body $.name -&gt; Expected &#x27;Hatsune Miku&#x27; but received null...","categories":[],"tags":[]}]}